(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],p=0,d=[];p<s.length;p++)i=s[p],Object.prototype.hasOwnProperty.call(o,i)&&o[i]&&d.push(o[i][0]),o[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);d.length;)d.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==o[l]&&(r=!1)}r&&(a.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},o={1:0},a=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"2b230d09",3:"8d07a58d",4:"4a01c80f",5:"8131f67b",6:"0adc3b01",7:"beb00f25",8:"f5786dd6",9:"da181e7b",10:"101b3fed",11:"3b9e3fef",12:"8e274cde",13:"8ad384a1",14:"d6a265a3",15:"f180a310",16:"5cee3905",17:"c11974c8",18:"0351b4d7",19:"78df4dab",20:"d611b348",21:"401f56de",22:"43eade43",23:"10e40ba9",24:"9d91e228",25:"69ae2b46",26:"904bcf11",27:"d003fb91",28:"223da5d2",29:"7915e793",30:"626578d3",31:"66686722",32:"41c02487",33:"6eca7fe3",34:"a4574b0c",35:"9952d665",36:"d58e704e",37:"74f417b8",38:"d265bec6",39:"c8e2e1d9",40:"6dccc139",41:"e89fc606",42:"ad076000",43:"f88c1817",44:"2bfa4525",45:"5d707a21",46:"bf1448d4",47:"1a4ed767",48:"c7f5fb83",49:"87adef4c",50:"1ecc818a",51:"ead5073a",52:"c3c2b4cc",53:"24a7c1d3",54:"ee1b717e",55:"feee73ee",56:"a23db923",57:"c0a53eef",58:"8f25eec8",59:"6748549c",60:"5ed88e96",61:"23b1e0d2",62:"f3b58e21",63:"fe02f331",64:"514a446c",65:"3bf4e200",66:"7c600553"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}o[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/leonBlog/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;a.push([96,0]),t()}([function(n,e,t){"use strict";var r=function(n){return n&&n.Math===Math&&n};n.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||r("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";var r="object"==typeof document&&document.all;n.exports=void 0===r&&void 0!==r?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var r=t(27),o=Function.prototype,a=o.call,i=r&&o.bind.bind(a,a);n.exports=r?i:function(n){return function(){return a.apply(n,arguments)}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var r=t(2);n.exports=!r((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){"use strict";var r=t(1);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(68),o="object"==typeof self&&self&&self.Object===Object&&self,a=r||o||Function("return this")();n.exports=a},function(n,e,t){"use strict";function r(n,e,t,r,o,a,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):o&&(l=s?function(){o.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:o),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var p=c.beforeCreate;c.beforeCreate=p?[].concat(p,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(3),o=t(36),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(o(n),e)}},function(n,e,t){var r=t(163),o=t(166);n.exports=function(n,e){var t=o(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return f})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return y})),t.d(e,"a",(function(){return x}));t(24);const r=/#.*$/,o=/\.(md|html)$/,a=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(o,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function p(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",o=s(n);return a.test(o)?n:o+".html"+t}function d(n,e){const t=n.hash,o=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(o&&t!==o)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const o=e.split("/");t&&o[o.length-1]||o.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?o.pop():"."!==e&&o.push(e)}""!==o[0]&&o.unshift("");return o.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:p(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function f(n,e,t,r){const{pages:o,themeConfig:a}=t,i=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||i.sidebar||a.sidebar))return h(n);const s=i.sidebar||a.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?h(n):r?r.map(n=>function n(e,t,r,o=1){if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});{o>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,o+1)),collapsable:!1!==e.collapsable}}}(n,o,t)):[]}return[]}function h(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function y(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function v(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return v(e)-v(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(15),o=t(148),a=t(149),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?o(n):a(n)}},function(n,e,t){"use strict";var r=t(5),o=t(17),a=t(28);n.exports=r?function(n,e,t){return o.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(7).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(3),o=r({}.toString),a=r("".slice);n.exports=function(n){return a(o(n),8,-1)}},function(n,e,t){"use strict";var r=t(5),o=t(61),a=t(105),i=t(62),s=t(52),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),o)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(153),o=t(154),a=t(155),i=t(156),s=t(157);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(70);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(175);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(45);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,p=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var o;return(o="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,o}(n,u,p)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var o,i=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),u=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(o=e.querySelector(r.spinnerSelector))&&d(o),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,o=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((r=n[o]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,o,a=arguments;if(2==a.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&r(n,t,o);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=p(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=p(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=o)},function(n,e,t){"use strict";var r=t(25),o=t(36),a=t(37),i=t(142),s=t(144);r({target:"Array",proto:!0,arity:1,forced:t(2)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=o(this),t=a(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return i(e,t),t}})},function(n,e,t){"use strict";var r=t(0),o=t(49).f,a=t(14),i=t(106),s=t(35),l=t(64),c=t(122);n.exports=function(n,e){var t,u,p,d,m,f=n.target,h=n.global,g=n.stat;if(t=h?r:g?r[f]||s(f,{}):r[f]&&r[f].prototype)for(u in e){if(d=e[u],p=n.dontCallGetSet?(m=o(t,u))&&m.value:t[u],!c(h?u:f+(g?".":"#")+u,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;l(d,p)}(n.sham||p&&p.sham)&&a(d,"sham",!0),i(t,u,d,n)}}},function(n,e,t){"use strict";var r=t(27),o=Function.prototype.call;n.exports=r?o.bind(o):function(){return o.apply(o,arguments)}},function(n,e,t){"use strict";var r=t(2);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var r=t(50),o=t(30);n.exports=function(n){return r(o(n))}},function(n,e,t){"use strict";var r=t(51),o=TypeError;n.exports=function(n){if(r(n))throw new o("Can't call method on "+n);return n}},function(n,e,t){"use strict";var r=t(0),o=t(1),a=function(n){return o(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";var r=t(1),o=t(102),a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(o(n)+" is not a function")}},function(n,e,t){"use strict";var r=t(0),o=t(58),a=t(9),i=t(60),s=t(56),l=t(55),c=r.Symbol,u=o("wks"),p=l?c.for||c:c&&c.withoutSetter||i;n.exports=function(n){return a(u,n)||(u[n]=s&&a(c,n)?c[n]:p("Symbol."+n)),u[n]}},function(n,e,t){"use strict";var r=t(59),o=t(0),a=t(35),i=n.exports=o["__core-js_shared__"]||a("__core-js_shared__",{});(i.versions||(i.versions=[])).push({version:"3.37.1",mode:r?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var r=t(0),o=Object.defineProperty;n.exports=function(n,e){try{o(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){"use strict";var r=t(30),o=Object;n.exports=function(n){return o(r(n))}},function(n,e,t){"use strict";var r=t(119);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(147),o=t(12),a=Object.prototype,i=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return o(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(7),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(167),o=t(174),a=t(176),i=t(177),s=t(178);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(4),o=t(45),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(i.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(13),o=t(12);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,a=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,p=Math.max,d=Math.min,m=function(){return c.Date.now()};function f(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(f(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=f(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=o.test(n);return s||a.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,o,a,i,s,l,c=0,u=!1,g=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=r,a=o;return r=o=void 0,c=e,i=n.apply(a,t)}function v(n){return c=n,s=setTimeout(w,e),u?y(n):i}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function w(){var n=m();if(x(n))return k(n);s=setTimeout(w,function(n){var t=e-(n-l);return g?d(t,a-(n-c)):t}(n))}function k(n){return s=void 0,b&&r?y(n):(r=o=void 0,i)}function T(){var n=m(),t=x(n);if(r=arguments,o=this,l=n,t){if(void 0===s)return v(l);if(g)return s=setTimeout(w,e),y(l)}return void 0===s&&(s=setTimeout(w,e)),i}return e=h(e)||0,f(t)&&(u=!!t.leading,a=(g="maxWait"in t)?p(h(t.maxWait)||0,e):a,b="trailing"in t?!!t.trailing:b),T.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=o=s=void 0},T.flush=function(){return void 0===s?i:k(m())},T}},function(n,e,t){"use strict";var r=t(5),o=t(26),a=t(98),i=t(28),s=t(29),l=t(52),c=t(9),u=t(61),p=Object.getOwnPropertyDescriptor;e.f=r?p:function(n,e){if(n=s(n),e=l(e),u)try{return p(n,e)}catch(n){}if(c(n,e))return i(!o(a.f,n,e),n[e])}},function(n,e,t){"use strict";var r=t(3),o=t(2),a=t(16),i=Object,s=r("".split);n.exports=o((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"===a(n)?s(n,""):i(n)}:i},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var r=t(99),o=t(53);n.exports=function(n){var e=r(n,"string");return o(e)?e:e+""}},function(n,e,t){"use strict";var r=t(31),o=t(1),a=t(54),i=t(55),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return o(e)&&a(e.prototype,s(n))}},function(n,e,t){"use strict";var r=t(3);n.exports=r({}.isPrototypeOf)},function(n,e,t){"use strict";var r=t(56);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var r=t(57),o=t(2),a=t(0).String;n.exports=!!Object.getOwnPropertySymbols&&!o((function(){var n=Symbol("symbol detection");return!a(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){"use strict";var r,o,a=t(0),i=t(100),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(o=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!o&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(o=+r[1]),n.exports=o},function(n,e,t){"use strict";var r=t(34);n.exports=function(n,e){return r[n]||(r[n]=e||{})}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var r=t(3),o=0,a=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++o+a,36)}},function(n,e,t){"use strict";var r=t(5),o=t(2),a=t(104);n.exports=!r&&!o((function(){return 7!==Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var r=t(6),o=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a(o(n)+" is not an object")}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";var r=t(9),o=t(113),a=t(49),i=t(17);n.exports=function(n,e,t){for(var s=o(e),l=i.f,c=a.f,u=0;u<s.length;u++){var p=s[u];r(n,p)||t&&r(t,p)||l(n,p,c(e,p))}}},function(n,e,t){"use strict";var r=t(118);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){"use strict";var r=t(129),o=t(6),a=t(30),i=t(130);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),i(r),o(t)?(e?n(t,r):t.__proto__=r,t):t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,o=n.length;++t<r;)n[o+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(18),o=t(158),a=t(159),i=t(160),s=t(161),l=t(162);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=o,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(13),o=t(40);n.exports=function(n){if(!o(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(179),o=t(12);n.exports=function n(e,t,a,i,s){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:r(e,t,a,i,n,s))}},function(n,e,t){var r=t(75),o=t(182),a=t(76);n.exports=function(n,e,t,i,s,l){var c=1&t,u=n.length,p=e.length;if(u!=p&&!(c&&p>u))return!1;var d=l.get(n),m=l.get(e);if(d&&m)return d==e&&m==n;var f=-1,h=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++f<u;){var b=n[f],y=e[f];if(i)var v=c?i(y,b,f,e,n,l):i(b,y,f,n,e,l);if(void 0!==v){if(v)continue;h=!1;break}if(g){if(!o(e,(function(n,e){if(!a(g,e)&&(b===n||s(b,n,t,i,l)))return g.push(e)}))){h=!1;break}}else if(b!==y&&!s(b,y,t,i,l)){h=!1;break}}return l.delete(n),l.delete(e),h}},function(n,e,t){var r=t(41),o=t(180),a=t(181);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=o,i.prototype.has=a,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(192),o=t(198),a=t(81);n.exports=function(n){return a(n)?r(n):o(n)}},function(n,e,t){(function(n){var r=t(7),o=t(194),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||o;n.exports=l}).call(this,t(47)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(195),o=t(196),a=t(197),i=a&&a.isTypedArray,s=i?o(i):r;n.exports=s},function(n,e,t){var r=t(71),o=t(43);n.exports=function(n){return null!=n&&o(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(7),"Set");n.exports=r},function(n,e,t){var r=t(40);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(86),o=t(22);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[o(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(4),o=t(44),a=t(209),i=t(212);n.exports=function(n,e){return r(n)?n:o(n,e)?[n]:a(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(145),o=t(150),a=t(221),i=t(229),s=t(238),l=t(95),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),o(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,o=r.exec(t);if(!o)return t;var a="",i=0,s=0;for(i=o.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(a+=t.substring(s,i)),s=i+1,a+=e}return s!==i?a+t.substring(s,i):a}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},o=(t(241),t(8)),a=Object(o.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},o=(t(242),t(8)),a=Object(o.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(247)},function(n,e,t){"use strict";var r=t(25),o=t(123).left,a=t(124),i=t(57);r({target:"Array",proto:!0,forced:!t(125)&&i>79&&i<83||!a("reduce")},{reduce:function(n){var e=arguments.length;return o(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,a=o&&!r.call({1:2},1);e.f=a?function(n){var e=o(this,n);return!!e&&e.enumerable}:r},function(n,e,t){"use strict";var r=t(26),o=t(6),a=t(53),i=t(101),s=t(103),l=t(33),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!o(n)||a(n))return n;var t,l=i(n,u);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!o(t)||a(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){"use strict";var r=t(32),o=t(51);n.exports=function(n,e){var t=n[e];return o(t)?void 0:r(t)}},function(n,e,t){"use strict";var r=String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var r=t(26),o=t(1),a=t(6),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&o(t=n.toString)&&!a(s=r(t,n)))return s;if(o(t=n.valueOf)&&!a(s=r(t,n)))return s;if("string"!==e&&o(t=n.toString)&&!a(s=r(t,n)))return s;throw new i("Can't convert object to primitive value")}},function(n,e,t){"use strict";var r=t(0),o=t(6),a=r.document,i=o(a)&&o(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},function(n,e,t){"use strict";var r=t(5),o=t(2);n.exports=r&&o((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var r=t(1),o=t(17),a=t(107),i=t(35);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&a(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:o.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";var r=t(3),o=t(2),a=t(1),i=t(9),s=t(5),l=t(108).CONFIGURABLE,c=t(109),u=t(110),p=u.enforce,d=u.get,m=String,f=Object.defineProperty,h=r("".slice),g=r("".replace),b=r([].join),y=s&&!o((function(){return 8!==f((function(){}),"length",{value:8}).length})),v=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===h(m(e),0,7)&&(e="["+g(m(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||l&&n.name!==e)&&(s?f(n,"name",{value:e,configurable:!0}):n.name=e),y&&t&&i(t,"arity")&&n.length!==t.arity&&f(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?s&&f(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=p(n);return i(r,"source")||(r.source=b(v,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return a(this)&&d(this).source||c(this)}),"toString")},function(n,e,t){"use strict";var r=t(5),o=t(9),a=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=o(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&i(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var r=t(3),o=t(1),a=t(34),i=r(Function.toString);o(a.inspectSource)||(a.inspectSource=function(n){return i(n)}),n.exports=a.inspectSource},function(n,e,t){"use strict";var r,o,a,i=t(111),s=t(0),l=t(6),c=t(14),u=t(9),p=t(34),d=t(112),m=t(63),f=s.TypeError,h=s.WeakMap;if(i||p.state){var g=p.state||(p.state=new h);g.get=g.get,g.has=g.has,g.set=g.set,r=function(n,e){if(g.has(n))throw new f("Object already initialized");return e.facade=n,g.set(n,e),e},o=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var b=d("state");m[b]=!0,r=function(n,e){if(u(n,b))throw new f("Object already initialized");return e.facade=n,c(n,b,e),e},o=function(n){return u(n,b)?n[b]:{}},a=function(n){return u(n,b)}}n.exports={set:r,get:o,has:a,enforce:function(n){return a(n)?o(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=o(e)).type!==n)throw new f("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(0),o=t(1),a=r.WeakMap;n.exports=o(a)&&/native code/.test(String(a))},function(n,e,t){"use strict";var r=t(58),o=t(60),a=r("keys");n.exports=function(n){return a[n]||(a[n]=o(n))}},function(n,e,t){"use strict";var r=t(31),o=t(3),a=t(114),i=t(121),s=t(62),l=o([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r=t(115),o=t(120).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,o)}},function(n,e,t){"use strict";var r=t(3),o=t(9),a=t(29),i=t(116).indexOf,s=t(63),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,u=[];for(t in r)!o(s,t)&&o(r,t)&&l(u,t);for(;e.length>c;)o(r,t=e[c++])&&(~i(u,t)||l(u,t));return u}},function(n,e,t){"use strict";var r=t(29),o=t(117),a=t(37),i=function(n){return function(e,t,i){var s=r(e),l=a(s);if(0===l)return!n&&-1;var c,u=o(i,l);if(n&&t!=t){for(;l>u;)if((c=s[u++])!=c)return!0}else for(;l>u;u++)if((n||u in s)&&s[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){"use strict";var r=t(65),o=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?o(t+e,0):a(t,e)}},function(n,e,t){"use strict";var r=Math.ceil,o=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?o:r)(e)}},function(n,e,t){"use strict";var r=t(65),o=Math.min;n.exports=function(n){var e=r(n);return e>0?o(e,9007199254740991):0}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var r=t(2),o=t(1),a=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t===u||t!==c&&(o(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",u=i.POLYFILL="P";n.exports=i},function(n,e,t){"use strict";var r=t(32),o=t(36),a=t(50),i=t(37),s=TypeError,l="Reduce of empty array with no initial value",c=function(n){return function(e,t,c,u){var p=o(e),d=a(p),m=i(p);if(r(t),0===m&&c<2)throw new s(l);var f=n?m-1:0,h=n?-1:1;if(c<2)for(;;){if(f in d){u=d[f],f+=h;break}if(f+=h,n?f<0:m<=f)throw new s(l)}for(;n?f>=0:m>f;f+=h)f in d&&(u=t(u,d[f],f,p));return u}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r=t(2);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var r=t(0),o=t(16);n.exports="process"===o(r.process)},function(n,e,t){"use strict";var r=t(25),o=t(0),a=t(127),i=t(128),s=o.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){"use strict";var r=t(27),o=Function.prototype,a=o.apply,i=o.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(a):function(){return i.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(31),o=t(9),a=t(14),i=t(54),s=t(66),l=t(64),c=t(132),u=t(133),p=t(134),d=t(138),m=t(139),f=t(5),h=t(59);n.exports=function(n,e,t,g){var b=g?2:1,y=n.split("."),v=y[y.length-1],x=r.apply(null,y);if(x){var w=x.prototype;if(!h&&o(w,"cause")&&delete w.cause,!t)return x;var k=r("Error"),T=e((function(n,e){var t=p(g?e:n,void 0),r=g?new x(n):new x;return void 0!==t&&a(r,"message",t),m(r,T,r.stack,2),this&&i(w,this)&&u(r,this,T),arguments.length>b&&d(r,arguments[b]),r}));if(T.prototype=w,"Error"!==v?s?s(T,k):l(T,k,{name:!0}):f&&"stackTraceLimit"in x&&(c(T,x,"stackTraceLimit"),c(T,x,"prepareStackTrace")),l(T,x),!h)try{w.name!==v&&a(w,"name",v),w.constructor=T}catch(n){}return T}}},function(n,e,t){"use strict";var r=t(3),o=t(32);n.exports=function(n,e,t){try{return r(o(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var r=t(131),o=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw new a("Can't set "+o(n)+" as a prototype")}},function(n,e,t){"use strict";var r=t(6);n.exports=function(n){return r(n)||null===n}},function(n,e,t){"use strict";var r=t(17).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),o=t(6),a=t(66);n.exports=function(n,e,t){var i,s;return a&&r(i=e.constructor)&&i!==t&&o(s=i.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){"use strict";var r=t(135);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){"use strict";var r=t(136),o=String;n.exports=function(n){if("Symbol"===r(n))throw new TypeError("Cannot convert a Symbol value to a string");return o(n)}},function(n,e,t){"use strict";var r=t(137),o=t(1),a=t(16),i=t(33)("toStringTag"),s=Object,l="Arguments"===a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?a(e):"Object"===(r=a(e))&&o(e.callee)?"Arguments":r}},function(n,e,t){"use strict";var r={};r[t(33)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){"use strict";var r=t(6),o=t(14);n.exports=function(n,e){r(e)&&"cause"in e&&o(n,"cause",e.cause)}},function(n,e,t){"use strict";var r=t(14),o=t(140),a=t(141),i=Error.captureStackTrace;n.exports=function(n,e,t,s){a&&(i?i(n,e):r(n,"stack",o(t,s)))}},function(n,e,t){"use strict";var r=t(3),o=Error,a=r("".replace),i=String(new o("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!o.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){"use strict";var r=t(2),o=t(28);n.exports=!r((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",o(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(5),o=t(143),a=TypeError,i=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(o(n)&&!i(n,"length").writable)throw new a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var r=t(16);n.exports=Array.isArray||function(n){return"Array"===r(n)}},function(n,e,t){"use strict";var r=TypeError;n.exports=function(n){if(n>9007199254740991)throw r("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(67),o=t(146);n.exports=function n(e,t,a,i,s){var l=-1,c=e.length;for(a||(a=o),s||(s=[]);++l<c;){var u=e[l];t>0&&a(u)?t>1?n(u,t-1,a,i,s):r(s,u):i||(s[s.length]=u)}return s}},function(n,e,t){var r=t(15),o=t(38),a=t(4),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||o(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(13),o=t(12);n.exports=function(n){return o(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(15),o=Object.prototype,a=o.hasOwnProperty,i=o.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var o=i.call(n);return r&&(e?n[s]=t:delete n[s]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(151),o=t(207),a=t(46),i=t(4),s=t(218);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?i(n)?o(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(152),o=t(206),a=t(84);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(69),o=t(73);n.exports=function(n,e,t,a){var i=t.length,s=i,l=!a;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var u=(c=t[i])[0],p=n[u],d=c[1];if(l&&c[2]){if(void 0===p&&!(u in n))return!1}else{var m=new r;if(a)var f=a(p,d,u,n,e,m);if(!(void 0===f?o(d,p,3,a,m):f))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(19),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(19);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(19);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(19);n.exports=function(n,e){var t=this.__data__,o=r(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var r=t(18);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(18),o=t(39),a=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!o||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(71),o=t(164),a=t(40),i=t(72),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,p=c.hasOwnProperty,d=RegExp("^"+u.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||o(n))&&(r(n)?d:s).test(i(n))}},function(n,e,t){var r,o=t(165),a=(r=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(7)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(168),o=t(18),a=t(39);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||o),string:new r}}},function(n,e,t){var r=t(169),o=t(170),a=t(171),i=t(172),s=t(173);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(20);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(20),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(20),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(21);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=r(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var r=t(69),o=t(74),a=t(183),i=t(186),s=t(202),l=t(4),c=t(78),u=t(80),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,f,h){var g=l(n),b=l(e),y=g?"[object Array]":s(n),v=b?"[object Array]":s(e),x=(y="[object Arguments]"==y?p:y)==p,w=(v="[object Arguments]"==v?p:v)==p,k=y==v;if(k&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(k&&!x)return h||(h=new r),g||u(n)?o(n,e,t,m,f,h):a(n,e,y,t,m,f,h);if(!(1&t)){var T=x&&d.call(n,"__wrapped__"),E=w&&d.call(e,"__wrapped__");if(T||E){var S=T?n.value():n,j=E?e.value():e;return h||(h=new r),f(S,j,t,m,h)}}return!!k&&(h||(h=new r),i(n,e,t,m,f,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(15),o=t(184),a=t(70),i=t(74),s=t(185),l=t(42),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,p,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var f=1&r;if(m||(m=l),n.size!=e.size&&!f)return!1;var h=d.get(n);if(h)return h==e;r|=2,d.set(n,e);var g=i(m(n),m(e),r,c,p,d);return d.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(7).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(187),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,i,s){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var p=u;p--;){var d=c[p];if(!(l?d in e:o.call(e,d)))return!1}var m=s.get(n),f=s.get(e);if(m&&f)return m==e&&f==n;var h=!0;s.set(n,e),s.set(e,n);for(var g=l;++p<u;){var b=n[d=c[p]],y=e[d];if(a)var v=l?a(y,b,d,e,n,s):a(b,y,d,n,e,s);if(!(void 0===v?b===y||i(b,y,t,a,s):v)){h=!1;break}g||(g="constructor"==d)}if(h&&!g){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var r=t(188),o=t(189),a=t(77);n.exports=function(n){return r(n,a,o)}},function(n,e,t){var r=t(67),o=t(4);n.exports=function(n,e,t){var a=e(n);return o(n)?a:r(a,t(n))}},function(n,e,t){var r=t(190),o=t(191),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return a.call(n,e)})))}:o;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=0,a=[];++t<r;){var i=n[t];e(i,t,n)&&(a[o++]=i)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(193),o=t(38),a=t(4),i=t(78),s=t(79),l=t(80),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&o(n),p=!t&&!u&&i(n),d=!t&&!u&&!p&&l(n),m=t||u||p||d,f=m?r(n.length,String):[],h=f.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||p&&("offset"==g||"parent"==g)||d&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,h))||f.push(g);return f}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(13),o=t(43),a=t(12),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&o(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(68),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,i=a&&a.exports===o&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(47)(n))},function(n,e,t){var r=t(199),o=t(200),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return o(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(201)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(203),o=t(39),a=t(204),i=t(82),s=t(205),l=t(13),c=t(72),u=c(r),p=c(o),d=c(a),m=c(i),f=c(s),h=l;(r&&"[object DataView]"!=h(new r(new ArrayBuffer(1)))||o&&"[object Map]"!=h(new o)||a&&"[object Promise]"!=h(a.resolve())||i&&"[object Set]"!=h(new i)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case m:return"[object Set]";case f:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var r=t(10)(t(7),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(7),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(7),"WeakMap");n.exports=r},function(n,e,t){var r=t(83),o=t(77);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var a=e[t],i=n[a];e[t]=[a,i,r(i)]}return e}},function(n,e,t){var r=t(73),o=t(208),a=t(215),i=t(44),s=t(83),l=t(84),c=t(22);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=o(t,n);return void 0===i&&i===e?a(t,n):r(e,i,3)}}},function(n,e,t){var r=t(85);n.exports=function(n,e,t){var o=null==n?void 0:r(n,e);return void 0===o?t:o}},function(n,e,t){var r=t(210),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,r,o){e.push(r?o.replace(a,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(211);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(41);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=e?e.apply(this,r):r[0],a=t.cache;if(a.has(o))return a.get(o);var i=n.apply(this,r);return t.cache=a.set(o,i)||a,i};return t.cache=new(o.Cache||r),t}o.Cache=r,n.exports=o},function(n,e,t){var r=t(213);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(15),o=t(214),a=t(4),i=t(45),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return o(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=Array(r);++t<r;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var r=t(216),o=t(217);n.exports=function(n,e){return null!=n&&o(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(86),o=t(38),a=t(4),i=t(79),s=t(43),l=t(22);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,p=!1;++c<u;){var d=l(e[c]);if(!(p=null!=n&&t(n,d)))break;n=n[d]}return p||++c!=u?p:!!(u=null==n?0:n.length)&&s(u)&&i(d,u)&&(a(n)||o(n))}},function(n,e,t){var r=t(219),o=t(220),a=t(44),i=t(22);n.exports=function(n){return a(n)?r(i(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(85);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(46),o=t(222),a=t(224);n.exports=function(n,e){return a(o(n,e,r),n+"")}},function(n,e,t){var r=t(223),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var a=arguments,i=-1,s=o(a.length-e,0),l=Array(s);++i<s;)l[i]=a[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=a[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(225),o=t(228)(r);n.exports=o},function(n,e,t){var r=t(226),o=t(227),a=t(46),i=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),o=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var o=t(),a=16-(o-r);if(r=o,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(75),o=t(230),a=t(235),i=t(76),s=t(236),l=t(42);n.exports=function(n,e,t){var c=-1,u=o,p=n.length,d=!0,m=[],f=m;if(t)d=!1,u=a;else if(p>=200){var h=e?null:s(n);if(h)return l(h);d=!1,u=i,f=new r}else f=e?[]:m;n:for(;++c<p;){var g=n[c],b=e?e(g):g;if(g=t||0!==g?g:0,d&&b==b){for(var y=f.length;y--;)if(f[y]===b)continue n;e&&f.push(b),m.push(g)}else u(f,b,t)||(f!==m&&f.push(b),m.push(g))}return m}},function(n,e,t){var r=t(231);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(232),o=t(233),a=t(234);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,o,t)}},function(n,e){n.exports=function(n,e,t,r){for(var o=n.length,a=t+(r?1:-1);r?a--:++a<o;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,o=n.length;++r<o;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,o=null==n?0:n.length;++r<o;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(82),o=t(237),a=t(42),i=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:o;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(81),o=t(12);n.exports=function(n){return o(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(87)},function(n,e,t){"use strict";t(88)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),o=Array.isArray;function a(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function d(n){return"[object Object]"===p.call(n)}function m(n){return"[object RegExp]"===p.call(n)}function f(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===p?JSON.stringify(n,b,2):String(n)}function b(n,e){return e&&e.__v_isRef?e.value:e}function y(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),r=n.split(","),o=0;o<r.length;o++)t[r[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var x=v("key,ref,slot,slot-scope,is");function w(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var k=Object.prototype.hasOwnProperty;function T(n,e){return k.call(n,e)}function E(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,j=E((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),_=E((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),A=/\B([A-Z])/g,C=E((function(n){return n.replace(A,"-$1").toLowerCase()}));var z=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function I(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function P(n,e){for(var t in e)n[t]=e[t];return n}function O(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function $(n,e,t){}var B=function(n,e,t){return!1},D=function(n){return n};function M(n,e){if(n===e)return!0;var t=u(n),r=u(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var o=Array.isArray(n),a=Array.isArray(e);if(o&&a)return n.length===e.length&&n.every((function(n,t){return M(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||a)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return M(n[t],e[t])}))}catch(n){return!1}}function F(n,e){for(var t=0;t<n.length;t++)if(M(n[t],e))return t;return-1}function R(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function L(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var N=["component","directive","filter"],q=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],U={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:$,parsePlatformTagName:D,mustUseProp:B,async:!0,_lifecycleHooks:q},J=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function V(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function H(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var W=new RegExp("[^".concat(J.source,".$_\\d]"));var G="__proto__"in{},K="undefined"!=typeof window,Z=K&&window.navigator.userAgent.toLowerCase(),X=Z&&/msie|trident/.test(Z),Y=Z&&Z.indexOf("msie 9.0")>0,Q=Z&&Z.indexOf("edge/")>0;Z&&Z.indexOf("android");var nn=Z&&/iphone|ipad|ipod|ios/.test(Z);Z&&/chrome\/\d+/.test(Z),Z&&/phantomjs/.test(Z);var en,tn=Z&&Z.match(/firefox\/(\d+)/),rn={}.watch,on=!1;if(K)try{var an={};Object.defineProperty(an,"passive",{get:function(){on=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var sn=function(){return void 0===en&&(en=!K&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=K&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var un,pn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);un="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function mn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var fn=function(){function n(n,e,t,r,o,a,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=o,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new fn;return e.text=n,e.isComment=!0,e};function gn(n){return new fn(void 0,void 0,void 0,String(n))}function bn(n){var e=new fn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var yn=0,vn=[],xn=function(){function n(){this._pending=!1,this.id=yn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();xn.target=null;var wn=[];function kn(n){wn.push(n),xn.target=n}function Tn(){wn.pop(),xn.target=wn[wn.length-1]}var En=Array.prototype,Sn=Object.create(En);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=En[n];H(Sn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var o,a=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&i.observeArray(o),i.dep.notify(),a}))}));var jn=Object.getOwnPropertyNames(Sn),_n={},An=!0;function Cn(n){An=n}var zn={notify:$,depend:$,addSub:$,removeSub:$},In=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?zn:new xn,this.vmCount=0,H(n,"__ob__",this),o(n)){if(!t)if(G)n.__proto__=Sn;else for(var r=0,a=jn.length;r<a;r++){H(n,s=jn[r],Sn[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(r=0;r<i.length;r++){var s;On(n,s=i[r],_n,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){return n&&T(n,"__ob__")&&n.__ob__ instanceof In?n.__ob__:!An||!t&&sn()||!o(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||Ln(n)||n instanceof fn?void 0:new In(n,e,t)}function On(n,e,t,r,a,i,s){void 0===s&&(s=!1);var l=new xn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var u=c&&c.get,p=c&&c.set;u&&!p||t!==_n&&2!==arguments.length||(t=n[e]);var d=a?t&&t.__ob__:Pn(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=u?u.call(n):t;return xn.target&&(l.depend(),d&&(d.dep.depend(),o(e)&&Dn(e))),Ln(e)&&!a?e.value:e},set:function(e){var r=u?u.call(n):t;if(L(r,e)){if(p)p.call(n,e);else{if(u)return;if(!a&&Ln(r)&&!Ln(e))return void(r.value=e);t=e}d=a?e&&e.__ob__:Pn(e,!1,i),l.notify()}}}),l}}function $n(n,e,t){if(!Rn(n)){var r=n.__ob__;return o(n)&&f(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(On(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Bn(n,e){if(o(n)&&f(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Rn(n)||T(n,e)&&(delete n[e],t&&t.dep.notify())}}function Dn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),o(e)&&Dn(e)}function Mn(n){return Fn(n,!0),H(n,"__v_isShallow",!0),n}function Fn(n,e){if(!Rn(n)){Pn(n,e,sn());0}}function Rn(n){return!(!n||!n.__v_isReadonly)}function Ln(n){return!(!n||!0!==n.__v_isRef)}function Nn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Ln(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Ln(r)&&!Ln(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var qn;var Un=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=qn,!n&&qn&&(this.index=(qn.scopes||(qn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=qn;try{return qn=this,n()}finally{qn=e}}else 0},n.prototype.on=function(){qn=this},n.prototype.off=function(){qn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Jn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Vn=E((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!o(n))return Ae(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)Ae(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Wn(n,e,t,r,o,i){var l,c,u,p;for(l in n)c=n[l],u=e[l],p=Vn(l),a(c)||(a(u)?(a(c.fns)&&(c=n[l]=Hn(c,i)),s(p.once)&&(c=n[l]=o(p.name,c,p.capture)),t(p.name,c,p.capture,p.passive,p.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)a(n[l])&&r((p=Vn(l)).name,e[l],p.capture)}function Gn(n,e,t){var r;n instanceof fn&&(n=n.data.hook||(n.data.hook={}));var o=n[e];function l(){t.apply(this,arguments),w(r.fns,l)}a(o)?r=Hn([l]):i(o.fns)&&s(o.merged)?(r=o).fns.push(l):r=Hn([o,l]),r.merged=!0,n[e]=r}function Kn(n,e,t,r,o){if(i(e)){if(T(e,t))return n[t]=e[t],o||delete e[t],!0;if(T(e,r))return n[t]=e[r],o||delete e[r],!0}return!1}function Zn(n){return l(n)?[gn(n)]:o(n)?function n(e,t){var r,c,u,p,d=[];for(r=0;r<e.length;r++)a(c=e[r])||"boolean"==typeof c||(u=d.length-1,p=d[u],o(c)?c.length>0&&(Xn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Xn(p)&&(d[u]=gn(p.text+c[0].text),c.shift()),d.push.apply(d,c)):l(c)?Xn(p)?d[u]=gn(p.text+c):""!==c&&d.push(gn(c)):Xn(c)&&Xn(p)?d[u]=gn(p.text+c.text):(s(e._isVList)&&i(c.tag)&&a(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),d.push(c)));return d}(n):void 0}function Xn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Yn(n,e){var t,r,a,s,l=null;if(o(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),p=c.next();!p.done;)l.push(e(p.value,l.length)),p=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,r=a.length;t<r;t++)s=a[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function Qn(n,e,t,r){var o,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=P(P({},r),t)),o=a(t)||(c(e)?e():e)):o=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},o):o}function ne(n){return It(this.$options,"filters",n,!0)||D}function ee(n,e){return o(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,r,o){var a=U.keyCodes[e]||t;return o&&r&&!U.keyCodes[e]?ee(o,r):a?ee(a,n):r?C(r)!==e:void 0===n}function re(n,e,t,r,a){if(t)if(u(t)){o(t)&&(t=O(t));var i=void 0,s=function(o){if("class"===o||"style"===o||x(o))i=n;else{var s=n.attrs&&n.attrs.type;i=r||U.mustUseProp(e,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(o),c=C(o);l in i||c in i||(i[o]=t[o],a&&((n.on||(n.on={}))["update:".concat(o)]=function(n){t[o]=n}))};for(var l in t)s(l)}else;return n}function oe(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ie(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return ie(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ie(n,e,t){if(o(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&se(n[r],"".concat(e,"_").concat(r),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(d(e)){var t=n.on=n.on?P({},n.on):{};for(var r in e){var o=t[r],a=e[r];t[r]=o?[].concat(o,a):a}}else;return n}function ce(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var i=n[a];o(i)?ce(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function ue(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function pe(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=ae,n._n=y,n._s=g,n._l=Yn,n._t=Qn,n._q=M,n._i=F,n._m=oe,n._f=ne,n._k=te,n._b=re,n._v=gn,n._e=hn,n._u=ce,n._g=le,n._d=ue,n._p=pe}function me(n,e){if(!n||!n.length)return{};for(var t={},r=0,o=n.length;r<o;r++){var a=n[r],i=a.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,a.context!==e&&a.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(a);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(fe)&&delete t[c];return t}function fe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,o){var a,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&o&&o!==r&&l===o.$key&&!i&&!o.$hasNormal)return o;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=be(n,t,c,e[c]))}else a={};for(var u in t)u in a||(a[u]=ye(t,u));return e&&Object.isExtensible(e)&&(e._normalized=a),H(a,"$stable",s),H(a,"$key",l),H(a,"$hasNormal",i),a}function be(n,e,t,r){var a=function(){var e=dn;mn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!o(t)?[t]:Zn(t))&&t[0];return mn(e),t&&(!a||1===t.length&&a.isComment&&!he(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function ye(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};H(e,"_v_attr_proxy",!0),xe(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||ke(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:z(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Nn(n,e,t)}))}}}function xe(n,e,t,r,o){var a=!1;for(var i in e)i in n?e[i]!==t[i]&&(a=!0):(a=!0,we(n,i,r,o));for(var i in n)i in e||(a=!0,delete n[i]);return a}function we(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function ke(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Te=null;function Ee(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function Se(n){if(o(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||he(t)))return t}}function je(n,e,t,r,p,d){return(o(t)||l(t))&&(p=r,r=t,t=void 0),s(d)&&(p=2),function(n,e,t,r,l){if(i(t)&&i(t.__ob__))return hn();i(t)&&i(t.is)&&(e=t.is);if(!e)return hn();0;o(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Zn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(o(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var p,d;if("string"==typeof e){var m=void 0;d=n.$vnode&&n.$vnode.ns||U.getTagNamespace(e),p=U.isReservedTag(e)?new fn(U.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(m=It(n.$options,"components",e))?new fn(e,t,r,void 0,void 0,n):wt(m,t,n,r,e)}else p=wt(e,t,n,r);return o(p)?p:i(p)?(i(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var o=0,l=e.children.length;o<l;o++){var c=e.children[o];i(c.tag)&&(a(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(p,d),i(t)&&function(n){u(n.style)&&Ue(n.style);u(n.class)&&Ue(n.class)}(t),p):hn()}(n,e,t,r,p)}function _e(n,e,t){kn();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var a=0;a<o.length;a++)try{if(!1===o[a].call(r,n,e,t))return}catch(n){Ce(n,r,"errorCaptured hook")}}Ce(n,e,t)}finally{Tn()}}function Ae(n,e,t,r,o){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&h(a)&&!a._handled&&(a.catch((function(n){return _e(n,r,o+" (Promise/async)")})),a._handled=!0)}catch(n){_e(n,r,o)}return a}function Ce(n,e,t){if(U.errorHandler)try{return U.errorHandler.call(null,n,e,t)}catch(e){e!==n&&ze(e,null,"config.errorHandler")}ze(n,e,t)}function ze(n,e,t){if(!K||"undefined"==typeof console)throw n;console.error(n)}var Ie,Pe=!1,Oe=[],$e=!1;function Be(){$e=!1;var n=Oe.slice(0);Oe.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var De=Promise.resolve();Ie=function(){De.then(Be),nn&&setTimeout($)},Pe=!0}else if(X||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ie="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Be)}:function(){setTimeout(Be,0)};else{var Me=1,Fe=new MutationObserver(Be),Re=document.createTextNode(String(Me));Fe.observe(Re,{characterData:!0}),Ie=function(){Me=(Me+1)%2,Re.data=String(Me)},Pe=!0}function Le(n,e){var t;if(Oe.push((function(){if(n)try{n.call(e)}catch(n){_e(n,e,"nextTick")}else t&&t(e)})),$e||($e=!0,Ie()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ne(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var r=n.$options;r[e]=_t(r[e],t)}(t,n,e)}}Ne("beforeMount"),Ne("mounted"),Ne("beforeUpdate"),Ne("updated"),Ne("beforeDestroy"),Ne("destroyed"),Ne("activated"),Ne("deactivated"),Ne("serverPrefetch"),Ne("renderTracked"),Ne("renderTriggered"),Ne("errorCaptured");var qe=new un;function Ue(n){return function n(e,t){var r,a,i=o(e);if(!i&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof fn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(r=e.length;r--;)n(e[r],t);else if(Ln(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,qe),qe.clear(),n}var Je,Ve=0,He=function(){function n(n,e,t,r,o){var a,i;a=this,void 0===(i=qn&&!qn._vm?qn:n?n._scope:void 0)&&(i=qn),i&&i.active&&i.effects.push(a),(this.vm=n)&&o&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ve,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new un,this.newDepIds=new un,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!W.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=$)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;kn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;_e(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ue(n),Tn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ae(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&w(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function We(n,e){Je.$on(n,e)}function Ge(n,e){Je.$off(n,e)}function Ke(n,e){var t=Je;return function r(){var o=e.apply(null,arguments);null!==o&&t.$off(n,r)}}function Ze(n,e,t){Je=n,Wn(e,t||{},We,Ge,Ke,n),Je=void 0}var Xe=null;function Ye(n){var e=Xe;return Xe=n,function(){Xe=e}}function Qe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Qe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,r){void 0===r&&(r=!0),kn();var o=dn,a=qn;r&&mn(n);var i=n.$options[e],s="".concat(e," hook");if(i)for(var l=0,c=i.length;l<c;l++)Ae(i[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),r&&(mn(o),a&&a.on()),Tn()}var tt=[],rt=[],ot={},at=!1,it=!1,st=0;var lt=0,ct=Date.now;if(K&&!X){var ut=window.performance;ut&&"function"==typeof ut.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return ut.now()})}var pt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(lt=ct(),it=!0,tt.sort(pt),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,ot[e]=null,n.run();var t=rt.slice(),r=tt.slice();st=tt.length=rt.length=0,ot={},at=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),ln&&U.devtools&&ln.emit("flush")}function mt(n){var e=n.id;if(null==ot[e]&&(n!==xn.target||!n.noRecurse)){if(ot[e]=!0,it){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);at||(at=!0,Le(dt))}}function ft(n,e){if(n){for(var t=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),o=0;o<r.length;o++){var a=r[o];if("__ob__"!==a){var i=n[a].from;if(i in e._provided)t[a]=e._provided[i];else if("default"in n[a]){var s=n[a].default;t[a]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,a,i){var l,c=this,u=i.options;T(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var p=s(u._compiled),d=!p;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=ft(u.inject,a),this.slots=function(){return c.$slots||ge(a,n.scopedSlots,c.$slots=me(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(a,n.scopedSlots,this.slots())}}),p&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=ge(a,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,r){var i=je(l,n,e,t,r,d);return i&&!o(i)&&(i.fnScopeId=u._scopeId,i.fnContext=a),i}:this._c=function(n,e,t,r){return je(l,n,e,t,r,d)}}function gt(n,e,t,r,o){var a=bn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function bt(n,e){for(var t in e)n[j(t)]=e[t]}function yt(n){return n.name||n.__name||n._componentTag}de(ht.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,a){var i=o.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o),n.$options._renderChildren=a;var p=o.data.attrs||r;n._attrsProxy&&xe(n._attrsProxy,p,u.data&&u.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=p,t=t||r;var d=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,d||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ze(n,t,d),e&&n.$options.props){Cn(!1);for(var m=n._props,f=n.$options._propKeys||[],h=0;h<f.length;h++){var g=f[h],b=n.$options.props;m[g]=Pt(g,b,e,n)}Cn(!0),n.$options.propsData=e}c&&(n.$slots=me(a,o.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Qe(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(vt);function wt(n,e,t,l,c){if(!a(n)){var p=t.$options._base;if(u(n)&&(n=p.extend(n)),"function"==typeof n){var d;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=Te;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],o=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return w(r,t)}));var p=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},d=R((function(t){n.resolved=Ee(t,e),o?r.length=0:p(!0)})),m=R((function(e){i(n.errorComp)&&(n.error=!0,p(!0))})),f=n(d,m);return u(f)&&(h(f)?a(n.resolved)&&f.then(d,m):h(f.component)&&(f.component.then(d,m),i(f.error)&&(n.errorComp=Ee(f.error,e)),i(f.loading)&&(n.loadingComp=Ee(f.loading,e),0===f.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,p(!1))}),f.delay||200)),i(f.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&m(null)}),f.timeout)))),o=!1,n.loading?n.loadingComp:n.resolved}}(d=n,p)))return function(n,e,t,r,o){var a=hn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:o},a}(d,e,t,l,c);e=e||{},Ht(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[r],l=e.model.callback;i(s)?(o(s)?-1===s.indexOf(l):s!==l)&&(a[r]=[l].concat(s)):a[r]=l}(n.options,e);var m=function(n,e,t){var r=e.options.props;if(!a(r)){var o={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var u=C(c);Kn(o,l,c,u,!0)||Kn(o,s,c,u,!1)}return o}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var l=n.options,c={},u=l.props;if(i(u))for(var p in u)c[p]=Pt(p,u,e||r);else i(t.attrs)&&bt(c,t.attrs),i(t.props)&&bt(c,t.props);var d=new ht(t,c,s,a,n),m=l.render.call(null,d._c,d);if(m instanceof fn)return gt(m,t,d.parent,l,d);if(o(m)){for(var f=Zn(m)||[],h=new Array(f.length),g=0;g<f.length;g++)h[g]=gt(f[g],t,d.parent,l,d);return h}}(n,m,e,t,l);var f=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var r=xt[t],o=e[r],a=vt[r];o===a||o&&o._merged||(e[r]=o?kt(a,o):a)}}(e);var b=yt(n.options)||c;return new fn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:f,tag:c,children:l},d)}}}function kt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var Tt=$,Et=U.optionMergeStrategies;function St(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,o,a,i=pn?Reflect.ownKeys(e):Object.keys(e),s=0;s<i.length;s++)"__ob__"!==(r=i[s])&&(o=n[r],a=e[r],t&&T(n,r)?o!==a&&d(o)&&d(a)&&St(o,a):$n(n,r,a));return n}function jt(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,o=c(n)?n.call(t,t):n;return r?St(r,o):o}:e?n?function(){return St(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function _t(n,e){var t=e?n?n.concat(e):o(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function At(n,e,t,r){var o=Object.create(n||null);return e?P(o,e):o}Et.data=function(n,e,t){return t?jt(n,e,t):e&&"function"!=typeof e?n:jt(n,e)},q.forEach((function(n){Et[n]=_t})),N.forEach((function(n){Et[n+"s"]=At})),Et.watch=function(n,e,t,r){if(n===rn&&(n=void 0),e===rn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var i in P(a,n),e){var s=a[i],l=e[i];s&&!o(s)&&(s=[s]),a[i]=s?s.concat(l):o(l)?l:[l]}return a},Et.props=Et.methods=Et.inject=Et.computed=function(n,e,t,r){if(!n)return e;var o=Object.create(null);return P(o,n),e&&P(o,e),o},Et.provide=function(n,e){return n?function(){var t=Object.create(null);return St(t,c(n)?n.call(this):n),e&&St(t,c(e)?e.call(this):e,!1),t}:e};var Ct=function(n,e){return void 0===e?n:e};function zt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,i={};if(o(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(i[j(a)]={type:null});else if(d(t))for(var s in t)a=t[s],i[j(s)]=d(a)?a:{type:a};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(o(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(d(t))for(var i in t){var s=t[i];r[i]=d(s)?P({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=zt(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=zt(n,e.mixins[r],t);var i,s={};for(i in n)l(i);for(i in e)T(n,i)||l(i);function l(r){var o=Et[r]||Ct;s[r]=o(n[r],e[r],t,r)}return s}function It(n,e,t,r){if("string"==typeof t){var o=n[e];if(T(o,t))return o[t];var a=j(t);if(T(o,a))return o[a];var i=_(a);return T(o,i)?o[i]:o[t]||o[a]||o[i]}}function Pt(n,e,t,r){var o=e[n],a=!T(t,n),i=t[n],s=Dt(Boolean,o.type);if(s>-1)if(a&&!T(o,"default"))i=!1;else if(""===i||i===C(n)){var l=Dt(String,o.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!T(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==$t(e.type)?r.call(n):r}(r,o,n);var u=An;Cn(!0),Pn(i),Cn(u)}return i}var Ot=/^\s*function (\w+)/;function $t(n){var e=n&&n.toString().match(Ot);return e?e[1]:""}function Bt(n,e){return $t(n)===$t(e)}function Dt(n,e){if(!o(e))return Bt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Bt(e[t],n))return t;return-1}var Mt={enumerable:!0,configurable:!0,get:$,set:$};function Ft(n,e,t){Mt.get=function(){return this[e][t]},Mt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Mt)}function Rt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Mn({}),o=n.$options._propKeys=[];n.$parent&&Cn(!1);var a=function(a){o.push(a);var i=Pt(a,e,t,n);On(r,a,i,void 0,!0),a in n||Ft(n,"_props",a)};for(var i in e)a(i);Cn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ve(n);mn(n),kn();var o=Ae(t,null,[n._props||Mn({}),r],n,"setup");if(Tn(),mn(),c(o))e.render=o;else if(u(o))if(n._setupState=o,o.__sfc){var a=n._setupProxy={};for(var i in o)"__sfc"!==i&&Nn(a,o,i)}else for(var i in o)V(i)||Nn(n,o,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?$:z(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=c(e)?function(n,e){kn();try{return n.call(e,e)}catch(n){return _e(n,e,"data()"),{}}finally{Tn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var a=t[o];0,r&&T(r,a)||V(a)||Ft(n,"_data",a)}var i=Pn(e);i&&i.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=sn();for(var o in e){var a=e[o],i=c(a)?a:a.get;0,r||(t[o]=new He(n,i||$,$,Lt)),o in n||Nt(n,o,a)}}(n,e.computed),e.watch&&e.watch!==rn&&function(n,e){for(var t in e){var r=e[t];if(o(r))for(var a=0;a<r.length;a++)Jt(n,t,r[a]);else Jt(n,t,r)}}(n,e.watch)}var Lt={lazy:!0};function Nt(n,e,t){var r=!sn();c(t)?(Mt.get=r?qt(e):Ut(t),Mt.set=$):(Mt.get=t.get?r&&!1!==t.cache?qt(e):Ut(t.get):$,Mt.set=t.set||$),Object.defineProperty(n,e,Mt)}function qt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function Ut(n){return function(){return n.call(this,this)}}function Jt(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Vt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var o in t)t[o]!==r[o]&&(e||(e={}),e[o]=t[o]);return e}(n);r&&P(n.extendOptions,r),(e=n.options=zt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Wt(n){this._init(n)}function Gt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,o=n._Ctor||(n._Ctor={});if(o[r])return o[r];var a=yt(n)||yt(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=zt(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)Ft(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)Nt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,N.forEach((function(n){i[n]=t[n]})),a&&(i.options.components[a]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=P({},i.options),o[r]=i,i}}function Kt(n){return n&&(yt(n.Ctor.options)||n.tag)}function Zt(n,e){return o(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Xt(n,e){var t=n.cache,r=n.keys,o=n._vnode,a=n.$vnode;for(var i in t){var s=t[i];if(s){var l=s.name;l&&!e(l)&&Yt(t,i,r,o)}}a.componentOptions.children=void 0}function Yt(n,e,t,r){var o=n[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),n[e]=null,w(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Vt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Un(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var o=r.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=zt(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ze(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=me(e._renderChildren,o),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,o){return je(n,e,t,r,o,!1)},n.$createElement=function(e,t,r,o){return je(n,e,t,r,o,!0)};var a=t&&t.data;On(n,"$attrs",a&&a.attrs||r,null,!0),On(n,"$listeners",e._parentListeners||r,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=ft(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){On(n,t,e[t])})),Cn(!0))}(e),Rt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var r=Jn(n),o=pn?Reflect.ownKeys(t):Object.keys(t),a=0;a<o.length;a++){var i=o[a];Object.defineProperty(r,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Wt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=$n,n.prototype.$delete=Bn,n.prototype.$watch=function(n,e,t){if(d(e))return Jt(this,n,e,t);(t=t||{}).user=!0;var r=new He(this,n,e,t);if(t.immediate){var o='callback for immediate watcher "'.concat(r.expression,'"');kn(),Ae(e,this,[r.value],this,o),Tn()}return function(){r.teardown()}}}(Wt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(o(n))for(var a=0,i=n.length;a<i;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(o(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?I(t):t;for(var r=I(arguments,1),o='event handler for "'.concat(n,'"'),a=0,i=t.length;a<i;a++)Ae(t[a],e,r,e,o)}return e}}(Wt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,o=t._vnode,a=Ye(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var i=t;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||w(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Wt),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return Le(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,r=e._parentVnode;r&&n._isMounted&&(n.$scopedSlots=ge(n.$parent,r.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&ke(n._slotsProxy,n.$scopedSlots)),n.$vnode=r;var a,i=dn,s=Te;try{mn(n),Te=n,a=t.call(n._renderProxy,n.$createElement)}catch(e){_e(e,n,"render"),a=n._vnode}finally{Te=s,mn(i)}return o(a)&&1===a.length&&(a=a[0]),a instanceof fn||(a=hn()),a.parent=r,a}}(Wt);var Qt=[String,RegExp,Array],nr={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Qt,exclude:Qt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var o=t.tag,a=t.componentInstance,i=t.componentOptions;n[r]={name:Kt(i),tag:o,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&Yt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Yt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Xt(n,(function(n){return Zt(e,n)}))})),this.$watch("exclude",(function(e){Xt(n,(function(n){return!Zt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Se(n),t=e&&e.componentOptions;if(t){var r=Kt(t),o=this.include,a=this.exclude;if(o&&(!r||!Zt(o,r))||a&&r&&Zt(a,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,w(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return U}};Object.defineProperty(n,"config",e),n.util={warn:Tt,extend:P,mergeOptions:zt,defineReactive:On},n.set=$n,n.delete=Bn,n.nextTick=Le,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),N.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,nr),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=I(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=zt(this.options,n),this}}(n),Gt(n),function(n){N.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Wt),Object.defineProperty(Wt.prototype,"$isServer",{get:sn}),Object.defineProperty(Wt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Wt,"FunctionalRenderContext",{value:ht}),Wt.version="2.7.16";var er=v("style,class"),tr=v("input,textarea,option,select,progress"),rr=v("contenteditable,draggable,spellcheck"),or=v("events,caret,typing,plaintext-only"),ar=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ir="http://www.w3.org/1999/xlink",sr=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},lr=function(n){return sr(n)?n.slice(6,n.length):""},cr=function(n){return null==n||!1===n};function ur(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=pr(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=pr(e,t.data));return function(n,e){if(i(n)||i(e))return dr(n,mr(e));return""}(e.staticClass,e.class)}function pr(n,e){return{staticClass:dr(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function dr(n,e){return n?e?n+" "+e:n:e||""}function mr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,o=n.length;r<o;r++)i(e=mr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var fr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hr=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),br=function(n){return hr(n)||gr(n)};var yr=Object.create(null);var vr=v("text,number,password,search,email,tel,url");var xr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(fr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wr={create:function(n,e){kr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(kr(n,!0),kr(e))},destroy:function(n){kr(n,!0)}};function kr(n,e){var t=n.data.ref;if(i(t)){var r=n.context,a=n.componentInstance||n.elm,s=e?null:a,l=e?void 0:a;if(c(t))Ae(t,r,[s],r,"template ref function");else{var u=n.data.refInFor,p="string"==typeof t||"number"==typeof t,d=Ln(t),m=r.$refs;if(p||d)if(u){var f=p?m[t]:t.value;e?o(f)&&w(f,a):o(f)?f.includes(a)||f.push(a):p?(m[t]=[a],Tr(r,t,m[t])):t.value=[a]}else if(p){if(e&&m[t]!==a)return;m[t]=l,Tr(r,t,s)}else if(d){if(e&&t.value!==a)return;t.value=s}else 0}}}function Tr(n,e,t){var r=n._setupState;r&&T(r,e)&&(Ln(r[e])?r[e].value=t:r[e]=t)}var Er=new fn("",{},[]),Sr=["create","activate","update","remove","destroy"];function jr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,o=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===o||vr(r)&&vr(o)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function _r(n,e,t){var r,o,a={};for(r=e;r<=t;++r)i(o=n[r].key)&&(a[o]=r);return a}var Ar={create:Cr,update:Cr,destroy:function(n){Cr(n,Er)}};function Cr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,o,a=n===Er,i=e===Er,s=Ir(n.data.directives,n.context),l=Ir(e.data.directives,e.context),c=[],u=[];for(t in l)r=s[t],o=l[t],r?(o.oldValue=r.value,o.oldArg=r.arg,Or(o,"update",e,n),o.def&&o.def.componentUpdated&&u.push(o)):(Or(o,"bind",e,n),o.def&&o.def.inserted&&c.push(o));if(c.length){var p=function(){for(var t=0;t<c.length;t++)Or(c[t],"inserted",e,n)};a?Gn(e,"insert",p):p()}u.length&&Gn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)Or(u[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||Or(s[t],"unbind",n,n,i)}(n,e)}var zr=Object.create(null);function Ir(n,e){var t,r,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=zr),o[Pr(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||It(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||It(e.$options,"directives",r.name)}return o}function Pr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Or(n,e,t,r,o){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,o)}catch(r){_e(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var $r=[wr,Ar];function Br(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,o,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(r in(i(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.attrs=P({},u)),u)o=u[r],c[r]!==o&&Dr(l,r,o,e.data.pre);for(r in(X||Q)&&u.value!==c.value&&Dr(l,"value",u.value),c)a(u[r])&&(sr(r)?l.removeAttributeNS(ir,lr(r)):rr(r)||l.removeAttribute(r))}}function Dr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Mr(n,e,t):ar(e)?cr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):rr(e)?n.setAttribute(e,function(n,e){return cr(e)||"false"===e?"false":"contenteditable"===n&&or(e)?e:"true"}(e,t)):sr(e)?cr(t)?n.removeAttributeNS(ir,lr(e)):n.setAttributeNS(ir,e,t):Mr(n,e,t)}function Mr(n,e,t){if(cr(t))n.removeAttribute(e);else{if(X&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Fr={create:Br,update:Br};function Rr(n,e){var t=e.elm,r=e.data,o=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(o)||a(o.staticClass)&&a(o.class)))){var s=ur(e),l=t._transitionClasses;i(l)&&(s=dr(s,mr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Lr,Nr={create:Rr,update:Rr};function qr(n,e,t){var r=Lr;return function o(){var a=e.apply(null,arguments);null!==a&&Vr(n,o,t,r)}}var Ur=Pe&&!(tn&&Number(tn[1])<=53);function Jr(n,e,t,r){if(Ur){var o=lt,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Lr.addEventListener(n,e,on?{capture:t,passive:r}:t)}function Vr(n,e,t,r){(r||Lr).removeEventListener(n,e._wrapper||e,t)}function Hr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Lr=e.elm||n.elm,function(n){if(i(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Wn(t,r,Jr,Vr,qr,e.context),Lr=void 0}}var Wr,Gr={create:Hr,update:Hr,destroy:function(n){return Hr(n,Er)}};function Kr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,o=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=P({},c)),l)t in c||(o[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=r;var u=a(r)?"":String(r);Zr(o,u)&&(o.value=u)}else if("innerHTML"===t&&gr(o.tagName)&&a(o.innerHTML)){(Wr=Wr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var p=Wr.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;p.firstChild;)o.appendChild(p.firstChild)}else if(r!==l[t])try{o[t]=r}catch(n){}}}}function Zr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return y(t)!==y(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Xr={create:Kr,update:Kr},Yr=E((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Qr(n){var e=no(n.style);return n.staticStyle?P(n.staticStyle,e):e}function no(n){return Array.isArray(n)?O(n):"string"==typeof n?Yr(n):n}var eo,to=/^--/,ro=/\s*!important$/,oo=function(n,e,t){if(to.test(e))n.style.setProperty(e,t);else if(ro.test(t))n.style.setProperty(C(e),t.replace(ro,""),"important");else{var r=io(e);if(Array.isArray(t))for(var o=0,a=t.length;o<a;o++)n.style[r]=t[o];else n.style[r]=t}},ao=["Webkit","Moz","ms"],io=E((function(n){if(eo=eo||document.createElement("div").style,"filter"!==(n=j(n))&&n in eo)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ao.length;t++){var r=ao[t]+e;if(r in eo)return r}}));function so(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var o,s,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},p=c||u,d=no(e.data.style)||{};e.data.normalizedStyle=i(d.__ob__)?P({},d):d;var m=function(n,e){var t,r={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=Qr(o.data))&&P(r,t);(t=Qr(n.data))&&P(r,t);for(var a=n;a=a.parent;)a.data&&(t=Qr(a.data))&&P(r,t);return r}(e,!0);for(s in p)a(m[s])&&oo(l,s,"");for(s in m)o=m[s],oo(l,s,null==o?"":o)}}var lo={create:so,update:so},co=/\s+/;function uo(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(co).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function po(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(co).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function mo(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,fo(n.name||"v")),P(e,n),e}return"string"==typeof n?fo(n):void 0}}var fo=E((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ho=K&&!Y,go="transition",bo="transitionend",yo="animation",vo="animationend";ho&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(go="WebkitTransition",bo="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(yo="WebkitAnimation",vo="webkitAnimationEnd"));var xo=K?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function wo(n){xo((function(){xo(n)}))}function ko(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),uo(n,e))}function To(n,e){n._transitionClasses&&w(n._transitionClasses,e),po(n,e)}function Eo(n,e,t){var r=jo(n,e),o=r.type,a=r.timeout,i=r.propCount;if(!o)return t();var s="transition"===o?bo:vo,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),a+1),n.addEventListener(s,u)}var So=/\b(transform|all)(,|$)/;function jo(n,e){var t,r=window.getComputedStyle(n),o=(r[go+"Delay"]||"").split(", "),a=(r[go+"Duration"]||"").split(", "),i=_o(o,a),s=(r[yo+"Delay"]||"").split(", "),l=(r[yo+"Duration"]||"").split(", "),c=_o(s,l),u=0,p=0;return"transition"===e?i>0&&(t="transition",u=i,p=a.length):"animation"===e?c>0&&(t="animation",u=c,p=l.length):p=(t=(u=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:u,propCount:p,hasTransform:"transition"===t&&So.test(r[go+"Property"])}}function _o(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ao(e)+Ao(n[t])})))}function Ao(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Co(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=mo(n.data.transition);if(!a(r)&&!i(t._enterCb)&&1===t.nodeType){for(var o=r.css,s=r.type,l=r.enterClass,p=r.enterToClass,d=r.enterActiveClass,m=r.appearClass,f=r.appearToClass,h=r.appearActiveClass,g=r.beforeEnter,b=r.enter,v=r.afterEnter,x=r.enterCancelled,w=r.beforeAppear,k=r.appear,T=r.afterAppear,E=r.appearCancelled,S=r.duration,j=Xe,_=Xe.$vnode;_&&_.parent;)j=_.context,_=_.parent;var A=!j._isMounted||!n.isRootInsert;if(!A||k||""===k){var C=A&&m?m:l,z=A&&h?h:d,I=A&&f?f:p,P=A&&w||g,O=A&&c(k)?k:b,$=A&&T||v,B=A&&E||x,D=y(u(S)?S.enter:S);0;var M=!1!==o&&!Y,F=Po(O),L=t._enterCb=R((function(){M&&(To(t,I),To(t,z)),L.cancelled?(M&&To(t,C),B&&B(t)):$&&$(t),t._enterCb=null}));n.data.show||Gn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),O&&O(t,L)})),P&&P(t),M&&(ko(t,C),ko(t,z),wo((function(){To(t,C),L.cancelled||(ko(t,I),F||(Io(D)?setTimeout(L,D):Eo(t,s,L)))}))),n.data.show&&(e&&e(),O&&O(t,L)),M||F||L()}}}function zo(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=mo(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var o=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,p=r.leaveActiveClass,d=r.beforeLeave,m=r.leave,f=r.afterLeave,h=r.leaveCancelled,g=r.delayLeave,b=r.duration,v=!1!==o&&!Y,x=Po(m),w=y(u(b)?b.leave:b);0;var k=t._leaveCb=R((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),v&&(To(t,c),To(t,p)),k.cancelled?(v&&To(t,l),h&&h(t)):(e(),f&&f(t)),t._leaveCb=null}));g?g(T):T()}function T(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),v&&(ko(t,l),ko(t,p),wo((function(){To(t,l),k.cancelled||(ko(t,c),x||(Io(w)?setTimeout(k,w):Eo(t,s,k)))}))),m&&m(t,k),v||x||k())}}function Io(n){return"number"==typeof n&&!isNaN(n)}function Po(n){if(a(n))return!1;var e=n.fns;return i(e)?Po(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Oo(n,e){!0!==e.data.show&&Co(e)}var $o=function(n){var e,t,r={},c=n.modules,u=n.nodeOps;for(e=0;e<Sr.length;++e)for(r[Sr[e]]=[],t=0;t<c.length;++t)i(c[t][Sr[e]])&&r[Sr[e]].push(c[t][Sr[e]]);function p(n){var e=u.parentNode(n);i(e)&&u.removeChild(e,n)}function d(n,e,t,o,a,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=bn(n)),n.isRootInsert=!a,!function(n,e,t,o){var a=n.data;if(i(a)){var l=i(n.componentInstance)&&a.keepAlive;if(i(a=a.hook)&&i(a=a.init)&&a(n,!1),i(n.componentInstance))return m(n,e),f(t,n.elm,o),s(l)&&function(n,e,t,o){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(a=s.data)&&i(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](Er,s);e.push(s);break}f(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var p=n.data,d=n.children,g=n.tag;i(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),y(n),h(n,d,e),i(p)&&b(n,e),f(t,n.elm,o)):s(n.isComment)?(n.elm=u.createComment(n.text),f(t,n.elm,o)):(n.elm=u.createTextNode(n.text),f(t,n.elm,o))}}function m(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(b(n,e),y(n)):(kr(n),e.push(n))}function f(n,e,t){i(n)&&(i(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function h(n,e,t){if(o(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function b(n,t){for(var o=0;o<r.create.length;++o)r.create[o](Er,n);i(e=n.data.hook)&&(i(e.create)&&e.create(Er,n),i(e.insert)&&t.push(n))}function y(n){var e;if(i(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;i(e=Xe)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function x(n,e,t,r,o,a){for(;r<=o;++r)d(t[r],a,n,e,!1,t,r)}function w(n){var e,t,o=n.data;if(i(o))for(i(e=o.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(T(r),w(r)):p(r.elm))}}function T(n,e){if(i(e)||i(n.data)){var t,o=r.remove.length+1;for(i(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,o),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&T(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else p(n.elm)}function E(n,e,t,r){for(var o=t;o<r;o++){var a=e[o];if(i(a)&&jr(n,a))return o}}function S(n,e,t,o,l,c){if(n!==e){i(e.elm)&&i(o)&&(e=o[l]=bn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,f=e.data;i(f)&&i(m=f.hook)&&i(m=m.prepatch)&&m(n,e);var h=n.children,b=e.children;if(i(f)&&g(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);i(m=f.hook)&&i(m=m.update)&&m(n,e)}a(e.text)?i(h)&&i(b)?h!==b&&function(n,e,t,r,o){var s,l,c,p=0,m=0,f=e.length-1,h=e[0],g=e[f],b=t.length-1,y=t[0],v=t[b],w=!o;for(0;p<=f&&m<=b;)a(h)?h=e[++p]:a(g)?g=e[--f]:jr(h,y)?(S(h,y,r,t,m),h=e[++p],y=t[++m]):jr(g,v)?(S(g,v,r,t,b),g=e[--f],v=t[--b]):jr(h,v)?(S(h,v,r,t,b),w&&u.insertBefore(n,h.elm,u.nextSibling(g.elm)),h=e[++p],v=t[--b]):jr(g,y)?(S(g,y,r,t,m),w&&u.insertBefore(n,g.elm,h.elm),g=e[--f],y=t[++m]):(a(s)&&(s=_r(e,p,f)),a(l=i(y.key)?s[y.key]:E(y,e,p,f))?d(y,r,n,h.elm,!1,t,m):jr(c=e[l],y)?(S(c,y,r,t,m),e[l]=void 0,w&&u.insertBefore(n,c.elm,h.elm)):d(y,r,n,h.elm,!1,t,m),y=t[++m]);p>f?x(n,a(t[b+1])?null:t[b+1].elm,t,m,b,r):m>b&&k(e,p,f)}(p,h,b,t,c):i(b)?(i(n.text)&&u.setTextContent(p,""),x(p,null,b,0,b.length-1,t)):i(h)?k(h,0,h.length-1):i(n.text)&&u.setTextContent(p,""):n.text!==e.text&&u.setTextContent(p,e.text),i(f)&&i(m=f.hook)&&i(m=m.postpatch)&&m(n,e)}}}function j(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var _=v("attrs,class,staticClass,staticStyle,key");function A(n,e,t,r){var o,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(o=l.hook)&&i(o=o.init)&&o(e,!0),i(o=e.componentInstance)))return m(e,t),!0;if(i(a)){if(i(c))if(n.hasChildNodes())if(i(o=l)&&i(o=o.domProps)&&i(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var u=!0,p=n.firstChild,d=0;d<c.length;d++){if(!p||!A(p,c[d],t,r)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else h(e,c,t);if(i(l)){var f=!1;for(var g in l)if(!_(g)){f=!0,b(e,t);break}!f&&l.class&&Ue(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,o){if(!a(e)){var l,c=!1,p=[];if(a(n))c=!0,d(e,p);else{var m=i(n.nodeType);if(!m&&jr(n,e))S(n,e,p,null,null,o);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&A(n,e,p))return j(e,p,!0),n;l=n,n=new fn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var f=n.elm,h=u.parentNode(f);if(d(e,p,f._leaveCb?null:h,u.nextSibling(f)),i(e.parent))for(var b=e.parent,y=g(e);b;){for(var v=0;v<r.destroy.length;++v)r.destroy[v](b);if(b.elm=e.elm,y){for(var x=0;x<r.create.length;++x)r.create[x](Er,b);var T=b.data.hook.insert;if(T.merged)for(var E=T.fns.slice(1),_=0;_<E.length;_++)E[_]()}else kr(b);b=b.parent}i(h)?k([n],0,0):i(n.tag)&&w(n)}}return j(e,p,c),e.elm}i(n)&&w(n)}}({nodeOps:xr,modules:[Fr,Nr,Gr,Xr,lo,K?{create:Oo,activate:Oo,remove:function(n,e){!0!==n.data.show?zo(n,e):e()}}:{}].concat($r)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&qo(n,"input")}));var Bo={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Gn(t,"postpatch",(function(){Bo.componentUpdated(n,e,t)})):Do(n,e,t.context),n._vOptions=[].map.call(n.options,Ro)):("textarea"===t.tag||vr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Lo),n.addEventListener("compositionend",No),n.addEventListener("change",No),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Do(n,e,t.context);var r=n._vOptions,o=n._vOptions=[].map.call(n.options,Ro);if(o.some((function(n,e){return!M(n,r[e])})))(n.multiple?e.value.some((function(n){return Fo(n,o)})):e.value!==e.oldValue&&Fo(e.value,o))&&qo(n,"change")}}};function Do(n,e,t){Mo(n,e,t),(X||Q)&&setTimeout((function(){Mo(n,e,t)}),0)}function Mo(n,e,t){var r=e.value,o=n.multiple;if(!o||Array.isArray(r)){for(var a,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],o)a=F(r,Ro(i))>-1,i.selected!==a&&(i.selected=a);else if(M(Ro(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));o||(n.selectedIndex=-1)}}function Fo(n,e){return e.every((function(e){return!M(e,n)}))}function Ro(n){return"_value"in n?n._value:n.value}function Lo(n){n.target.composing=!0}function No(n){n.target.composing&&(n.target.composing=!1,qo(n.target,"input"))}function qo(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Uo(n){return!n.componentInstance||n.data&&n.data.transition?n:Uo(n.componentInstance._vnode)}var Jo={model:Bo,show:{bind:function(n,e,t){var r=e.value,o=(t=Uo(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&o?(t.data.show=!0,Co(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Uo(t)).data&&t.data.transition?(t.data.show=!0,r?Co(t,(function(){n.style.display=n.__vOriginalDisplay})):zo(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,o){o||(n.style.display=n.__vOriginalDisplay)}}},Vo={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ho(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ho(Se(e.children)):n}function Wo(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var o=t._parentListeners;for(var r in o)e[j(r)]=o[r];return e}function Go(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ko=function(n){return n.tag||he(n)},Zo=function(n){return"show"===n.name},Xo={name:"transition",props:Vo,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ko)).length){0;var r=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var a=Ho(o);if(!a)return o;if(this._leaving)return Go(n,o);var i="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?i+"comment":i+a.tag:l(a.key)?0===String(a.key).indexOf(i)?a.key:i+a.key:a.key;var s=(a.data||(a.data={})).transition=Wo(this),c=this._vnode,u=Ho(c);if(a.data.directives&&a.data.directives.some(Zo)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!he(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=P({},s);if("out-in"===r)return this._leaving=!0,Gn(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Go(n,o);if("in-out"===r){if(he(a))return c;var d,m=function(){d()};Gn(s,"afterEnter",m),Gn(s,"enterCancelled",m),Gn(p,"delayLeave",(function(n){d=n}))}}return o}}},Yo=P({tag:String,moveClass:String},Vo);function Qo(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function na(n){n.data.newPos=n.elm.getBoundingClientRect()}function ea(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,o=e.top-t.top;if(r||o){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(o,"px)"),a.transitionDuration="0s"}}delete Yo.mode;var ta={Transition:Xo,TransitionGroup:{props:Yo,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var o=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],a=this.children=[],i=Wo(this),s=0;s<o.length;s++){if((u=o[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))a.push(u),t[u.key]=u,(u.data||(u.data={})).transition=i;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var u;(u=r[s]).data.transition=i,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Qo),n.forEach(na),n.forEach(ea),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;ko(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(bo,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(bo,n),t._moveCb=null,To(t,e))})}})))},methods:{hasMove:function(n,e){if(!ho)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){po(t,n)})),uo(t,e),t.style.display="none",this.$el.appendChild(t);var r=jo(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ra(n,e){for(var t in e)n[t]=e[t];return n}Wt.config.mustUseProp=function(n,e,t){return"value"===t&&tr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Wt.config.isReservedTag=br,Wt.config.isReservedAttr=er,Wt.config.getTagNamespace=function(n){return gr(n)?"svg":"math"===n?"math":void 0},Wt.config.isUnknownElement=function(n){if(!K)return!0;if(br(n))return!1;if(n=n.toLowerCase(),null!=yr[n])return yr[n];var e=document.createElement(n);return n.indexOf("-")>-1?yr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:yr[n]=/HTMLUnknownElement/.test(e.toString())},P(Wt.options.directives,Jo),P(Wt.options.components,ta),Wt.prototype.__patch__=K?$o:$,Wt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=hn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new He(n,r,$,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var o=n._preWatchers;if(o)for(var a=0;a<o.length;a++)o[a].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&K?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},K&&setTimeout((function(){U.devtools&&ln&&ln.emit("init",Wt)}),0);var oa=/[!'()*]/g,aa=function(n){return"%"+n.charCodeAt(0).toString(16)},ia=/%2C/g,sa=function(n){return encodeURIComponent(n).replace(oa,aa).replace(ia,",")};function la(n){try{return decodeURIComponent(n)}catch(n){0}return n}var ca=function(n){return null==n||"object"==typeof n?n:String(n)};function ua(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=la(t.shift()),o=t.length>0?la(t.join("=")):null;void 0===e[r]?e[r]=o:Array.isArray(e[r])?e[r].push(o):e[r]=[e[r],o]})),e):e}function pa(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return sa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(sa(e)):r.push(sa(e)+"="+sa(n)))})),r.join("&")}return sa(e)+"="+sa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var da=/\/?$/;function ma(n,e,t,r){var o=r&&r.options.stringifyQuery,a=e.query||{};try{a=fa(a)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:ba(e,o),matched:n?ga(n):[]};return t&&(i.redirectedFrom=ba(t,o)),Object.freeze(i)}function fa(n){if(Array.isArray(n))return n.map(fa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=fa(n[t]);return e}return n}var ha=ma(null,{path:"/"});function ga(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function ba(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||pa)(r)+o}function ya(n,e,t){return e===ha?n===e:!!e&&(n.path&&e.path?n.path.replace(da,"")===e.path.replace(da,"")&&(t||n.hash===e.hash&&va(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&va(n.query,e.query)&&va(n.params,e.params))))}function va(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var a=n[t];if(r[o]!==t)return!1;var i=e[t];return null==a||null==i?a===i:"object"==typeof a&&"object"==typeof i?va(a,i):String(a)===String(i)}))}function xa(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var o=t.instances[r],a=t.enteredCbs[r];if(o&&a){delete t.enteredCbs[r];for(var i=0;i<a.length;i++)o._isBeingDestroyed||a[i](o)}}}}var wa={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,o=e.parent,a=e.data;a.routerView=!0;for(var i=o.$createElement,s=t.name,l=o.$route,c=o._routerViewCache||(o._routerViewCache={}),u=0,p=!1;o&&o._routerRoot!==o;){var d=o.$vnode?o.$vnode.data:{};d.routerView&&u++,d.keepAlive&&o._directInactive&&o._inactive&&(p=!0),o=o.$parent}if(a.routerViewDepth=u,p){var m=c[s],f=m&&m.component;return f?(m.configProps&&ka(f,a,m.route,m.configProps),i(f,a,r)):i()}var h=l.matched[u],g=h&&h.components[s];if(!h||!g)return c[s]=null,i();c[s]={component:g},a.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),xa(l)};var b=h.props&&h.props[s];return b&&(ra(c[s],{route:l,configProps:b}),ka(g,a,l,b)),i(g,a,r)}};function ka(n,e,t,r){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=ra({},o);var a=e.attrs=e.attrs||{};for(var i in o)n.props&&i in n.props||(a[i]=o[i],delete o[i])}}function Ta(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?o.pop():"."!==s&&o.push(s)}return""!==o[0]&&o.unshift(""),o.join("/")}function Ea(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Sa=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ja=La,_a=Pa,Aa=function(n,e){return $a(Pa(n,e),e)},Ca=$a,za=Ra,Ia=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Pa(n,e){for(var t,r=[],o=0,a=0,i="",s=e&&e.delimiter||"/";null!=(t=Ia.exec(n));){var l=t[0],c=t[1],u=t.index;if(i+=n.slice(a,u),a=u+l.length,c)i+=c[1];else{var p=n[a],d=t[2],m=t[3],f=t[4],h=t[5],g=t[6],b=t[7];i&&(r.push(i),i="");var y=null!=d&&null!=p&&p!==d,v="+"===g||"*"===g,x="?"===g||"*"===g,w=t[2]||s,k=f||h;r.push({name:m||o++,prefix:d||"",delimiter:w,optional:x,repeat:v,partial:y,asterisk:!!b,pattern:k?Da(k):b?".*":"[^"+Ba(w)+"]+?"})}}return a<n.length&&(i+=n.substr(a)),i&&r.push(i),r}function Oa(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function $a(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Fa(e)));return function(e,r){for(var o="",a=e||{},i=(r||{}).pretty?Oa:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=a[l.name];if(null==u){if(l.optional){l.partial&&(o+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Sa(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(c=i(u[p]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");o+=(0===p?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');o+=l.prefix+c}}else o+=l}return o}}function Ba(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Da(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Ma(n,e){return n.keys=e,n}function Fa(n){return n&&n.sensitive?"":"i"}function Ra(n,e,t){Sa(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,o=!1!==t.end,a="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)a+=Ba(s);else{var l=Ba(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=Ba(t.delimiter||"/"),p=a.slice(-u.length)===u;return r||(a=(p?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=o?"$":r&&p?"":"(?="+u+"|$)",Ma(new RegExp("^"+a,Fa(t)),e)}function La(n,e,t){return Sa(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Ma(n,e)}(n,e):Sa(n)?function(n,e,t){for(var r=[],o=0;o<n.length;o++)r.push(La(n[o],e,t).source);return Ma(new RegExp("(?:"+r.join("|")+")",Fa(t)),e)}(n,e,t):function(n,e,t){return Ra(Pa(n,t),e,t)}(n,e,t)}ja.parse=_a,ja.compile=Aa,ja.tokensToFunction=Ca,ja.tokensToRegExp=za;var Na=Object.create(null);function qa(n,e,t){e=e||{};try{var r=Na[n]||(Na[n]=ja.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ua(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var a=(o=ra({},n)).params;return a&&"object"==typeof a&&(o.params=ra({},a)),o}if(!o.path&&o.params&&e){(o=ra({},o))._normalized=!0;var i=ra(ra({},e.params),o.params);if(e.name)o.name=e.name,o.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;o.path=qa(s,i,e.path)}else 0;return o}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(o.path||""),c=e&&e.path||"/",u=l.path?Ta(l.path,c,t||o.append):c,p=function(n,e,t){void 0===e&&(e={});var r,o=t||ua;try{r=o(n||"")}catch(n){r={}}for(var a in e){var i=e[a];r[a]=Array.isArray(i)?i.map(ca):ca(i)}return r}(l.query,o.query,r&&r.options.parseQuery),d=o.hash||l.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:u,query:p,hash:d}}var Ja,Va=function(){},Ha={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,o=t.resolve(this.to,r,this.append),a=o.location,i=o.route,s=o.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,p=null==c?"router-link-active":c,d=null==u?"router-link-exact-active":u,m=null==this.activeClass?p:this.activeClass,f=null==this.exactActiveClass?d:this.exactActiveClass,h=i.redirectedFrom?ma(null,Ua(i.redirectedFrom),null,t):i;l[f]=ya(r,h,this.exactPath),l[m]=this.exact||this.exactPath?l[f]:function(n,e){return 0===n.path.replace(da,"/").indexOf(e.path.replace(da,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,h);var g=l[f]?this.ariaCurrentValue:null,b=function(n){Wa(n)&&(e.replace?t.replace(a,Va):t.push(a,Va))},y={click:Wa};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=b})):y[this.event]=b;var v={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:b,isActive:l[m],isExactActive:l[f]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)v.on=y,v.attrs={href:s,"aria-current":g};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=ra({},w.data);for(var T in k.on=k.on||{},k.on){var E=k.on[T];T in y&&(k.on[T]=Array.isArray(E)?E:[E])}for(var S in y)S in k.on?k.on[S].push(y[S]):k.on[S]=b;var j=w.data.attrs=ra({},w.data.attrs);j.href=s,j["aria-current"]=g}else v.on=y}return n(this.tag,v,this.$slots.default)}};function Wa(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ga="undefined"!=typeof window;function Ka(n,e,t,r,o){var a=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,o,a,i){var s=o.path,l=o.name;0;var c=o.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Ea(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof o.caseSensitive&&(c.sensitive=o.caseSensitive);var p={path:u,regex:Za(u,c),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:i,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var a=i?Ea(i+"/"+o.path):void 0;n(e,t,r,o,p,a)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==o.alias)for(var d=Array.isArray(o.alias)?o.alias:[o.alias],m=0;m<d.length;++m){0;var f={path:d[m],children:o.children};n(e,t,r,f,a,p.path||"/")}l&&(r[l]||(r[l]=p))}(a,i,s,n,o)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:i,nameMap:s}}function Za(n,e){return ja(n,[],e)}function Xa(n,e){var t=Ka(n),r=t.pathList,o=t.pathMap,a=t.nameMap;function i(n,t,i){var s=Ua(n,t,!1,e),c=s.name;if(c){var u=a[c];if(!u)return l(null,s);var p=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=qa(u.path,s.params),l(u,s,i)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var f=r[m],h=o[f];if(Ya(h.regex,s.path,s.params))return l(h,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,o="function"==typeof r?r(ma(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return l(null,t);var s=o,c=s.name,u=s.path,p=t.query,d=t.hash,m=t.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,m=s.hasOwnProperty("params")?s.params:m,c){a[c];return i({_normalized:!0,name:c,query:p,hash:d,params:m},void 0,t)}if(u){var f=function(n,e){return Ta(n,e.parent?e.parent.path:"/",!0)}(u,n);return i({_normalized:!0,path:qa(f,m),query:p,hash:d},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:qa(t,e.params)});if(r){var o=r.matched,a=o[o.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):ma(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Ka([e||n],r,o,a,t),t&&t.alias.length&&Ka(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,a,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){Ka(n,r,o,a)}}}function Ya(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var o=1,a=r.length;o<a;++o){var i=n.keys[o-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[o]?la(r[o]):r[o])}return!0}var Qa=Ga&&window.performance&&window.performance.now?window.performance:Date;function ni(){return Qa.now().toFixed(3)}var ei=ni();function ti(){return ei}function ri(n){return ei=n}var oi=Object.create(null);function ai(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ra({},window.history.state);return t.key=ti(),window.history.replaceState(t,"",e),window.addEventListener("popstate",li),function(){window.removeEventListener("popstate",li)}}function ii(n,e,t,r){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var a=function(){var n=ti();if(n)return oi[n]}(),i=o.call(n,e,t,r?a:null);i&&("function"==typeof i.then?i.then((function(n){mi(n,a)})).catch((function(n){0})):mi(i,a))}))}}function si(){var n=ti();n&&(oi[n]={x:window.pageXOffset,y:window.pageYOffset})}function li(n){si(),n.state&&n.state.key&&ri(n.state.key)}function ci(n){return pi(n.x)||pi(n.y)}function ui(n){return{x:pi(n.x)?n.x:window.pageXOffset,y:pi(n.y)?n.y:window.pageYOffset}}function pi(n){return"number"==typeof n}var di=/^#\d/;function mi(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var o=di.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,a={x:pi((t=a).x)?t.x:0,y:pi(t.y)?t.y:0})}else ci(n)&&(e=ui(n))}else r&&ci(n)&&(e=ui(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var fi,hi=Ga&&((-1===(fi=window.navigator.userAgent).indexOf("Android 2.")&&-1===fi.indexOf("Android 4.0")||-1===fi.indexOf("Mobile Safari")||-1!==fi.indexOf("Chrome")||-1!==fi.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function gi(n,e){si();var t=window.history;try{if(e){var r=ra({},t.state);r.key=ti(),t.replaceState(r,"",n)}else t.pushState({key:ri(ni())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function bi(n){gi(n,!0)}var yi={redirected:2,aborted:4,cancelled:8,duplicated:16};function vi(n,e){return wi(n,e,yi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ki.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xi(n,e){return wi(n,e,yi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function wi(n,e,t,r){var o=new Error(r);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var ki=["params","query","hash"];function Ti(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Ei(n,e){return Ti(n)&&n._isRouter&&(null==e||n.type===e)}function Si(n,e,t){var r=function(o){o>=n.length?t():n[o]?e(n[o],(function(){r(o+1)})):r(o+1)};r(0)}function ji(n){return function(e,t,r){var o=!1,a=0,i=null;_i(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){o=!0,a++;var l,c=zi((function(e){var o;((o=e).__esModule||Ci&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ja.extend(e),t.components[s]=e,--a<=0&&r()})),u=zi((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=Ti(n)?n:new Error(e),r(i))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var p=l.component;p&&"function"==typeof p.then&&p.then(c,u)}}})),o||r()}}function _i(n,e){return Ai(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ai(n){return Array.prototype.concat.apply([],n)}var Ci="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function zi(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Ii=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ga){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ha,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Pi(n,e,t,r){var o=_i(n,(function(n,r,o,a){var i=function(n,e){"function"!=typeof n&&(n=Ja.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,o,a)})):t(i,r,o,a)}));return Ai(r?o.reverse():o)}function Oi(n,e){if(e)return function(){return n.apply(e,arguments)}}Ii.prototype.listen=function(n){this.cb=n},Ii.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ii.prototype.onError=function(n){this.errorCbs.push(n)},Ii.prototype.transitionTo=function(n,e,t){var r,o=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){o.updateRoute(r),e&&e(r),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(r,a)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!o.ready&&(Ei(n,yi.redirected)&&a===ha||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ii.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var a,i,s=function(n){!Ei(n)&&Ti(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=o.matched.length-1;if(ya(n,o)&&l===c&&n.matched[l]===o.matched[c])return this.ensureURL(),n.hash&&ii(this.router,o,n,!1),s(((i=wi(a=o,n,yi.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",i));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=u.updated,d=u.deactivated,m=u.activated,f=[].concat(function(n){return Pi(n,"beforeRouteLeave",Oi,!0)}(d),this.router.beforeHooks,function(n){return Pi(n,"beforeRouteUpdate",Oi)}(p),m.map((function(n){return n.beforeEnter})),ji(m)),h=function(e,t){if(r.pending!==n)return s(xi(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return wi(n,e,yi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):Ti(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(vi(o,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Si(f,h,(function(){Si(function(n){return Pi(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,o,a){return n(r,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),h,(function(){if(r.pending!==n)return s(xi(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){xa(n)}))}))}))},Ii.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ii.prototype.setupListeners=function(){},Ii.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ha,this.pending=null};var $i=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Bi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=hi&&t;r&&this.listeners.push(ai());var o=function(){var t=n.current,o=Bi(n.base);n.current===ha&&o===n._startLocation||n.transitionTo(o,(function(n){r&&ii(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){gi(Ea(r.base+n.fullPath)),ii(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){bi(Ea(r.base+n.fullPath)),ii(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Bi(this.base)!==this.current.fullPath){var e=Ea(this.base+this.current.fullPath);n?gi(e):bi(e)}},e.prototype.getCurrentLocation=function(){return Bi(this.base)},e}(Ii);function Bi(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(Ea(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Di=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Bi(n);if(!/^\/#/.test(e))return window.location.replace(Ea(n+"/#"+e)),!0}(this.base)||Mi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=hi&&e;t&&this.listeners.push(ai());var r=function(){var e=n.current;Mi()&&n.transitionTo(Fi(),(function(r){t&&ii(n.router,r,e,!0),hi||Ni(r.fullPath)}))},o=hi?"popstate":"hashchange";window.addEventListener(o,r),this.listeners.push((function(){window.removeEventListener(o,r)}))}},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Li(n.fullPath),ii(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Ni(n.fullPath),ii(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Fi()!==e&&(n?Li(e):Ni(e))},e.prototype.getCurrentLocation=function(){return Fi()},e}(Ii);function Mi(){var n=Fi();return"/"===n.charAt(0)||(Ni("/"+n),!1)}function Fi(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ri(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Li(n){hi?gi(Ri(n)):window.location.hash=n}function Ni(n){hi?bi(Ri(n)):window.location.replace(Ri(n))}var qi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){Ei(n,yi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ii),Ui=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Xa(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!hi&&!1!==n.fallback,this.fallback&&(e="hash"),Ga||(e="abstract"),this.mode=e,e){case"history":this.history=new $i(this,n.base);break;case"hash":this.history=new Di(this,n.base,this.fallback);break;case"abstract":this.history=new qi(this,n.base);break;default:0}},Ji={currentRoute:{configurable:!0}};Ui.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ji.currentRoute.get=function(){return this.history&&this.history.current},Ui.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof $i||t instanceof Di){var r=function(n){t.setupListeners(),function(n){var r=t.current,o=e.options.scrollBehavior;hi&&o&&"fullPath"in n&&ii(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ui.prototype.beforeEach=function(n){return Hi(this.beforeHooks,n)},Ui.prototype.beforeResolve=function(n){return Hi(this.resolveHooks,n)},Ui.prototype.afterEach=function(n){return Hi(this.afterHooks,n)},Ui.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ui.prototype.onError=function(n){this.history.onError(n)},Ui.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Ui.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ui.prototype.go=function(n){this.history.go(n)},Ui.prototype.back=function(){this.go(-1)},Ui.prototype.forward=function(){this.go(1)},Ui.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ui.prototype.resolve=function(n,e,t){var r=Ua(n,e=e||this.history.current,t,this),o=this.match(r,e),a=o.redirectedFrom||o.fullPath;return{location:r,route:o,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?Ea(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:o}},Ui.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ui.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ha&&this.history.transitionTo(this.history.getCurrentLocation())},Ui.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ha&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ui.prototype,Ji);var Vi=Ui;function Hi(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ui.install=function n(e){if(!n.installed||Ja!==e){n.installed=!0,Ja=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",wa),e.component("RouterLink",Ha);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},Ui.version="3.6.5",Ui.isNavigationFailure=Ei,Ui.NavigationFailureType=yi,Ui.START_LOCATION=ha,Ga&&window.Vue&&window.Vue.use(Ui);t(97);t(126),t(24);var Wi={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,318)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,317))},Gi={"v-0ee92da4":()=>t.e(5).then(t.bind(null,319)),"v-7f679b5b":()=>t.e(7).then(t.bind(null,320)),"v-3eb66734":()=>t.e(8).then(t.bind(null,321)),"v-45a1f54c":()=>t.e(6).then(t.bind(null,322)),"v-952f32c6":()=>t.e(11).then(t.bind(null,323)),"v-5c39b61f":()=>t.e(10).then(t.bind(null,324)),"v-73f8edea":()=>t.e(9).then(t.bind(null,325)),"v-f309980c":()=>t.e(13).then(t.bind(null,326)),"v-7873b251":()=>t.e(12).then(t.bind(null,327)),"v-766e8bf2":()=>t.e(14).then(t.bind(null,328)),"v-51e54f4e":()=>t.e(15).then(t.bind(null,329)),"v-e8175582":()=>t.e(17).then(t.bind(null,330)),"v-50d25313":()=>t.e(16).then(t.bind(null,331)),"v-be378bd6":()=>t.e(19).then(t.bind(null,332)),"v-5aaf9039":()=>t.e(20).then(t.bind(null,333)),"v-01cb89d6":()=>t.e(18).then(t.bind(null,334)),"v-c53007e2":()=>t.e(23).then(t.bind(null,335)),"v-b22aca30":()=>t.e(22).then(t.bind(null,336)),"v-f25adb98":()=>t.e(21).then(t.bind(null,337)),"v-2d76ceaa":()=>t.e(25).then(t.bind(null,338)),"v-54609122":()=>t.e(26).then(t.bind(null,339)),"v-7a0ca7fb":()=>t.e(24).then(t.bind(null,340)),"v-15eb2aee":()=>t.e(28).then(t.bind(null,341)),"v-7ac371b2":()=>t.e(29).then(t.bind(null,342)),"v-58a1fe2f":()=>t.e(31).then(t.bind(null,343)),"v-8ee5acb4":()=>t.e(27).then(t.bind(null,344)),"v-5a9cb89d":()=>t.e(30).then(t.bind(null,345)),"v-5ab4e514":()=>t.e(32).then(t.bind(null,346)),"v-390955c8":()=>t.e(34).then(t.bind(null,347)),"v-79b8ec0a":()=>t.e(35).then(t.bind(null,348)),"v-229d25c8":()=>t.e(33).then(t.bind(null,349)),"v-9e2db8ca":()=>t.e(38).then(t.bind(null,350)),"v-4306ecce":()=>t.e(37).then(t.bind(null,351)),"v-1435df20":()=>t.e(36).then(t.bind(null,352)),"v-1cdc20aa":()=>t.e(39).then(t.bind(null,353)),"v-4dfee520":()=>t.e(42).then(t.bind(null,354)),"v-4a7dec34":()=>t.e(40).then(t.bind(null,355)),"v-5862c350":()=>t.e(41).then(t.bind(null,356)),"v-e113a874":()=>t.e(43).then(t.bind(null,357)),"v-207166ad":()=>t.e(45).then(t.bind(null,358)),"v-5cdd16c2":()=>t.e(44).then(t.bind(null,359)),"v-363c7954":()=>t.e(47).then(t.bind(null,360)),"v-ba40a92e":()=>t.e(46).then(t.bind(null,361)),"v-6e816d0a":()=>t.e(48).then(t.bind(null,362)),"v-b5138e64":()=>t.e(50).then(t.bind(null,363)),"v-29605e9b":()=>t.e(51).then(t.bind(null,364)),"v-5d1debe1":()=>t.e(49).then(t.bind(null,365)),"v-66d9d8bd":()=>t.e(52).then(t.bind(null,366)),"v-23976180":()=>t.e(53).then(t.bind(null,367)),"v-b7ae6a94":()=>t.e(56).then(t.bind(null,368)),"v-4093cc6a":()=>t.e(54).then(t.bind(null,369)),"v-311fd1d0":()=>t.e(55).then(t.bind(null,370)),"v-22079d2f":()=>t.e(59).then(t.bind(null,371)),"v-447ce33c":()=>t.e(58).then(t.bind(null,372)),"v-6c0afe04":()=>t.e(57).then(t.bind(null,373)),"v-41d731e4":()=>t.e(61).then(t.bind(null,374)),"v-7feb8d24":()=>t.e(60).then(t.bind(null,375)),"v-5dd236c0":()=>t.e(62).then(t.bind(null,376)),"v-4978dfba":()=>t.e(64).then(t.bind(null,377)),"v-43865bc6":()=>t.e(66).then(t.bind(null,378)),"v-7511215a":()=>t.e(65).then(t.bind(null,379)),"v-493496da":()=>t.e(63).then(t.bind(null,380))};function Ki(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Zi=/-(\w)/g,Xi=Ki(n=>n.replace(Zi,(n,e)=>e?e.toUpperCase():"")),Yi=/\B([A-Z])/g,Qi=Ki(n=>n.replace(Yi,"-$1").toLowerCase()),ns=Ki(n=>n.charAt(0).toUpperCase()+n.slice(1));function es(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(ns(Xi(e))):n(ns(e))||n(Qi(e))}const ts=Object.assign({},Wi,Gi),rs=n=>ts[n],os=n=>Gi[n],as=n=>Wi[n],is=n=>Wt.component(n);function ss(n){return es(os,n)}function ls(n){return es(as,n)}function cs(n){return es(rs,n)}function us(n){return es(is,n)}function ps(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!us(n)&&cs(n)){const e=await cs(n)();Wt.component(n,e.default)}}))}function ds(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ms=t(91),fs=t.n(ms),hs=t(92),gs=t.n(hs),bs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${gs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return fs()([{name:"description",content:this.$description}],n,this.siteMeta,ws)},updateCanonicalLink(){ys(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xs(null,this.currentMetaTags),ys()}};function ys(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ws(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ks=t(48),Ts={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ks)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],i=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(a.hash)){const t=a;if(o===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Es=t(23),Ss=t.n(Es),js={mounted(){Ss.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Wt.component(n.name)||Ss.a.start(),t()}),this.$router.afterEach(()=>{Ss.a.done(),this.isSidebarOpen=!1})}};t(239),t(240);class _s{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var As={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new _s).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css","top"===t&&r.firstChild?r.insertBefore(o,r.firstChild):r.appendChild(o),o.styleSheet?o.styleSheet.cssText=n:o.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Cs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},zs={},Is=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ps=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Cs[n]},Os=function n(e,t,r){var o=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))o[n]=t[n];else{var e=n.replace("data","");o.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;o.appendChild(n(t,r,a))})),o},$s=function(n,e,t){var r,o=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==o.length||t?o:o[0]},Bs=function(n,e){var t,r,o=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:o&&o[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Is(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),o=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](o);return a.template=e,a}(s.js,s.html);var l=Ps("vue");return s.jsLib.unshift(l),s},Ds=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},Ms=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Fs(){var n=$s(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=$s(n,"vuepress-plugin-demo-block__code"),t=$s(n,"vuepress-plugin-demo-block__display"),r=$s(n,"vuepress-plugin-demo-block__footer"),o=$s(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),o=new Function("return ".concat(r))(),a={js:o,css:o.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ms(n),htmlTpl:Is("")},i=Ps("react"),s=Ps("reactDOM");return a.jsLib.unshift(i,s),a}(a,i):"vanilla"===s?Ds(a,i):Bs(a,i),u=Os("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(u),u.addEventListener("click",Rs.bind(null,u,l,e,r)),Ps("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=o.concat(a).concat(Ps("cssLib")).concat(Ps("jsLib")).join(",");return Os("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ps("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:o.concat(Ps("jsLib")).join(";"),css_external:a.concat(Ps("cssLib")).join(";"),layout:Ps("codepenLayout"),js_pre_processor:Ps("codepenJsProcessor"),editors:Ps("codepenEditors")});return Os("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:Ps("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(c.css&&function(n){if(!zs[n]){var e=Os("style",{innerHTML:n});document.body.appendChild(e),zs[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),o);else if("vue"===s){var d=(new(Vue.extend(c.script))).$mount();o.appendChild(d.$el)}else"vanilla"===s&&(o.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Fs()}),300)}function Rs(n,e,t,r){var o="1"!==n.dataset.isExpand;t.style.height=o?"".concat(e,"px"):0,o?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=o?"1":"0"}var Ls=[bs,Ts,js,As,{mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Fs()},updated:function(){Fs()}}],Ns={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ds("layout",n),Wt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},qs=t(8),Us=Object(qs.a)(Ns,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(Us,"mixins",Ls);const Js=[{name:"v-0ee92da4",path:"/web/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-0ee92da4").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/01.前端/01.前端.html",redirect:"/web/"},{name:"v-7f679b5b",path:"/pages/d9cf63/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-7f679b5b").then(t)}},{path:"/pages/d9cf63/index.html",redirect:"/pages/d9cf63/"},{path:"/01.前端/02.前端工程化/02.前端工程化理解.html",redirect:"/pages/d9cf63/"},{name:"v-3eb66734",path:"/pages/2da590/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-3eb66734").then(t)}},{path:"/pages/2da590/index.html",redirect:"/pages/2da590/"},{path:"/01.前端/03.JavaScript高级程序设计/01.JavaScript高级程序设计笔记.html",redirect:"/pages/2da590/"},{name:"v-45a1f54c",path:"/pages/5e2247/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-45a1f54c").then(t)}},{path:"/pages/5e2247/index.html",redirect:"/pages/5e2247/"},{path:"/01.前端/02.前端工程化/01.常见包管理工具.html",redirect:"/pages/5e2247/"},{name:"v-952f32c6",path:"/pages/de0153/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-952f32c6").then(t)}},{path:"/pages/de0153/index.html",redirect:"/pages/de0153/"},{path:"/01.前端/03.JavaScript高级程序设计/04.语法基础（一）.html",redirect:"/pages/de0153/"},{name:"v-5c39b61f",path:"/pages/ac246c/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-5c39b61f").then(t)}},{path:"/pages/ac246c/index.html",redirect:"/pages/ac246c/"},{path:"/01.前端/03.JavaScript高级程序设计/03.html中的js.html",redirect:"/pages/ac246c/"},{name:"v-73f8edea",path:"/pages/3946c7/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-73f8edea").then(t)}},{path:"/pages/3946c7/index.html",redirect:"/pages/3946c7/"},{path:"/01.前端/03.JavaScript高级程序设计/02.什么是JavaScript.html",redirect:"/pages/3946c7/"},{name:"v-f309980c",path:"/pages/d218d6/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-f309980c").then(t)}},{path:"/pages/d218d6/index.html",redirect:"/pages/d218d6/"},{path:"/01.前端/03.JavaScript高级程序设计/06.变量、作用域与内存.html",redirect:"/pages/d218d6/"},{name:"v-7873b251",path:"/pages/546def/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-7873b251").then(t)}},{path:"/pages/546def/index.html",redirect:"/pages/546def/"},{path:"/01.前端/03.JavaScript高级程序设计/05.语法基础（二）.html",redirect:"/pages/546def/"},{name:"v-766e8bf2",path:"/pages/58a981/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-766e8bf2").then(t)}},{path:"/pages/58a981/index.html",redirect:"/pages/58a981/"},{path:"/01.前端/03.JavaScript高级程序设计/07.基本引用类型.html",redirect:"/pages/58a981/"},{name:"v-51e54f4e",path:"/pages/f63386/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-51e54f4e").then(t)}},{path:"/pages/f63386/index.html",redirect:"/pages/f63386/"},{path:"/01.前端/03.JavaScript高级程序设计/08.集合引用类型.html",redirect:"/pages/f63386/"},{name:"v-e8175582",path:"/pages/ab17e4/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-e8175582").then(t)}},{path:"/pages/ab17e4/index.html",redirect:"/pages/ab17e4/"},{path:"/01.前端/03.JavaScript高级程序设计/10.对象、类与面向对象编程.html",redirect:"/pages/ab17e4/"},{name:"v-50d25313",path:"/pages/e9a165/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-50d25313").then(t)}},{path:"/pages/e9a165/index.html",redirect:"/pages/e9a165/"},{path:"/01.前端/03.JavaScript高级程序设计/09.迭代器与生成器.html",redirect:"/pages/e9a165/"},{name:"v-be378bd6",path:"/pages/2aaf04/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-be378bd6").then(t)}},{path:"/pages/2aaf04/index.html",redirect:"/pages/2aaf04/"},{path:"/01.前端/03.JavaScript高级程序设计/12.函数.html",redirect:"/pages/2aaf04/"},{name:"v-5aaf9039",path:"/pages/789703/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-5aaf9039").then(t)}},{path:"/pages/789703/index.html",redirect:"/pages/789703/"},{path:"/01.前端/03.JavaScript高级程序设计/13.期约与异步函数.html",redirect:"/pages/789703/"},{name:"v-01cb89d6",path:"/pages/911d11/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-01cb89d6").then(t)}},{path:"/pages/911d11/index.html",redirect:"/pages/911d11/"},{path:"/01.前端/03.JavaScript高级程序设计/11.代理与反射.html",redirect:"/pages/911d11/"},{name:"v-c53007e2",path:"/pages/ce368e/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-c53007e2").then(t)}},{path:"/pages/ce368e/index.html",redirect:"/pages/ce368e/"},{path:"/01.前端/05.vue熟悉/01.深度指南摘录.html",redirect:"/pages/ce368e/"},{name:"v-b22aca30",path:"/pages/29c00e/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-b22aca30").then(t)}},{path:"/pages/29c00e/index.html",redirect:"/pages/29c00e/"},{path:"/01.前端/04.sass/02.sass基础.html",redirect:"/pages/29c00e/"},{name:"v-f25adb98",path:"/pages/d0e9c2/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-f25adb98").then(t)}},{path:"/pages/d0e9c2/index.html",redirect:"/pages/d0e9c2/"},{path:"/01.前端/04.sass/01.写在前面.html",redirect:"/pages/d0e9c2/"},{name:"v-2d76ceaa",path:"/pages/8232ec/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-2d76ceaa").then(t)}},{path:"/pages/8232ec/index.html",redirect:"/pages/8232ec/"},{path:"/01.前端/07.opensumi/01.opensumi介绍与使用.html",redirect:"/pages/8232ec/"},{name:"v-54609122",path:"/pages/5f1228/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-54609122").then(t)}},{path:"/pages/5f1228/index.html",redirect:"/pages/5f1228/"},{path:"/01.前端/08.WebContainer/01.介绍与使用.html",redirect:"/pages/5f1228/"},{name:"v-7a0ca7fb",path:"/pages/78c7e2/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-7a0ca7fb").then(t)}},{path:"/pages/78c7e2/index.html",redirect:"/pages/78c7e2/"},{path:"/01.前端/06.前端存储/01.indexedDB的应用.html",redirect:"/pages/78c7e2/"},{name:"v-15eb2aee",path:"/pages/f51e80/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-15eb2aee").then(t)}},{path:"/pages/f51e80/index.html",redirect:"/pages/f51e80/"},{path:"/01.前端/10.性能优化/01.前端性能优化.html",redirect:"/pages/f51e80/"},{name:"v-7ac371b2",path:"/pages/ce5e4c/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-7ac371b2").then(t)}},{path:"/pages/ce5e4c/index.html",redirect:"/pages/ce5e4c/"},{path:"/01.前端/11.卡颂React/01.前言.html",redirect:"/pages/ce5e4c/"},{name:"v-58a1fe2f",path:"/pages/98715f/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-58a1fe2f").then(t)}},{path:"/pages/98715f/index.html",redirect:"/pages/98715f/"},{path:"/01.前端/11.卡颂React/03.小试牛刀.html",redirect:"/pages/98715f/"},{name:"v-8ee5acb4",path:"/pages/8c2210/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-8ee5acb4").then(t)}},{path:"/pages/8c2210/index.html",redirect:"/pages/8c2210/"},{path:"/01.前端/09.storybook/01.介绍与使用.html",redirect:"/pages/8c2210/"},{name:"v-5a9cb89d",path:"/pages/d36b61/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-5a9cb89d").then(t)}},{path:"/pages/d36b61/index.html",redirect:"/pages/d36b61/"},{path:"/01.前端/11.卡颂React/02.环境搭建.html",redirect:"/pages/d36b61/"},{name:"v-5ab4e514",path:"/pages/59645f/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-5ab4e514").then(t)}},{path:"/pages/59645f/index.html",redirect:"/pages/59645f/"},{path:"/01.前端/12.JS基础/01.面向对象.html",redirect:"/pages/59645f/"},{name:"v-390955c8",path:"/pages/7deb64/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-390955c8").then(t)}},{path:"/pages/7deb64/index.html",redirect:"/pages/7deb64/"},{path:"/02.场景/02.ResizeObserver防抖优化性能.html",redirect:"/pages/7deb64/"},{name:"v-79b8ec0a",path:"/pages/72b6d7/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-79b8ec0a").then(t)}},{path:"/pages/72b6d7/index.html",redirect:"/pages/72b6d7/"},{path:"/02.场景/03.useAbortableRequest.html",redirect:"/pages/72b6d7/"},{name:"v-229d25c8",path:"/ui/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-229d25c8").then(t)}},{path:"/ui/index.html",redirect:"/ui/"},{path:"/02.场景/01.场景.html",redirect:"/ui/"},{name:"v-9e2db8ca",path:"/pages/016f34/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-9e2db8ca").then(t)}},{path:"/pages/016f34/index.html",redirect:"/pages/016f34/"},{path:"/02.场景/06.单点登录场景与理解.html",redirect:"/pages/016f34/"},{name:"v-4306ecce",path:"/pages/d969d2/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-4306ecce").then(t)}},{path:"/pages/d969d2/index.html",redirect:"/pages/d969d2/"},{path:"/02.场景/05.支持promise的并发.html",redirect:"/pages/d969d2/"},{name:"v-1435df20",path:"/pages/8bee02/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-1435df20").then(t)}},{path:"/pages/8bee02/index.html",redirect:"/pages/8bee02/"},{path:"/02.场景/04.RequestAnimationFrame与滚动.html",redirect:"/pages/8bee02/"},{name:"v-1cdc20aa",path:"/pages/b1d0fe/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-1cdc20aa").then(t)}},{path:"/pages/b1d0fe/index.html",redirect:"/pages/b1d0fe/"},{path:"/02.场景/07.前端路由.html",redirect:"/pages/b1d0fe/"},{name:"v-4dfee520",path:"/pages/0a5e76/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-4dfee520").then(t)}},{path:"/pages/0a5e76/index.html",redirect:"/pages/0a5e76/"},{path:"/03.技术/02.TypeScript/02.教程中的难点.html",redirect:"/pages/0a5e76/"},{name:"v-4a7dec34",path:"/technology/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-4a7dec34").then(t)}},{path:"/technology/index.html",redirect:"/technology/"},{path:"/03.技术/01.技术.html",redirect:"/technology/"},{name:"v-5862c350",path:"/pages/064912/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-5862c350").then(t)}},{path:"/pages/064912/index.html",redirect:"/pages/064912/"},{path:"/03.技术/02.TypeScript/01.前言.html",redirect:"/pages/064912/"},{name:"v-e113a874",path:"/pages/e7bde6/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-e113a874").then(t)}},{path:"/pages/e7bde6/index.html",redirect:"/pages/e7bde6/"},{path:"/03.技术/02.TypeScript/03.教程中的难点2.html",redirect:"/pages/e7bde6/"},{name:"v-207166ad",path:"/pages/0a08d6/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-207166ad").then(t)}},{path:"/pages/0a08d6/index.html",redirect:"/pages/0a08d6/"},{path:"/03.技术/03.NodeJS/01.sequelize学习.html",redirect:"/pages/0a08d6/"},{name:"v-5cdd16c2",path:"/pages/d8612d/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-5cdd16c2").then(t)}},{path:"/pages/d8612d/index.html",redirect:"/pages/d8612d/"},{path:"/03.技术/02.TypeScript/04.教程中的难点3.html",redirect:"/pages/d8612d/"},{name:"v-363c7954",path:"/pages/fbac8b/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-363c7954").then(t)}},{path:"/pages/fbac8b/index.html",redirect:"/pages/fbac8b/"},{path:"/03.技术/04.shell/01.写在前面.html",redirect:"/pages/fbac8b/"},{name:"v-ba40a92e",path:"/pages/1d60cd/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-ba40a92e").then(t)}},{path:"/pages/1d60cd/index.html",redirect:"/pages/1d60cd/"},{path:"/03.技术/03.NodeJS/02.使用postman进行服务端开发.html",redirect:"/pages/1d60cd/"},{name:"v-6e816d0a",path:"/pages/453cda/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-6e816d0a").then(t)}},{path:"/pages/453cda/index.html",redirect:"/pages/453cda/"},{path:"/03.技术/04.shell/02.基础了解.html",redirect:"/pages/453cda/"},{name:"v-b5138e64",path:"/pages/9a9b72/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-b5138e64").then(t)}},{path:"/pages/9a9b72/index.html",redirect:"/pages/9a9b72/"},{path:"/03.技术/05.vscode开发/01.前言.html",redirect:"/pages/9a9b72/"},{name:"v-29605e9b",path:"/pages/16af6e/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-29605e9b").then(t)}},{path:"/pages/16af6e/index.html",redirect:"/pages/16af6e/"},{path:"/03.技术/05.vscode开发/02.vscode的command.html",redirect:"/pages/16af6e/"},{name:"v-5d1debe1",path:"/pages/d72ce4/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-5d1debe1").then(t)}},{path:"/pages/d72ce4/index.html",redirect:"/pages/d72ce4/"},{path:"/03.技术/04.shell/03.学习阮一峰bash教程.html",redirect:"/pages/d72ce4/"},{name:"v-66d9d8bd",path:"/pages/8c3c18/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-66d9d8bd").then(t)}},{path:"/pages/8c3c18/index.html",redirect:"/pages/8c3c18/"},{path:"/03.技术/05.vscode开发/03.树视图.html",redirect:"/pages/8c3c18/"},{name:"v-23976180",path:"/pages/e6e3c2/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-23976180").then(t)}},{path:"/pages/e6e3c2/index.html",redirect:"/pages/e6e3c2/"},{path:"/03.技术/05.vscode开发/04.webview.html",redirect:"/pages/e6e3c2/"},{name:"v-b7ae6a94",path:"/more/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-b7ae6a94").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/04.更多/01.更多.html",redirect:"/more/"},{name:"v-4093cc6a",path:"/pages/3ebda0/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-4093cc6a").then(t)}},{path:"/pages/3ebda0/index.html",redirect:"/pages/3ebda0/"},{path:"/03.技术/06.图解HTTP阅读/01.了解Web及网络基础.html",redirect:"/pages/3ebda0/"},{name:"v-311fd1d0",path:"/pages/f3d2f4/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-311fd1d0").then(t)}},{path:"/pages/f3d2f4/index.html",redirect:"/pages/f3d2f4/"},{path:"/03.技术/06.图解HTTP阅读/02.简单的HTTP协议.html",redirect:"/pages/f3d2f4/"},{name:"v-22079d2f",path:"/pages/8d7ea0/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-22079d2f").then(t)}},{path:"/pages/8d7ea0/index.html",redirect:"/pages/8d7ea0/"},{path:"/04.更多/04.好用工具.html",redirect:"/pages/8d7ea0/"},{name:"v-447ce33c",path:"/pages/815283/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-447ce33c").then(t)}},{path:"/pages/815283/index.html",redirect:"/pages/815283/"},{path:"/04.更多/03.专有名词学习.html",redirect:"/pages/815283/"},{name:"v-6c0afe04",path:"/pages/29fb55/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-6c0afe04").then(t)}},{path:"/pages/29fb55/index.html",redirect:"/pages/29fb55/"},{path:"/04.更多/02.个人记录/01.2024年5月.html",redirect:"/pages/29fb55/"},{name:"v-41d731e4",path:"/about/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-41d731e4").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/05.关于/01.关于.html",redirect:"/about/"},{name:"v-7feb8d24",path:"/pages/2d88c4/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-7feb8d24").then(t)}},{path:"/pages/2d88c4/index.html",redirect:"/pages/2d88c4/"},{path:"/04.更多/05.面试/01.备战腾讯20240902.html",redirect:"/pages/2d88c4/"},{name:"v-5dd236c0",path:"/favorite/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-5dd236c0").then(t)}},{path:"/favorite/index.html",redirect:"/favorite/"},{path:"/06.收藏/01.收藏.html",redirect:"/favorite/"},{name:"v-4978dfba",path:"/categories/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-4978dfba").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-43865bc6",path:"/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-43865bc6").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-7511215a",path:"/tags/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-7511215a").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-493496da",path:"/archives/",component:Us,beforeEnter:(n,e,t)=>{ps("Layout","v-493496da").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{path:"*",component:Us}],Vs={title:"",description:"",base:"/leonBlog/",headTags:[["link",{rel:"icon",href:"/leonBlog/img/avatar.jpg"}],["meta",{name:"keywords",content:"前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"前端",frontmatter:{title:"前端",date:"2024-05-19T19:18:31.000Z",permalink:"/web/",categories:["前端"],tags:[null],article:!1,author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF.html",relativePath:"01.前端/01.前端.md",key:"v-0ee92da4",path:"/web/",headersStr:null,content:"> 在这里，我将记录有关个人学习前端技术相关的内容\n\n> 例如，我打算记录学习 JS 时遇到的难点，前端工程化方面的学习内容",normalizedContent:"> 在这里，我将记录有关个人学习前端技术相关的内容\n\n> 例如，我打算记录学习 js 时遇到的难点，前端工程化方面的学习内容",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"前端工程化理解",frontmatter:{title:"前端工程化理解",date:"2024-07-30T19:10:29.000Z",permalink:"/pages/d9cf63/",categories:["前端","前端工程化"],tags:["核心概念"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/02.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/02.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%90%86%E8%A7%A3.html",relativePath:"01.前端/02.前端工程化/02.前端工程化理解.md",key:"v-7f679b5b",path:"/pages/d9cf63/",headers:[{level:2,title:"早期工程化定义",slug:"早期工程化定义",normalizedTitle:"早期工程化定义",charIndex:43},{level:2,title:"工程领域方案/工具",slug:"工程领域方案-工具",normalizedTitle:"工程领域方案/工具",charIndex:72},{level:2,title:"软件工程三要素",slug:"软件工程三要素",normalizedTitle:"软件工程三要素",charIndex:164},{level:2,title:"前端工程化",slug:"前端工程化",normalizedTitle:"前端工程化",charIndex:6}],headersStr:"早期工程化定义 工程领域方案/工具 软件工程三要素 前端工程化",content:"提示\n\n理解前端工程化，在企业级项目里找到最佳实践\n\n\n# 前端工程化的理解\n\n\n# 早期工程化定义\n\n模块化、规范化、组件化、自动化\n\n\n# 工程领域方案/工具\n\n * 性能优化\n * 微前端\n * Serverless\n * 监控告警\n * CI/CD\n * 脚手架\n * 构建\n * LowCode/NoCode\n\n\n# 软件工程三要素\n\n工具、规范、过程\n\n\n# 前端工程化\n\n前端为降低开发成本和提高开发质量而形成的可复用的规范、工具和过程",normalizedContent:"提示\n\n理解前端工程化，在企业级项目里找到最佳实践\n\n\n# 前端工程化的理解\n\n\n# 早期工程化定义\n\n模块化、规范化、组件化、自动化\n\n\n# 工程领域方案/工具\n\n * 性能优化\n * 微前端\n * serverless\n * 监控告警\n * ci/cd\n * 脚手架\n * 构建\n * lowcode/nocode\n\n\n# 软件工程三要素\n\n工具、规范、过程\n\n\n# 前端工程化\n\n前端为降低开发成本和提高开发质量而形成的可复用的规范、工具和过程",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"JavaScript高级程序设计笔记",frontmatter:{title:"JavaScript高级程序设计笔记",date:"2024-07-30T14:45:56.000Z",permalink:"/pages/2da590/",categories:["前端","JavaScript"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"},sticky:4},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/01.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/03.JavaScript高级程序设计/01.JavaScript高级程序设计笔记.md",key:"v-3eb66734",path:"/pages/2da590/",headersStr:null,content:"提示\n\n在阅读时，已经对JS有了比较深入的了解了，借此书籍补足短板。\n\n书籍链接",normalizedContent:"提示\n\n在阅读时，已经对js有了比较深入的了解了，借此书籍补足短板。\n\n书籍链接",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"常见包管理工具",frontmatter:{title:"常见包管理工具",date:"2024-07-30T14:26:20.000Z",permalink:"/pages/5e2247/",categories:["前端","前端工程化"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/02.%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/01.%E5%B8%B8%E8%A7%81%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.html",relativePath:"01.前端/02.前端工程化/01.常见包管理工具.md",key:"v-45a1f54c",path:"/pages/5e2247/",headersStr:null,content:"# npm\n\n * 全称: Node Package Manager\n * 特点:\n   * 最早的包管理工具，Node.js 默认的包管理器。\n   * 提供了丰富的命令行工具来管理依赖、发布包等。\n   * 社区庞大，生态系统丰富。\n\n\n# yarn\n\n * 全称: Yet Another Resource Negotiator\n * 特点:\n   * 由 Facebook 开发，旨在解决 npm 的一些性能和安全问题。\n   * 更快的依赖安装速度，使用并行下载。\n   * 更好的依赖管理，使用 yarn.lock 文件确保一致的依赖版本。\n\n\n# pnpm\n\n * 全称: Performant NPM\n * 特点:\n * 通过硬链接和符号链接来节省磁盘空间和加快安装速度。\n * 支持 monorepo 项目结构，适合大型项目。\n * 更高效的依赖管理，减少重复安装。\n\n\n# 三者之间的关系\n\n * 共同点：都是用于管理 JavaScript 项目的依赖包。\n * 差异点：在性能、磁盘空间使用、依赖管理方式等方面有所不同。",normalizedContent:"# npm\n\n * 全称: node package manager\n * 特点:\n   * 最早的包管理工具，node.js 默认的包管理器。\n   * 提供了丰富的命令行工具来管理依赖、发布包等。\n   * 社区庞大，生态系统丰富。\n\n\n# yarn\n\n * 全称: yet another resource negotiator\n * 特点:\n   * 由 facebook 开发，旨在解决 npm 的一些性能和安全问题。\n   * 更快的依赖安装速度，使用并行下载。\n   * 更好的依赖管理，使用 yarn.lock 文件确保一致的依赖版本。\n\n\n# pnpm\n\n * 全称: performant npm\n * 特点:\n * 通过硬链接和符号链接来节省磁盘空间和加快安装速度。\n * 支持 monorepo 项目结构，适合大型项目。\n * 更高效的依赖管理，减少重复安装。\n\n\n# 三者之间的关系\n\n * 共同点：都是用于管理 javascript 项目的依赖包。\n * 差异点：在性能、磁盘空间使用、依赖管理方式等方面有所不同。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"语法基础（一）",frontmatter:{title:"语法基础（一）",date:"2024-08-02T10:40:56.000Z",permalink:"/pages/de0153/",categories:["前端","JavaScript"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/04.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89.html",relativePath:"01.前端/03.JavaScript高级程序设计/04.语法基础（一）.md",key:"v-952f32c6",path:"/pages/de0153/",headers:[{level:2,title:"严格模式",slug:"严格模式",normalizedTitle:"严格模式",charIndex:22},{level:2,title:"let 与条件声明",slug:"let-与条件声明",normalizedTitle:"let 与条件声明",charIndex:146},{level:2,title:"typeof 中的注意事项",slug:"typeof-中的注意事项",normalizedTitle:"typeof 中的注意事项",charIndex:371},{level:2,title:"控制流最佳实践",slug:"控制流最佳实践",normalizedTitle:"控制流最佳实践",charIndex:480},{level:2,title:"NaN 的含义",slug:"nan-的含义",normalizedTitle:"nan 的含义",charIndex:517},{level:2,title:"使用标签函数改变模版字符串的默认行文",slug:"使用标签函数改变模版字符串的默认行文",normalizedTitle:"使用标签函数改变模版字符串的默认行文",charIndex:663},{level:2,title:"Symbol 类型",slug:"symbol-类型",normalizedTitle:"symbol 类型",charIndex:1456},{level:3,title:"使用全局符号注册表",slug:"使用全局符号注册表",normalizedTitle:"使用全局符号注册表",charIndex:1586},{level:3,title:"使用 Symbol 作为属性",slug:"使用-symbol-作为属性",normalizedTitle:"使用 symbol 作为属性",charIndex:2190},{level:3,title:"Symbol 作为内置符号",slug:"symbol-作为内置符号",normalizedTitle:"symbol 作为内置符号",charIndex:4044},{level:3,title:"Symbol.asyncIterator",slug:"symbol-asynciterator",normalizedTitle:"symbol.asynciterator",charIndex:4466},{level:3,title:"Symbol.hasInstance",slug:"symbol-hasinstance",normalizedTitle:"symbol.hasinstance",charIndex:5559},{level:3,title:"Symbol.isConcatSpreadable",slug:"symbol-isconcatspreadable",normalizedTitle:"symbol.isconcatspreadable",charIndex:5919},{level:3,title:"Symbol.iterator",slug:"symbol-iterator",normalizedTitle:"symbol.iterator",charIndex:4226},{level:3,title:"Symbol.match",slug:"symbol-match",normalizedTitle:"symbol.match",charIndex:6985},{level:3,title:"Symbol.replace",slug:"symbol-replace",normalizedTitle:"symbol.replace",charIndex:8101},{level:3,title:"Symbol.search",slug:"symbol-search",normalizedTitle:"symbol.search",charIndex:9205},{level:3,title:"Symbol.species",slug:"symbol-species",normalizedTitle:"symbol.species",charIndex:10398},{level:3,title:"Symbol.split",slug:"symbol-split",normalizedTitle:"symbol.split",charIndex:11189},{level:3,title:"Symbol.toPrimitive",slug:"symbol-toprimitive",normalizedTitle:"symbol.toprimitive",charIndex:12190},{level:3,title:"Symbol.toStringTag",slug:"symbol-tostringtag",normalizedTitle:"symbol.tostringtag",charIndex:13133},{level:3,title:"Symbol.unscopables",slug:"symbol-unscopables",normalizedTitle:"symbol.unscopables",charIndex:14037},{level:2,title:"Object 类型",slug:"object-类型",normalizedTitle:"object 类型",charIndex:14380}],headersStr:"严格模式 let 与条件声明 typeof 中的注意事项 控制流最佳实践 NaN 的含义 使用标签函数改变模版字符串的默认行文 Symbol 类型 使用全局符号注册表 使用 Symbol 作为属性 Symbol 作为内置符号 Symbol.asyncIterator Symbol.hasInstance Symbol.isConcatSpreadable Symbol.iterator Symbol.match Symbol.replace Symbol.search Symbol.species Symbol.split Symbol.toPrimitive Symbol.toStringTag Symbol.unscopables Object 类型",content:"# JavaScript 语法基础\n\n\n# 严格模式\n\nECMAScript 5 增加了严格模式（strict mode）的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。\n\n\n# let 与条件声明\n\n使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。\n\n当使用 if 或者 try catch 语法进行条件声明时，使用 let 声明的变量将会被局限在块内。\n\n为此，对于let 这个新的ES6 声明关键字，不能依赖条件声明模式。\n\n\n# typeof 中的注意事项\n\n 1. typeof null 结果将会是 'object'\n 2. 严格来说，function 不是对象，但是可以使用 typeof 操作符区分 function 与 其他对象\n\n\n# 控制流最佳实践\n\n控制流数据中条件判断建议使用 if (标志符)\n\n\n# NaN 的含义\n\n一个特殊的数值叫NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript 中，0、+0 或0 相除会返回NaN：\n\n\n# 使用标签函数改变模版字符串的默认行文\n\n模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。 标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。\n\nlet a = 6; \nlet b = 9;  \n \nfunction simpleTag(strings, aValExpression, bValExpression, sumExpression) { \n  console.log(strings); \n  console.log(aValExpression); \n  console.log(bValExpression); \n  console.log(sumExpression); \n \n  return 'foobar'; \n} \n \nlet untaggedResult = `${ a } + ${ b } = ${ a + b }`; \nlet taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`; \n// [\"\", \" + \", \" = \", \"\"] \n// 6 \n// 9 \n// 15 \n \nconsole.log(untaggedResult);   // \"6 + 9 = 15\" \nconsole.log(taggedResult);     // \"foobar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n使用 String.raw 方法可以避免模版字符串的转义\n\n\n# Symbol 类型\n\n用法\n\n * 作为唯一标志符\n * 使用 Symbol() 生成唯一符号\n * 不能使用 new 关键字（为了避免创建包装对象）\n * 创建 Symbol 的包装对象可以通过 Object 函数，Object(Symbol())\n\n\n# 使用全局符号注册表\n\n使用 Symbol.for() 共享和重用同一个符号\n\nlet fooGlobalSymbol = Symbol.for('foo')\nconsole.log(typeof fooGlobalSymbol) // symbol\nlet otherGlobalSymbol = Symbol.for('foo')\nconsole.log(fooGlobalSymbol === otherGlobalSymbol) // true\n\n\n1\n2\n3\n4\n\n\n即使采用相同的符号描述，在全局注册表中定义的符号跟使用Symbol()定义的符号也并不等同：\n\nlet localSymbol = Symbol('foo'); \nlet globalSymbol = Symbol.for('foo'); \n \nconsole.log(localSymbol === globalSymbol); // false\n\n\n1\n2\n3\n4\n\n\n注册表中使用的键同时也会被用作符号描述。\n\nlet emptyGlobalSymbol = Symbol.for(); \nconsole.log(emptyGlobalSymbol);    // Symbol(undefined)  \n\n\n1\n2\n\n\n传给 Symbol.keyFor() 的值不是 Symbol 时，将会抛出 TypeError\n\n\n# 使用 Symbol 作为属性\n\n * 可以使用显示赋值，也可以使用 Object.defineProperty / Object.defineProperties 来使用Symbol作为属性\n\nlet s1 = Symbol('foo'), \n    s2 = Symbol('bar'), \n    s3 = Symbol('baz'), \n    s4 = Symbol('qux'); \n \nlet o = { \n  [s1]: 'foo val' \n}; \n// 这样也可以：o[s1] = 'foo val'; \n \nconsole.log(o); \n// {Symbol(foo): foo val} \n \nObject.defineProperty(o, s2, {value: 'bar val'}); \n \nconsole.log(o); \n// {Symbol(foo): foo val, Symbol(bar): bar val} \n \nObject.defineProperties(o, { \n  [s3]: {value: 'baz val'}, \n  [s4]: {value: 'qux val'} \n}); \n \nconsole.log(o); \n// {Symbol(foo): foo val, Symbol(bar): bar val, \n//  Symbol(baz): baz val, Symbol(qux): qux val}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 将会返回常规属性，类似于Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键。\n\nlet s1 = Symbol('foo'), \n    s2 = Symbol('bar');  \n \nlet o = { \n  [s1]: 'foo val', \n  [s2]: 'bar val', \n  baz: 'baz val', \n  qux: 'qux val' \n}; \n \nconsole.log(Object.getOwnPropertySymbols(o)); \n// [Symbol(foo), Symbol(bar)] \n \nconsole.log(Object.getOwnPropertyNames(o)); \n// [\"baz\", \"qux\"] \n \nconsole.log(Object.getOwnPropertyDescriptors(o)); \n// {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}} \n \nconsole.log(Reflect.ownKeys(o)); \n// [\"baz\", \"qux\", Symbol(foo), Symbol(bar)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 如何没有显示保存 symbol 的属性名，只能通过过滤对应的属性值来寻找符号属性名了。\n\nlet o = {  \n  [Symbol('foo')]: 'foo val', \n  [Symbol('bar')]: 'bar val' \n}; \n \nconsole.log(o); \n// {Symbol(foo): \"foo val\", Symbol(bar): \"bar val\"} \n \nlet barSymbol = Object.getOwnPropertySymbols(o) \n              .find((symbol) => symbol.toString().match(/bar/)); \n \nconsole.log(barSymbol); \n// Symbol(bar) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Symbol 作为内置符号\n\nECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以Symbol 工厂函数字符串属性的形式存在。 这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，来改变for-of 在迭代该对象时的行为。 这些内置符号也没有什么特别之处，它们就是全局函数Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。\n\n提示\n\n注意 在提到ECMAScript 规范时，经常会引用符号在规范中的名称，前缀为@@。比如，@@iterator 指的就是Symbol.iterator。\n\n\n# Symbol.asyncIterator\n\n根据ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的AsyncIterator。由for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器API 的函数。 for-await-of 循环会利用这个函数执行异步迭代操作。循环时，它们会调用以Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器API 的对象。很多时候，返回的对象是实现该API的AsyncGenerator：\n\nclass Foo {  \n  async *[Symbol.asyncIterator]() {} \n} \n \nlet f = new Foo(); \n \nconsole.log(f[Symbol.asyncIterator]()); \n// AsyncGenerator {<suspended>}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n技术上，这个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回Promise 实例。可以通过显式地调用next()方法返回，也可以隐式地通过异步生成器函数返回：\n\nclass Emitter {  \n  constructor(max) { \n    this.max = max; \n    this.asyncIdx = 0; \n  } \n \n  async *[Symbol.asyncIterator]() { \n    while(this.asyncIdx < this.max) { \n      yield new Promise((resolve) => resolve(this.asyncIdx++)); \n    } \n  } \n} \n \nasync function asyncCount() { \n  let emitter = new Emitter(5);\n  for await(const x of emitter) { \n    console.log(x); \n  } \n} \n \nasyncCount(); \n// 0 \n// 1 \n// 2 \n// 3 \n// 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n提示\n\n注意 Symbol.asyncIterator 是 ES2018 规范定义的，因此只有版本非常新的浏览器 支持它。\n\n\n# Symbol.hasInstance\n\n作为对象的一个属性，使用对象的 obj[Symbol.hasInstance] 方法和 使用 instanceof 关键字是一个效果\n\n同时，可以通过重新定义静态方法重写 Symbol.hasInstance 来改变 instanceof 的行为\n\nclass MyClass {  \n  static [Symbol.hasInstance](instance) { \n    return instance instanceof Object; \n  } \n} \n\nlet obj = { foo: 'bar' }; \nconsole.log(MyClass[Symbol.hasInstance](obj)); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Symbol.isConcatSpreadable\n\n这个符号作为一个属性表示“一个布尔值，如果是true，则意味着对象应该用Array.prototype.concat()打平其数组元素”。 这个符号的主要目标就是允许用户定义的对象可以与Array.prototype.concat()很好地兼容。默认情况下，一个对象传递给concat()时，它会被简单地添加到数组中，作为一个元素：\n\nlet collection = {  \n  0: 'foo', \n  1: 'bar', \n  length: 2, \n  [Symbol.isConcatSpreadable]: true \n}; \n\nlet items = ['baz']; \nitems = items.concat(collection); \nconsole.log(items); \n// ['baz', 'foo', 'bar']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Symbol.iterator\n\n这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由for-of 语句使用”。这个符号表示实现迭代器API 的函数。 for-of 循环会在相关对象上使用这个函数，并期望这个函数会返回一个实现迭代器API 的对象。很多内置类型都实现了这个函数，比如 Array、Map 和 Set。自定义对象默认不实现这个函数，因此除非显式定义，否则它们不能被for-of 循环直接迭代。\n\nclass Emitter {  \n  constructor(max) { \n    this.max = max; \n    this.idx = 0; \n  } \n \n  *[Symbol.iterator]() { \n    while(this.idx < this.max) { \n      yield this.idx++; \n    } \n  } \n} \n \nfunction count() { \n  let emitter = new Emitter(5); \n \n  for (const x of emitter) { \n    console.log(x); \n  } \n} \n \ncount(); \n// 0\n// 1 \n// 2 \n// 3 \n// 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Symbol.match\n\n根据ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由String.prototype.match()方法使用”。String.prototype.matc()方法会使用以 Symbol.match 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个String 方法的有效参数：\n\nconsole.log(RegExp.prototype[Symbol.match]); \n// ƒ [Symbol.match]() { [native code] } \n \nconsole.log('foobar'.match(/bar/)); \n// [\"bar\", index: 3, input: \"foobar\", groups: unde\n\n\n1\n2\n3\n4\n5\n\n\n给这个方法传入非正则表达式值会导致该值被转换为RegExp 对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义 Symbol.match 函数以取代默认对正则表达式求值的行为，从而让match()方法使用非正则表达式实例。Symbol.match 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制：\n\nclass FooMatcher {  \n  static [Symbol.match](target) { \n    return target.includes('foo'); \n  } \n} \n \nconsole.log('foobar'.match(FooMatcher)); // true \nconsole.log('barbaz'.match(FooMatcher)); // false \n \nclass StringMatcher { \n  constructor(str) { \n    this.str = str; \n  } \n \n  [Symbol.match](target) { \n    return target.includes(this.str); \n  } \n} \n \nconsole.log('foobar'.match(new StringMatcher('foo'))); // true \nconsole.log('barbaz'.match(new StringMatcher('qux'))); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Symbol.replace\n\n根据ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用”。String.prototype.replace()方法会使用以 Symbol.replace 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个String 方法的有效参数：\n\nconsole.log(RegExp.prototype[Symbol.replace]); \n// ƒ [Symbol.replace]() { [native code] } \n \nconsole.log('foobarbaz'.replace(/bar/, 'qux')); \n// 'fooquxbaz\n\n\n1\n2\n3\n4\n5\n\n\n给这个方法传入非正则表达式值会导致该值被转换为RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.replace 函数以取代默认对正则表达式求值的行为，从而让replace()方法使用非正则表达式实例。Symbol.replace 函数接收两个参数，即调用replace()方法的字符串实例和替换字符串。返回的值没有限制：\n\nclass FooReplacer { \n  static [Symbol.replace](target, replacement) { \n    return target.split('foo').join(replacement); \n  } \n}  \n \nconsole.log('barfoobaz'.replace(FooReplacer, 'qux')); \n// \"barquxbaz\" \n \nclass StringReplacer { \n  constructor(str) { \n    this.str = str; \n  } \n \n  [Symbol.replace](target, replacement) { \n    return target.split(this.str).join(replacement); \n  } \n} \n \nconsole.log('barfoobaz'.replace(new StringReplacer('foo'), 'qux')); \n// \"barquxbaz\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Symbol.search\n\n根据ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回一个字符串中匹配正则表达式的索引。由String.prototype.search()方法使用”。String.prototype.search()方法会使用以 Symbol.search 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个String 方法的有效参数：\n\nconsole.log(RegExp.prototype[Symbol.search]); \n// ƒ [Symbol.search]() { [native code] } \n \nconsole.log('foobar'.search(/bar/)); \n// 3\n\n\n1\n2\n3\n4\n5\n\n\n给这个方法传入非正则表达式值会导致该值被转换为RegExp 对象。如果想改变这种行为，让方法 直接使用参数，可以重新定义 Symbol.search 函数以取代默认对正则表达式求值的行为，从而让 search()方法使用非正则表达式实例。Symbol.search 函数接收一个参数，就是调用 match()方法 的字符串实例。返回的值没有限制：\n\nclass FooSearcher {  \n  static [Symbol.search](target) { \n    return target.indexOf('foo'); \n  } \n}\nconsole.log('foobar'.search(FooSearcher)); // 0 \nconsole.log('barfoo'.search(FooSearcher)); // 3 \nconsole.log('barbaz'.search(FooSearcher)); // -1 \n \nclass StringSearcher { \n  constructor(str) { \n    this.str = str; \n  } \n \n  [Symbol.search](target) { \n    return target.indexOf(this.str); \n  } \n} \n \nconsole.log('foobar'.search(new StringSearcher('foo'))); // 0 \nconsole.log('barfoo'.search(new StringSearcher('foo'))); // 3 \nconsole.log('barbaz'.search(new StringSearcher('qux')));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Symbol.species\n\n根据ECMAScript 规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：\n\nclass Bar extends Array {}  \nclass Baz extends Array { \n  static get [Symbol.species]() { \n    return Array; \n  } \n} \n \nlet bar = new Bar(); \nconsole.log(bar instanceof Array); // true \nconsole.log(bar instanceof Bar);   // true \nbar = bar.concat('bar'); \nconsole.log(bar instanceof Array); // true \nconsole.log(bar instanceof Bar);   // true \n \nlet baz = new Baz(); \nconsole.log(baz instanceof Array); // true \nconsole.log(baz instanceof Baz);   // true \nbaz = baz.concat('baz'); \nconsole.log(baz instanceof Array); // true \nconsole.log(baz instanceof Baz);   // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Symbol.split\n\n根据ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用”。String.prototype. split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个String 方法的有效参数：\n\nconsole.log(RegExp.prototype[Symbol.split]); \n// ƒ [Symbol.split]() { [native code] } \n \nconsole.log('foobarbaz'.split(/bar/)); \n// ['foo', 'baz\n\n\n1\n2\n3\n4\n5\n\n\n给这个方法传入非正则表达式值会导致该值被转换为RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义Symbol.split 函数以取代默认对正则表达式求值的行为，从而让split()方法使用非正则表达式实例。Symbol.split 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制：\n\nclass FooSplitter {  \n  static [Symbol.split](target) { \n    return target.split('foo'); \n  } \n} \n \nconsole.log('barfoobaz'.split(FooSplitter)); \n// [\"bar\", \"baz\"] \n \nclass StringSplitter { \n  constructor(str) { \n    this.str = str; \n  } \n \n  [Symbol.split](target) { \n    return target.split(this.str); \n  } \n} \n \nconsole.log('barfoobaz'.split(new StringSplitter('foo'))); \n// [\"bar\", \"baz\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# Symbol.toPrimitive\n\n根据ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由ToPrimitive 抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的Symbol.toPrimitive 属性上定义一个函数可以改变默认行为。\n\n根据提供给这个函数的参数（string、number 或default），可以控制返回的原始值：\n\nclass Foo {}  \nlet foo = new Foo(); \n \nconsole.log(3 + foo);       // \"3[object Object]\" \nconsole.log(3 - foo);       // NaN \nconsole.log(String(foo));   // \"[object Object]\" \n \nclass Bar { \n  constructor() { \n    this[Symbol.toPrimitive] = function(hint) { \n      switch (hint) { \n        case 'number': \n          return 3; \n        case 'string': \n          return 'string bar'; \n        case 'default': \n        default: \n          return 'default bar'; \n      } \n    } \n  } \n}\nlet bar = new Bar()\nconsole.log(3 + bar);       // \"3default bar\" \nconsole.log(3 - bar);       // 0 \nconsole.log(String(bar));   // \"string bar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# Symbol.toStringTag\n\n根据ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法Object.prototype.toString()使用”。 通过toString()方法获取对象标识时，会检索由Symbol.toStringTag指定的实例标识符，默认为 \"Object\"。内置类型已经指定了这个值，但自定义实例还需要明确定义。\n\nlet s = new Set(); \n \nconsole.log(s);                      // Set(0) {} \nconsole.log(s.toString());           // [object Set] \nconsole.log(s[Symbol.toStringTag]);  // Set \n \nclass Foo {}  \nlet foo = new Foo(); \n \nconsole.log(foo);                      // Foo {} \nconsole.log(foo.toString());           // [object Object] \nconsole.log(foo[Symbol.toStringTag]);  // undefined \n \nclass Bar { \n  constructor() { \n    this[Symbol.toStringTag] = 'Bar'; \n  } \n} \nlet bar = new Bar(); \n \nconsole.log(bar);                      // Bar {} \nconsole.log(bar.toString());           // [Object Bar]\nconsole.log(bar[Symbol.toStringTag]);  // Bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Symbol.unscopables\n\n根据ECMAScript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的with 环境绑定中排除”。设置止该属性出现在with 环境绑定中，如下例所示：\n\n \nwith (o) {  \n  console.log(foo); // bar \n} \n \no[Symbol.unscopables] = { \n  foo: true \n}; \n \nwith (o) { \n  console.log(foo); // ReferenceError \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意\n\n不推荐使用with，因此也不推荐使用Symbol.unscopables。\n\n\n# Object 类型\n\nObject 类型的所有属性和方法在派生的对象上同样存在。\n\n每个Object 实例都有如下属性和方法。\n\n * constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object() 函数。\n * hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如o.hasOwnProperty(\"name\")）或符号。\n * isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。（第 8 章将详细介绍原型。）\n * propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用（本章稍后讨论的）for-in 语句枚举。与hasOwnProperty()一样，属性名必须是字符串。\n * toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行境。\n * toString()：返回对象的字符串表示。\n * valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与toString()的返回值相同。\n\n提示\n\n注意 严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受ECMA-262 约束，所以它们可能会也可能不会继承Object。",normalizedContent:"# javascript 语法基础\n\n\n# 严格模式\n\necmascript 5 增加了严格模式（strict mode）的概念。严格模式是一种不同的 javascript 解析和执行模型，ecmascript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。\n\n\n# let 与条件声明\n\n使用 var 声明变量时，由于声明会被提升，javascript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。\n\n当使用 if 或者 try catch 语法进行条件声明时，使用 let 声明的变量将会被局限在块内。\n\n为此，对于let 这个新的es6 声明关键字，不能依赖条件声明模式。\n\n\n# typeof 中的注意事项\n\n 1. typeof null 结果将会是 'object'\n 2. 严格来说，function 不是对象，但是可以使用 typeof 操作符区分 function 与 其他对象\n\n\n# 控制流最佳实践\n\n控制流数据中条件判断建议使用 if (标志符)\n\n\n# nan 的含义\n\n一个特殊的数值叫nan，意思是“不是数值”（not a number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ecmascript 中，0、+0 或0 相除会返回nan：\n\n\n# 使用标签函数改变模版字符串的默认行文\n\n模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。 标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。\n\nlet a = 6; \nlet b = 9;  \n \nfunction simpletag(strings, avalexpression, bvalexpression, sumexpression) { \n  console.log(strings); \n  console.log(avalexpression); \n  console.log(bvalexpression); \n  console.log(sumexpression); \n \n  return 'foobar'; \n} \n \nlet untaggedresult = `${ a } + ${ b } = ${ a + b }`; \nlet taggedresult = simpletag`${ a } + ${ b } = ${ a + b }`; \n// [\"\", \" + \", \" = \", \"\"] \n// 6 \n// 9 \n// 15 \n \nconsole.log(untaggedresult);   // \"6 + 9 = 15\" \nconsole.log(taggedresult);     // \"foobar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n使用 string.raw 方法可以避免模版字符串的转义\n\n\n# symbol 类型\n\n用法\n\n * 作为唯一标志符\n * 使用 symbol() 生成唯一符号\n * 不能使用 new 关键字（为了避免创建包装对象）\n * 创建 symbol 的包装对象可以通过 object 函数，object(symbol())\n\n\n# 使用全局符号注册表\n\n使用 symbol.for() 共享和重用同一个符号\n\nlet fooglobalsymbol = symbol.for('foo')\nconsole.log(typeof fooglobalsymbol) // symbol\nlet otherglobalsymbol = symbol.for('foo')\nconsole.log(fooglobalsymbol === otherglobalsymbol) // true\n\n\n1\n2\n3\n4\n\n\n即使采用相同的符号描述，在全局注册表中定义的符号跟使用symbol()定义的符号也并不等同：\n\nlet localsymbol = symbol('foo'); \nlet globalsymbol = symbol.for('foo'); \n \nconsole.log(localsymbol === globalsymbol); // false\n\n\n1\n2\n3\n4\n\n\n注册表中使用的键同时也会被用作符号描述。\n\nlet emptyglobalsymbol = symbol.for(); \nconsole.log(emptyglobalsymbol);    // symbol(undefined)  \n\n\n1\n2\n\n\n传给 symbol.keyfor() 的值不是 symbol 时，将会抛出 typeerror\n\n\n# 使用 symbol 作为属性\n\n * 可以使用显示赋值，也可以使用 object.defineproperty / object.defineproperties 来使用symbol作为属性\n\nlet s1 = symbol('foo'), \n    s2 = symbol('bar'), \n    s3 = symbol('baz'), \n    s4 = symbol('qux'); \n \nlet o = { \n  [s1]: 'foo val' \n}; \n// 这样也可以：o[s1] = 'foo val'; \n \nconsole.log(o); \n// {symbol(foo): foo val} \n \nobject.defineproperty(o, s2, {value: 'bar val'}); \n \nconsole.log(o); \n// {symbol(foo): foo val, symbol(bar): bar val} \n \nobject.defineproperties(o, { \n  [s3]: {value: 'baz val'}, \n  [s4]: {value: 'qux val'} \n}); \n \nconsole.log(o); \n// {symbol(foo): foo val, symbol(bar): bar val, \n//  symbol(baz): baz val, symbol(qux): qux val}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 将会返回常规属性，类似于object.getownpropertynames()返回对象实例的常规属性数组，object.getownpropertysymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。object.getownpropertydescriptors()会返回同时包含常规和符号属性描述符的对象。reflect.ownkeys()会返回两种类型的键。\n\nlet s1 = symbol('foo'), \n    s2 = symbol('bar');  \n \nlet o = { \n  [s1]: 'foo val', \n  [s2]: 'bar val', \n  baz: 'baz val', \n  qux: 'qux val' \n}; \n \nconsole.log(object.getownpropertysymbols(o)); \n// [symbol(foo), symbol(bar)] \n \nconsole.log(object.getownpropertynames(o)); \n// [\"baz\", \"qux\"] \n \nconsole.log(object.getownpropertydescriptors(o)); \n// {baz: {...}, qux: {...}, symbol(foo): {...}, symbol(bar): {...}} \n \nconsole.log(reflect.ownkeys(o)); \n// [\"baz\", \"qux\", symbol(foo), symbol(bar)]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 如何没有显示保存 symbol 的属性名，只能通过过滤对应的属性值来寻找符号属性名了。\n\nlet o = {  \n  [symbol('foo')]: 'foo val', \n  [symbol('bar')]: 'bar val' \n}; \n \nconsole.log(o); \n// {symbol(foo): \"foo val\", symbol(bar): \"bar val\"} \n \nlet barsymbol = object.getownpropertysymbols(o) \n              .find((symbol) => symbol.tostring().match(/bar/)); \n \nconsole.log(barsymbol); \n// symbol(bar) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# symbol 作为内置符号\n\necmascript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以symbol 工厂函数字符串属性的形式存在。 这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道for-of 循环会在相关对象上使用 symbol.iterator 属性，那么就可以通过在自定义对象上重新定义symbol.iterator 的值，来改变for-of 在迭代该对象时的行为。 这些内置符号也没有什么特别之处，它们就是全局函数symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。\n\n提示\n\n注意 在提到ecmascript 规范时，经常会引用符号在规范中的名称，前缀为@@。比如，@@iterator 指的就是symbol.iterator。\n\n\n# symbol.asynciterator\n\n根据ecmascript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的asynciterator。由for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器api 的函数。 for-await-of 循环会利用这个函数执行异步迭代操作。循环时，它们会调用以symbol.asynciterator为键的函数，并期望这个函数会返回一个实现迭代器api 的对象。很多时候，返回的对象是实现该api的asyncgenerator：\n\nclass foo {  \n  async *[symbol.asynciterator]() {} \n} \n \nlet f = new foo(); \n \nconsole.log(f[symbol.asynciterator]()); \n// asyncgenerator {<suspended>}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n技术上，这个由 symbol.asynciterator 函数生成的对象应该通过其 next()方法陆续返回promise 实例。可以通过显式地调用next()方法返回，也可以隐式地通过异步生成器函数返回：\n\nclass emitter {  \n  constructor(max) { \n    this.max = max; \n    this.asyncidx = 0; \n  } \n \n  async *[symbol.asynciterator]() { \n    while(this.asyncidx < this.max) { \n      yield new promise((resolve) => resolve(this.asyncidx++)); \n    } \n  } \n} \n \nasync function asynccount() { \n  let emitter = new emitter(5);\n  for await(const x of emitter) { \n    console.log(x); \n  } \n} \n \nasynccount(); \n// 0 \n// 1 \n// 2 \n// 3 \n// 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n提示\n\n注意 symbol.asynciterator 是 es2018 规范定义的，因此只有版本非常新的浏览器 支持它。\n\n\n# symbol.hasinstance\n\n作为对象的一个属性，使用对象的 obj[symbol.hasinstance] 方法和 使用 instanceof 关键字是一个效果\n\n同时，可以通过重新定义静态方法重写 symbol.hasinstance 来改变 instanceof 的行为\n\nclass myclass {  \n  static [symbol.hasinstance](instance) { \n    return instance instanceof object; \n  } \n} \n\nlet obj = { foo: 'bar' }; \nconsole.log(myclass[symbol.hasinstance](obj)); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# symbol.isconcatspreadable\n\n这个符号作为一个属性表示“一个布尔值，如果是true，则意味着对象应该用array.prototype.concat()打平其数组元素”。 这个符号的主要目标就是允许用户定义的对象可以与array.prototype.concat()很好地兼容。默认情况下，一个对象传递给concat()时，它会被简单地添加到数组中，作为一个元素：\n\nlet collection = {  \n  0: 'foo', \n  1: 'bar', \n  length: 2, \n  [symbol.isconcatspreadable]: true \n}; \n\nlet items = ['baz']; \nitems = items.concat(collection); \nconsole.log(items); \n// ['baz', 'foo', 'bar']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# symbol.iterator\n\n这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由for-of 语句使用”。这个符号表示实现迭代器api 的函数。 for-of 循环会在相关对象上使用这个函数，并期望这个函数会返回一个实现迭代器api 的对象。很多内置类型都实现了这个函数，比如 array、map 和 set。自定义对象默认不实现这个函数，因此除非显式定义，否则它们不能被for-of 循环直接迭代。\n\nclass emitter {  \n  constructor(max) { \n    this.max = max; \n    this.idx = 0; \n  } \n \n  *[symbol.iterator]() { \n    while(this.idx < this.max) { \n      yield this.idx++; \n    } \n  } \n} \n \nfunction count() { \n  let emitter = new emitter(5); \n \n  for (const x of emitter) { \n    console.log(x); \n  } \n} \n \ncount(); \n// 0\n// 1 \n// 2 \n// 3 \n// 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# symbol.match\n\n根据ecmascript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由string.prototype.match()方法使用”。string.prototype.matc()方法会使用以 symbol.match 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个string 方法的有效参数：\n\nconsole.log(regexp.prototype[symbol.match]); \n// ƒ [symbol.match]() { [native code] } \n \nconsole.log('foobar'.match(/bar/)); \n// [\"bar\", index: 3, input: \"foobar\", groups: unde\n\n\n1\n2\n3\n4\n5\n\n\n给这个方法传入非正则表达式值会导致该值被转换为regexp 对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义 symbol.match 函数以取代默认对正则表达式求值的行为，从而让match()方法使用非正则表达式实例。symbol.match 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制：\n\nclass foomatcher {  \n  static [symbol.match](target) { \n    return target.includes('foo'); \n  } \n} \n \nconsole.log('foobar'.match(foomatcher)); // true \nconsole.log('barbaz'.match(foomatcher)); // false \n \nclass stringmatcher { \n  constructor(str) { \n    this.str = str; \n  } \n \n  [symbol.match](target) { \n    return target.includes(this.str); \n  } \n} \n \nconsole.log('foobar'.match(new stringmatcher('foo'))); // true \nconsole.log('barbaz'.match(new stringmatcher('qux'))); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# symbol.replace\n\n根据ecmascript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 string.prototype.replace()方法使用”。string.prototype.replace()方法会使用以 symbol.replace 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个string 方法的有效参数：\n\nconsole.log(regexp.prototype[symbol.replace]); \n// ƒ [symbol.replace]() { [native code] } \n \nconsole.log('foobarbaz'.replace(/bar/, 'qux')); \n// 'fooquxbaz\n\n\n1\n2\n3\n4\n5\n\n\n给这个方法传入非正则表达式值会导致该值被转换为regexp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 symbol.replace 函数以取代默认对正则表达式求值的行为，从而让replace()方法使用非正则表达式实例。symbol.replace 函数接收两个参数，即调用replace()方法的字符串实例和替换字符串。返回的值没有限制：\n\nclass fooreplacer { \n  static [symbol.replace](target, replacement) { \n    return target.split('foo').join(replacement); \n  } \n}  \n \nconsole.log('barfoobaz'.replace(fooreplacer, 'qux')); \n// \"barquxbaz\" \n \nclass stringreplacer { \n  constructor(str) { \n    this.str = str; \n  } \n \n  [symbol.replace](target, replacement) { \n    return target.split(this.str).join(replacement); \n  } \n} \n \nconsole.log('barfoobaz'.replace(new stringreplacer('foo'), 'qux')); \n// \"barquxbaz\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# symbol.search\n\n根据ecmascript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回一个字符串中匹配正则表达式的索引。由string.prototype.search()方法使用”。string.prototype.search()方法会使用以 symbol.search 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个string 方法的有效参数：\n\nconsole.log(regexp.prototype[symbol.search]); \n// ƒ [symbol.search]() { [native code] } \n \nconsole.log('foobar'.search(/bar/)); \n// 3\n\n\n1\n2\n3\n4\n5\n\n\n给这个方法传入非正则表达式值会导致该值被转换为regexp 对象。如果想改变这种行为，让方法 直接使用参数，可以重新定义 symbol.search 函数以取代默认对正则表达式求值的行为，从而让 search()方法使用非正则表达式实例。symbol.search 函数接收一个参数，就是调用 match()方法 的字符串实例。返回的值没有限制：\n\nclass foosearcher {  \n  static [symbol.search](target) { \n    return target.indexof('foo'); \n  } \n}\nconsole.log('foobar'.search(foosearcher)); // 0 \nconsole.log('barfoo'.search(foosearcher)); // 3 \nconsole.log('barbaz'.search(foosearcher)); // -1 \n \nclass stringsearcher { \n  constructor(str) { \n    this.str = str; \n  } \n \n  [symbol.search](target) { \n    return target.indexof(this.str); \n  } \n} \n \nconsole.log('foobar'.search(new stringsearcher('foo'))); // 0 \nconsole.log('barfoo'.search(new stringsearcher('foo'))); // 3 \nconsole.log('barbaz'.search(new stringsearcher('qux')));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# symbol.species\n\n根据ecmascript 规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：\n\nclass bar extends array {}  \nclass baz extends array { \n  static get [symbol.species]() { \n    return array; \n  } \n} \n \nlet bar = new bar(); \nconsole.log(bar instanceof array); // true \nconsole.log(bar instanceof bar);   // true \nbar = bar.concat('bar'); \nconsole.log(bar instanceof array); // true \nconsole.log(bar instanceof bar);   // true \n \nlet baz = new baz(); \nconsole.log(baz instanceof array); // true \nconsole.log(baz instanceof baz);   // true \nbaz = baz.concat('baz'); \nconsole.log(baz instanceof array); // true \nconsole.log(baz instanceof baz);   // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# symbol.split\n\n根据ecmascript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 string.prototype.split()方法使用”。string.prototype. split()方法会使用以 symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个string 方法的有效参数：\n\nconsole.log(regexp.prototype[symbol.split]); \n// ƒ [symbol.split]() { [native code] } \n \nconsole.log('foobarbaz'.split(/bar/)); \n// ['foo', 'baz\n\n\n1\n2\n3\n4\n5\n\n\n给这个方法传入非正则表达式值会导致该值被转换为regexp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义symbol.split 函数以取代默认对正则表达式求值的行为，从而让split()方法使用非正则表达式实例。symbol.split 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制：\n\nclass foosplitter {  \n  static [symbol.split](target) { \n    return target.split('foo'); \n  } \n} \n \nconsole.log('barfoobaz'.split(foosplitter)); \n// [\"bar\", \"baz\"] \n \nclass stringsplitter { \n  constructor(str) { \n    this.str = str; \n  } \n \n  [symbol.split](target) { \n    return target.split(this.str); \n  } \n} \n \nconsole.log('barfoobaz'.split(new stringsplitter('foo'))); \n// [\"bar\", \"baz\"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# symbol.toprimitive\n\n根据ecmascript 规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由toprimitive 抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的symbol.toprimitive 属性上定义一个函数可以改变默认行为。\n\n根据提供给这个函数的参数（string、number 或default），可以控制返回的原始值：\n\nclass foo {}  \nlet foo = new foo(); \n \nconsole.log(3 + foo);       // \"3[object object]\" \nconsole.log(3 - foo);       // nan \nconsole.log(string(foo));   // \"[object object]\" \n \nclass bar { \n  constructor() { \n    this[symbol.toprimitive] = function(hint) { \n      switch (hint) { \n        case 'number': \n          return 3; \n        case 'string': \n          return 'string bar'; \n        case 'default': \n        default: \n          return 'default bar'; \n      } \n    } \n  } \n}\nlet bar = new bar()\nconsole.log(3 + bar);       // \"3default bar\" \nconsole.log(3 - bar);       // 0 \nconsole.log(string(bar));   // \"string bar\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# symbol.tostringtag\n\n根据ecmascript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法object.prototype.tostring()使用”。 通过tostring()方法获取对象标识时，会检索由symbol.tostringtag指定的实例标识符，默认为 \"object\"。内置类型已经指定了这个值，但自定义实例还需要明确定义。\n\nlet s = new set(); \n \nconsole.log(s);                      // set(0) {} \nconsole.log(s.tostring());           // [object set] \nconsole.log(s[symbol.tostringtag]);  // set \n \nclass foo {}  \nlet foo = new foo(); \n \nconsole.log(foo);                      // foo {} \nconsole.log(foo.tostring());           // [object object] \nconsole.log(foo[symbol.tostringtag]);  // undefined \n \nclass bar { \n  constructor() { \n    this[symbol.tostringtag] = 'bar'; \n  } \n} \nlet bar = new bar(); \n \nconsole.log(bar);                      // bar {} \nconsole.log(bar.tostring());           // [object bar]\nconsole.log(bar[symbol.tostringtag]);  // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# symbol.unscopables\n\n根据ecmascript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的with 环境绑定中排除”。设置止该属性出现在with 环境绑定中，如下例所示：\n\n \nwith (o) {  \n  console.log(foo); // bar \n} \n \no[symbol.unscopables] = { \n  foo: true \n}; \n \nwith (o) { \n  console.log(foo); // referenceerror \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意\n\n不推荐使用with，因此也不推荐使用symbol.unscopables。\n\n\n# object 类型\n\nobject 类型的所有属性和方法在派生的对象上同样存在。\n\n每个object 实例都有如下属性和方法。\n\n * constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 object() 函数。\n * hasownproperty(propertyname)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如o.hasownproperty(\"name\")）或符号。\n * isprototypeof(object)：用于判断当前对象是否为另一个对象的原型。（第 8 章将详细介绍原型。）\n * propertyisenumerable(propertyname)：用于判断给定的属性是否可以使用（本章稍后讨论的）for-in 语句枚举。与hasownproperty()一样，属性名必须是字符串。\n * tolocalestring()：返回对象的字符串表示，该字符串反映对象所在的本地化执行境。\n * tostring()：返回对象的字符串表示。\n * valueof()：返回对象对应的字符串、数值或布尔值表示。通常与tostring()的返回值相同。\n\n提示\n\n注意 严格来讲，ecma-262 中对象的行为不一定适合 javascript 中的其他对象。比如浏览器环境中的 bom 和 dom 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受ecma-262 约束，所以它们可能会也可能不会继承object。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"html中的js",frontmatter:{title:"html中的js",date:"2024-07-31T01:00:29.000Z",permalink:"/pages/ac246c/",categories:["前端","JavaScript"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/03.html%E4%B8%AD%E7%9A%84js.html",relativePath:"01.前端/03.JavaScript高级程序设计/03.html中的js.md",key:"v-5c39b61f",path:"/pages/ac246c/",headers:[{level:2,title:"<script> 元素",slug:"script-元素",normalizedTitle:"<script> 元素",charIndex:25},{level:3,title:"标签位置",slug:"标签位置",normalizedTitle:"标签位置",charIndex:383},{level:3,title:"defer",slug:"defer",normalizedTitle:"defer",charIndex:507},{level:3,title:"async",slug:"async",normalizedTitle:"async",charIndex:562},{level:3,title:"动态加载",slug:"动态加载",normalizedTitle:"动态加载",charIndex:593},{level:3,title:"XHTML（已废弃，可不再关注）",slug:"xhtml-已废弃-可不再关注",normalizedTitle:"xhtml（已废弃，可不再关注）",charIndex:846},{level:3,title:"行内代码与外部文件",slug:"行内代码与外部文件",normalizedTitle:"行内代码与外部文件",charIndex:1105},{level:3,title:"文档模式",slug:"文档模式",normalizedTitle:"文档模式",charIndex:1130},{level:2,title:"<noscript>标签的用途",slug:"noscript-标签的用途",normalizedTitle:"<noscript>标签的用途",charIndex:1242}],headersStr:"<script> 元素 标签位置 defer async 动态加载 XHTML（已废弃，可不再关注） 行内代码与外部文件 文档模式 <noscript>标签的用途",content:'# HTML 中的 JavaScript\n\n\n# <script> 元素\n\nscript>元素的一个最为强大、同时也备受争议的特性是，它可以包含来自外部域的 JavaScript 文件。跟<img>元素很像，<script>元素的 src 属性可以是一个完整的 URL，而且这个 URL 指向的 资源可以跟包含它的HTML 页面不在同一个域中，比如这个例子：\n\n<script src="http://www.somewhere.com/afile.js"><\/script>\n\n浏览器在解析这个资源时，会向 src 属性指定的路径发送一个 GET 请求，以取得相应资源，假定是一个JavaScript 文件。这个初始的请求不受浏览器同源策略限制，但返回并被执行的JavaScript 则受限制。当然，这个请求仍然受父页面HTTP/HTTPS 协议的限制。\n\n\n# 标签位置\n\n在 head 标签中加入script会导致白屏问题，所以过去一般把script标签放在内容的后面，这样一来，页面会在处理 JavaScript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。\n\n\n# defer\n\n延迟执行脚本，相当于放在底部，script会按照顺序执行。实际上不一定，最好只有一个。\n\n\n# async\n\n异步执行，在后台加载完之后就会立即执行\n\n\n# 动态加载\n\n除了<script>标签，还有其他方式可以加载脚本。因为JavaScript 可以使用DOM API，所以通过向DOM 中动态添加script 元素同样可以加载指定的脚本。\n\n以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：\n\n<link rel="preload" href="gibberish.js">\n\n\n# XHTML（已废弃，可不再关注）\n\n可扩展超文本标记语言（XHTML，Extensible HyperText Markup Language）是将HTML 作为XML的应用重新包装的结果。与 HTML 不同，在 XHTML 中使用 JavaScript 必须指定 type 属性且值为text/javascript，HTML 中则可以没有这个属性。XHTML 虽然已经退出历史舞台，但实践中偶尔可能也会遇到遗留代码。\n\n兼容XHTML，可以人工转译，也可以使用CDATA 块表示文档中可以包含任意文本的区块\n\n\n# 行内代码与外部文件\n\n外部文件是最佳实践\n\n\n# 文档模式\n\nIE5.5 发明了文档模式的概念，即可以使用doctype 切换文档模式。最初的文档模式有两种：混杂模式（quirks mode）和标准模式（standards mode）\n\n可以使用文档模式来兼容IE\n\n\n# <noscript>标签的用途\n\n下面是一个例子：\n\n<!DOCTYPE html> \n<html>  \n  <head> \n  <title>Example HTML Page</title> \n  <script defer="defer" src="example1.js"><\/script> \n  <script defer="defer" src="example2.js"><\/script> \n  </head> \n  <body> \n  <noscript> \n    <p>This page requires a JavaScript-enabled browser.</p> \n  </noscript> \n  </body> \n</html> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。',normalizedContent:'# html 中的 javascript\n\n\n# <script> 元素\n\nscript>元素的一个最为强大、同时也备受争议的特性是，它可以包含来自外部域的 javascript 文件。跟<img>元素很像，<script>元素的 src 属性可以是一个完整的 url，而且这个 url 指向的 资源可以跟包含它的html 页面不在同一个域中，比如这个例子：\n\n<script src="http://www.somewhere.com/afile.js"><\/script>\n\n浏览器在解析这个资源时，会向 src 属性指定的路径发送一个 get 请求，以取得相应资源，假定是一个javascript 文件。这个初始的请求不受浏览器同源策略限制，但返回并被执行的javascript 则受限制。当然，这个请求仍然受父页面http/https 协议的限制。\n\n\n# 标签位置\n\n在 head 标签中加入script会导致白屏问题，所以过去一般把script标签放在内容的后面，这样一来，页面会在处理 javascript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。\n\n\n# defer\n\n延迟执行脚本，相当于放在底部，script会按照顺序执行。实际上不一定，最好只有一个。\n\n\n# async\n\n异步执行，在后台加载完之后就会立即执行\n\n\n# 动态加载\n\n除了<script>标签，还有其他方式可以加载脚本。因为javascript 可以使用dom api，所以通过向dom 中动态添加script 元素同样可以加载指定的脚本。\n\n以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：\n\n<link rel="preload" href="gibberish.js">\n\n\n# xhtml（已废弃，可不再关注）\n\n可扩展超文本标记语言（xhtml，extensible hypertext markup language）是将html 作为xml的应用重新包装的结果。与 html 不同，在 xhtml 中使用 javascript 必须指定 type 属性且值为text/javascript，html 中则可以没有这个属性。xhtml 虽然已经退出历史舞台，但实践中偶尔可能也会遇到遗留代码。\n\n兼容xhtml，可以人工转译，也可以使用cdata 块表示文档中可以包含任意文本的区块\n\n\n# 行内代码与外部文件\n\n外部文件是最佳实践\n\n\n# 文档模式\n\nie5.5 发明了文档模式的概念，即可以使用doctype 切换文档模式。最初的文档模式有两种：混杂模式（quirks mode）和标准模式（standards mode）\n\n可以使用文档模式来兼容ie\n\n\n# <noscript>标签的用途\n\n下面是一个例子：\n\n<!doctype html> \n<html>  \n  <head> \n  <title>example html page</title> \n  <script defer="defer" src="example1.js"><\/script> \n  <script defer="defer" src="example2.js"><\/script> \n  </head> \n  <body> \n  <noscript> \n    <p>this page requires a javascript-enabled browser.</p> \n  </noscript> \n  </body> \n</html> \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。',charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"什么是JavaScript",frontmatter:{title:"什么是JavaScript",date:"2024-07-31T00:32:47.000Z",permalink:"/pages/3946c7/",categories:["前端","JavaScript"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/02.%E4%BB%80%E4%B9%88%E6%98%AFJavaScript.html",relativePath:"01.前端/03.JavaScript高级程序设计/02.什么是JavaScript.md",key:"v-73f8edea",path:"/pages/3946c7/",headers:[{level:2,title:"ECMAScript",slug:"ecmascript",normalizedTitle:"ecmascript",charIndex:52},{level:3,title:"ES6 更新",slug:"es6-更新",normalizedTitle:"es6 更新",charIndex:184},{level:3,title:"ES8 更新",slug:"es8-更新",normalizedTitle:"es8 更新",charIndex:326},{level:3,title:"ES 符合性与 TypeScript",slug:"es-符合性与-typescript",normalizedTitle:"es 符合性与 typescript",charIndex:534},{level:2,title:"DOM",slug:"dom",normalizedTitle:"dom",charIndex:74},{level:2,title:"BOM",slug:"bom",normalizedTitle:"bom",charIndex:90}],headersStr:"ECMAScript ES6 更新 ES8 更新 ES 符合性与 TypeScript DOM BOM",content:"# JavaScript 实现\n\n完整的 JavaScript 实现由以下三个部分组成：\n\n * 核心（ECMAScript）\n * 文档对象模型（DOM）\n * 浏览器对象模型（BOM）\n\nECMA-262 定义的语言包含以下部分\n\n * 语法\n * 类型\n * 语句\n * 关键字\n * 保留字\n * 操作符\n * 全局对象\n\n\n# ECMAScript\n\n\n# ES6 更新\n\nECMA-262 第6 版，俗称ES6、ES2015 或ES Harmony（和谐版），于2015 年6 月发布。这一版包含了大概这个规范有史以来最重要的一批增强特性。ES6 正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型。\n\n\n# ES8 更新\n\nECMA-262 第8 版，也称为ES8、ES2017，完成于2017 年6 月。这一版主要增加了异步函数（async/ await）、SharedArrayBuffer 及Atomics API，以及Object.values()/Object.entries()/Object. getOwnPropertyDescriptors()和字符串填充方法，另外明确支持对象字面量最后的逗号。\n\n\n# ES 符合性与 TypeScript\n\nECMAScript 是 JavaScript 的标准，而 TypeScript 是 JavaScript 的超集，它为 JavaScript 添加了可选的静态类型和基于类的面向对象编程。\n\n支持ECMA-262 中描述的所有“类型、值、对象、属性、函数，以及程序语法与语义”；\n\n支持Unicode 字符标准。\n\n此外，符合性实现还可以满足下列要求。\n\n增加ECMA-262 中未提及的“额外的类型、值、对象、属性和函数”。ECMA-262 所说的这些额外内容主要指规范中未给出的新对象或对象的新属性。 支持ECMA-262 中没有定义的“程序和正则表达式语法”（意思是允许修改和扩展内置的正则表达式特性）。\n\n\n# DOM\n\n文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在HTML 中使用扩展的XML。\n\n\n# BOM\n\nIE3 和Netscape Navigator 3 提供了浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。使用BOM，开发者可以操控浏览器显示页面之外的部分。而BOM 真正独一无二的地方，当然也是问题最多的地方，就是它是唯一一个没有相关标准的JavaScript 实现。HTML5 改变了这个局面，这个版本的 HTML 以正式规范的形式涵盖了尽可能多的 BOM 特性。由于 HTML5 的出现，之前很多与 BOM有关的问题都迎刃而解了。 总体来说，BOM 主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的扩展都归在BOM 的范畴内。",normalizedContent:"# javascript 实现\n\n完整的 javascript 实现由以下三个部分组成：\n\n * 核心（ecmascript）\n * 文档对象模型（dom）\n * 浏览器对象模型（bom）\n\necma-262 定义的语言包含以下部分\n\n * 语法\n * 类型\n * 语句\n * 关键字\n * 保留字\n * 操作符\n * 全局对象\n\n\n# ecmascript\n\n\n# es6 更新\n\necma-262 第6 版，俗称es6、es2015 或es harmony（和谐版），于2015 年6 月发布。这一版包含了大概这个规范有史以来最重要的一批增强特性。es6 正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型。\n\n\n# es8 更新\n\necma-262 第8 版，也称为es8、es2017，完成于2017 年6 月。这一版主要增加了异步函数（async/ await）、sharedarraybuffer 及atomics api，以及object.values()/object.entries()/object. getownpropertydescriptors()和字符串填充方法，另外明确支持对象字面量最后的逗号。\n\n\n# es 符合性与 typescript\n\necmascript 是 javascript 的标准，而 typescript 是 javascript 的超集，它为 javascript 添加了可选的静态类型和基于类的面向对象编程。\n\n支持ecma-262 中描述的所有“类型、值、对象、属性、函数，以及程序语法与语义”；\n\n支持unicode 字符标准。\n\n此外，符合性实现还可以满足下列要求。\n\n增加ecma-262 中未提及的“额外的类型、值、对象、属性和函数”。ecma-262 所说的这些额外内容主要指规范中未给出的新对象或对象的新属性。 支持ecma-262 中没有定义的“程序和正则表达式语法”（意思是允许修改和扩展内置的正则表达式特性）。\n\n\n# dom\n\n文档对象模型（dom，document object model）是一个应用编程接口（api），用于在html 中使用扩展的xml。\n\n\n# bom\n\nie3 和netscape navigator 3 提供了浏览器对象模型（bom） api，用于支持访问和操作浏览器的窗口。使用bom，开发者可以操控浏览器显示页面之外的部分。而bom 真正独一无二的地方，当然也是问题最多的地方，就是它是唯一一个没有相关标准的javascript 实现。html5 改变了这个局面，这个版本的 html 以正式规范的形式涵盖了尽可能多的 bom 特性。由于 html5 的出现，之前很多与 bom有关的问题都迎刃而解了。 总体来说，bom 主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的扩展都归在bom 的范畴内。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"变量、作用域与内存",frontmatter:{title:"变量、作用域与内存",date:"2024-08-23T23:57:19.000Z",permalink:"/pages/d218d6/",categories:["前端","JavaScript高级程序设计"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/06.%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98.html",relativePath:"01.前端/03.JavaScript高级程序设计/06.变量、作用域与内存.md",key:"v-f309980c",path:"/pages/d218d6/",headers:[{level:2,title:"原始值与引用值",slug:"原始值与引用值",normalizedTitle:"原始值与引用值",charIndex:2},{level:3,title:"复制值",slug:"复制值",normalizedTitle:"复制值",charIndex:535},{level:2,title:"执行上下文与作用域",slug:"执行上下文与作用域",normalizedTitle:"执行上下文与作用域",charIndex:659},{level:3,title:"作用域链增强",slug:"作用域链增强",normalizedTitle:"作用域链增强",charIndex:1052},{level:3,title:"变量声明",slug:"变量声明",normalizedTitle:"变量声明",charIndex:1132},{level:2,title:"垃圾回收",slug:"垃圾回收",normalizedTitle:"垃圾回收",charIndex:1400},{level:3,title:"标记清理",slug:"标记清理",normalizedTitle:"标记清理",charIndex:1443},{level:3,title:"引用计数",slug:"引用计数",normalizedTitle:"引用计数",charIndex:1448},{level:3,title:"垃圾回收与性能",slug:"垃圾回收与性能",normalizedTitle:"垃圾回收与性能",charIndex:2445},{level:3,title:"内存管理",slug:"内存管理",normalizedTitle:"内存管理",charIndex:2812},{level:4,title:"隐藏类和删除操作",slug:"隐藏类和删除操作",normalizedTitle:"隐藏类和删除操作",charIndex:3523},{level:4,title:"内存泄露",slug:"内存泄露",normalizedTitle:"内存泄露",charIndex:4967},{level:4,title:"静态分配与对象池",slug:"静态分配与对象池",normalizedTitle:"静态分配与对象池",charIndex:5772}],headersStr:"原始值与引用值 复制值 执行上下文与作用域 作用域链增强 变量声明 垃圾回收 标记清理 引用计数 垃圾回收与性能 内存管理 隐藏类和删除操作 内存泄露 静态分配与对象池",content:"# 原始值与引用值\n\n原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。\n\n原始值不能有属性，尽管尝试给原始值添加属性不会报错。\n\nlet name = \"Nicholas\";\nname.age = 27;\nconsole.log(name.age); // undefined\n\n\n1\n2\n3\n\n\n注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是new 关键字，则JavaScript 会创建一个Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：\n\nlet name1 = \"Nicholas\";\nlet name2 = new String(\"Matt\");\nname1.age = 27;\nname2.age = 26;\nconsole.log(name1.age); // undefined\nconsole.log(name2.age); // 26\nconsole.log(typeof name1); // string\nconsole.log(typeof name2); // object\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 复制值\n\n在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。\n\n在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。\n\n\n# 执行上下文与作用域\n\n上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。\n\n代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）\n\n局部作用域中定义的变量可用于在局部上下文中替换全局变量。\n\n\n# 作用域链增强\n\n使用 try/catch 语句的 catch 块和 with 语句都会导致作用前端临时添加一个上下文，这个上下文在代码执行后会被删除。\n\n\n# 变量声明\n\n根据标识符从下往上查找标识符的规律，结合“使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次”的特点，可以局部声明一个新的变量，用来处理对应的逻辑。\n\nvar color = 'blue';\nfunction getColor() {\n  let color = 'red';\n  {\n    let color = 'green';\n    return color;\n  }\n}\nconsole.log(getColor()); // 'green'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 垃圾回收\n\n垃圾回收的定义：执行环境负责在代码执行时管理内存。\n\n垃圾回收的两种策略：标记清理和引用计数\n\n\n# 标记清理\n\nJavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。\n\n给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。\n\n垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。\n\n到了2008 年，IE、Firefox、Opera、Chrome 和Safari 都在自己的JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。\n\n\n# 引用计数\n\n另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0 的值的内存。\n\n引用计数最早由Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象A 有一个指针指向对象B，而对象B 也引用了对象A。比如：\n\nfunction problem() {\n  let objectA = new Object();\n  let objectB = new Object();\n  objectA.someOtherObject = objectB;\n  objectB.anotherObject = objectA;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 垃圾回收与性能\n\n垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。\n\n比如，根据V8 团队2016 年的一篇博文的说法：“在一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”\n\n注意\n\n在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在IE 中，window.CollectGarbage()方法会立即触发垃圾回收。在Opera 7 及更高版本中，调用window.opera.collect()也会启动垃圾回收程序。\n\n\n# 内存管理\n\n在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过，JavaScript 运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量JavaScript 的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。\n\n将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用，如下面的例子所示：\n\nfunction createPerson(name){\n  let localPerson = new Object();\n  localPerson.name = name;\n  return localPerson;\n}\nlet globalPerson = createPerson(\"Nicholas\");\n// 解除globalPerson 对值的引用\nglobalPerson = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n笔记\n\nES6新增加的 const 和 let 关键字不仅有助于改善代码风格，同样有助于改进垃圾回收的过程。因为 const 和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地将变量自动解除引用，从而有利于垃圾回收。\n\n# 隐藏类和删除操作\n\n笔记\n\n根据JavaScript 所在的运行环境，有时候需要根据浏览器使用的JavaScript 引擎来采取不同的性能优化策略。截至2017 年，Chrome 是最流行的浏览器，使用V8 JavaScript 引擎。V8 在将解释后的JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很重要。\n\n运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到。\n\nfunction Article() {\n  this.title = 'Inauguration Ceremony Features Kazoo Band';\n}\nlet a1 = new Article();\nlet a2 = new Article();\n\n\n1\n2\n3\n4\n5\n\n\nV8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：\n\na2.author = 'Jake';\n\n\n1\n\n\n此时两个Article 实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。\n\n当然，解决方案就是避免JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有属性，如下所示：\n\nfunction Article(opt_author) {\n  this.title = 'Inauguration Ceremony Features Kazoo Band';\n  this.author = opt_author;\n}\nlet a1 = new Article();\nlet a2 = new Article('Jake');\n\n\n1\n2\n3\n4\n5\n6\n\n\n这样，两个实例基本上就一样了（不考虑hasOwnProperty 的返回值），因此可以共享一个隐藏类，从而带来潜在的性能提升。不过要记住，使用delete 关键字会导致生成相同的隐藏类片段。看一下这个例子：\n\nfunction Article() {\n  this.title = 'Inauguration Ceremony Features Kazoo Band';\n  this.author = 'Jake';\n}\nlet a1 = new Article();\nlet a2 = new Article();\ndelete a1.author;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在代码结束后，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。比如：\n\nfunction Article() {\n  this.title = 'Inauguration Ceremony Features Kazoo Band';\n  this.author = 'Jake';\n}\nlet a1 = new Article();\nlet a2 = new Article();\na1.author = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 内存泄露\n\n写得不好的JavaScript 可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。\n\n意外声明全局变量是最常见但也最容易修复的内存泄漏问题。\n\nfunction setName() {\n  name = 'Jake';\n}\n\n\n1\n2\n3\n\n\n此时，解释器会把变量name 当作window 的属性来创建（相当于window.name = 'Jake'）。可想而知，在window 对象上创建的属性，只要window 本身不被清理就不会消失。这个问题很容易解决，只要在变量声明前头加上var、let 或const 关键字即可，这样变量就会在函数执行完毕后离开作用域。\n\n定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：\n\nlet name = 'Jake';\nsetInterval(() => {\n  console.log(name);\n}, 100);\n\n\n1\n2\n3\n4\n\n\n只要定时器一直运行，回调函数中引用的name 就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。\n\n使用JavaScript 闭包很容易在不知不觉间造成内存泄漏。请看下面的例子：\n\nlet outer = function() {\n  let name = 'Jake';\n  return function() {\n    return name;\n  };\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用outer()会导致分配给name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理name，因为闭包一直在引用着它。假如name 的内容很大（不止是一个小字符串），那可能就是个大问题了。\n\n# 静态分配与对象池\n\n为了提升JavaScript 性能，最后要考虑的一点往往就是压榨浏览器了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。\n\n浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。\n\n看一看下面的例子，这是一个计算二维矢量加法的函数：\n\nfunction addVector(a, b) {\n  let resultant = new Vector();\n  resultant.x = a.x + b.x;\n  resultant.y = a.y + b.y;\n  return resultant;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。假如这个矢量加法函数频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。\n\n该问题的解决方案是不要动态创建矢量对象，比如可以修改上面的函数，让它使用一个已有的矢量对象：\n\nfunction addVector(a, b, resultant) {\n  resultant.x = a.x + b.x;\n  resultant.y = a.y + b.y;\n  return resultant;\n}\n\n\n1\n2\n3\n4\n5\n\n\n当然，这需要在其他地方实例化矢量参数resultant，但这个函数的行为没有变。那么在哪里创建矢量可以不让垃圾回收调度程序盯上呢？\n\n一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现：\n\n// vectorPool 是已有的对象池\nlet v1 = vectorPool.allocate();\nlet v2 = vectorPool.allocate();\nlet v3 = vectorPool.allocate();\nv1.x = 10;\nv1.y = 5;\nv2.x = -3;\nv2.y = -6;\naddVector(v1, v2, v3);\nconsole.log([v3.x, v3.y]); // [7, -1]\nvectorPool.free(v1);\nvectorPool.free(v2);\nvectorPool.free(v3);\n// 如果对象有属性引用了其他对象\n// 则这里也需要把这些属性设置为null\nv1 = null;\nv2 = null;\nv3 = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。\n\n比如下面这个例子：\n\nlet vectorList = new Array(100);\nlet vector = new Vector();\nvectorList.push(vector);\n\n\n1\n2\n3\n\n\n由于JavaScript 数组的大小是动态可变的，引擎会删除大小为100 的数组，再创建一个新的大小为200 的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，必须事先想好这个数组有多大。\n\n笔记\n\n静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。",normalizedContent:"# 原始值与引用值\n\n原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。\n\n原始值不能有属性，尽管尝试给原始值添加属性不会报错。\n\nlet name = \"nicholas\";\nname.age = 27;\nconsole.log(name.age); // undefined\n\n\n1\n2\n3\n\n\n注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是new 关键字，则javascript 会创建一个object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：\n\nlet name1 = \"nicholas\";\nlet name2 = new string(\"matt\");\nname1.age = 27;\nname2.age = 26;\nconsole.log(name1.age); // undefined\nconsole.log(name2.age); // 26\nconsole.log(typeof name1); // string\nconsole.log(typeof name2); // object\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 复制值\n\n在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。\n\n在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。\n\n\n# 执行上下文与作用域\n\n上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。\n\n代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）\n\n局部作用域中定义的变量可用于在局部上下文中替换全局变量。\n\n\n# 作用域链增强\n\n使用 try/catch 语句的 catch 块和 with 语句都会导致作用前端临时添加一个上下文，这个上下文在代码执行后会被删除。\n\n\n# 变量声明\n\n根据标识符从下往上查找标识符的规律，结合“使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次”的特点，可以局部声明一个新的变量，用来处理对应的逻辑。\n\nvar color = 'blue';\nfunction getcolor() {\n  let color = 'red';\n  {\n    let color = 'green';\n    return color;\n  }\n}\nconsole.log(getcolor()); // 'green'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 垃圾回收\n\n垃圾回收的定义：执行环境负责在代码执行时管理内存。\n\n垃圾回收的两种策略：标记清理和引用计数\n\n\n# 标记清理\n\njavascript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。\n\n给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。\n\n垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。\n\n到了2008 年，ie、firefox、opera、chrome 和safari 都在自己的javascript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。\n\n\n# 引用计数\n\n另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0 的值的内存。\n\n引用计数最早由netscape navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象a 有一个指针指向对象b，而对象b 也引用了对象a。比如：\n\nfunction problem() {\n  let objecta = new object();\n  let objectb = new object();\n  objecta.someotherobject = objectb;\n  objectb.anotherobject = objecta;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 垃圾回收与性能\n\n垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。\n\n比如，根据v8 团队2016 年的一篇博文的说法：“在一次完整的垃圾回收之后，v8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”\n\n注意\n\n在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在ie 中，window.collectgarbage()方法会立即触发垃圾回收。在opera 7 及更高版本中，调用window.opera.collect()也会启动垃圾回收程序。\n\n\n# 内存管理\n\n在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过，javascript 运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量javascript 的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。\n\n将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用，如下面的例子所示：\n\nfunction createperson(name){\n  let localperson = new object();\n  localperson.name = name;\n  return localperson;\n}\nlet globalperson = createperson(\"nicholas\");\n// 解除globalperson 对值的引用\nglobalperson = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n笔记\n\nes6新增加的 const 和 let 关键字不仅有助于改善代码风格，同样有助于改进垃圾回收的过程。因为 const 和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地将变量自动解除引用，从而有利于垃圾回收。\n\n# 隐藏类和删除操作\n\n笔记\n\n根据javascript 所在的运行环境，有时候需要根据浏览器使用的javascript 引擎来采取不同的性能优化策略。截至2017 年，chrome 是最流行的浏览器，使用v8 javascript 引擎。v8 在将解释后的javascript代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很重要。\n\n运行期间，v8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，v8 会针对这种情况进行优化，但不一定总能够做到。\n\nfunction article() {\n  this.title = 'inauguration ceremony features kazoo band';\n}\nlet a1 = new article();\nlet a2 = new article();\n\n\n1\n2\n3\n4\n5\n\n\nv8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：\n\na2.author = 'jake';\n\n\n1\n\n\n此时两个article 实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。\n\n当然，解决方案就是避免javascript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有属性，如下所示：\n\nfunction article(opt_author) {\n  this.title = 'inauguration ceremony features kazoo band';\n  this.author = opt_author;\n}\nlet a1 = new article();\nlet a2 = new article('jake');\n\n\n1\n2\n3\n4\n5\n6\n\n\n这样，两个实例基本上就一样了（不考虑hasownproperty 的返回值），因此可以共享一个隐藏类，从而带来潜在的性能提升。不过要记住，使用delete 关键字会导致生成相同的隐藏类片段。看一下这个例子：\n\nfunction article() {\n  this.title = 'inauguration ceremony features kazoo band';\n  this.author = 'jake';\n}\nlet a1 = new article();\nlet a2 = new article();\ndelete a1.author;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在代码结束后，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。比如：\n\nfunction article() {\n  this.title = 'inauguration ceremony features kazoo band';\n  this.author = 'jake';\n}\nlet a1 = new article();\nlet a2 = new article();\na1.author = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 内存泄露\n\n写得不好的javascript 可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。javascript 中的内存泄漏大部分是由不合理的引用导致的。\n\n意外声明全局变量是最常见但也最容易修复的内存泄漏问题。\n\nfunction setname() {\n  name = 'jake';\n}\n\n\n1\n2\n3\n\n\n此时，解释器会把变量name 当作window 的属性来创建（相当于window.name = 'jake'）。可想而知，在window 对象上创建的属性，只要window 本身不被清理就不会消失。这个问题很容易解决，只要在变量声明前头加上var、let 或const 关键字即可，这样变量就会在函数执行完毕后离开作用域。\n\n定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：\n\nlet name = 'jake';\nsetinterval(() => {\n  console.log(name);\n}, 100);\n\n\n1\n2\n3\n4\n\n\n只要定时器一直运行，回调函数中引用的name 就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。\n\n使用javascript 闭包很容易在不知不觉间造成内存泄漏。请看下面的例子：\n\nlet outer = function() {\n  let name = 'jake';\n  return function() {\n    return name;\n  };\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用outer()会导致分配给name 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理name，因为闭包一直在引用着它。假如name 的内容很大（不止是一个小字符串），那可能就是个大问题了。\n\n# 静态分配与对象池\n\n为了提升javascript 性能，最后要考虑的一点往往就是压榨浏览器了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。\n\n浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。\n\n看一看下面的例子，这是一个计算二维矢量加法的函数：\n\nfunction addvector(a, b) {\n  let resultant = new vector();\n  resultant.x = a.x + b.x;\n  resultant.y = a.y + b.y;\n  return resultant;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。假如这个矢量加法函数频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。\n\n该问题的解决方案是不要动态创建矢量对象，比如可以修改上面的函数，让它使用一个已有的矢量对象：\n\nfunction addvector(a, b, resultant) {\n  resultant.x = a.x + b.x;\n  resultant.y = a.y + b.y;\n  return resultant;\n}\n\n\n1\n2\n3\n4\n5\n\n\n当然，这需要在其他地方实例化矢量参数resultant，但这个函数的行为没有变。那么在哪里创建矢量可以不让垃圾回收调度程序盯上呢？\n\n一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现：\n\n// vectorpool 是已有的对象池\nlet v1 = vectorpool.allocate();\nlet v2 = vectorpool.allocate();\nlet v3 = vectorpool.allocate();\nv1.x = 10;\nv1.y = 5;\nv2.x = -3;\nv2.y = -6;\naddvector(v1, v2, v3);\nconsole.log([v3.x, v3.y]); // [7, -1]\nvectorpool.free(v1);\nvectorpool.free(v2);\nvectorpool.free(v3);\n// 如果对象有属性引用了其他对象\n// 则这里也需要把这些属性设置为null\nv1 = null;\nv2 = null;\nv3 = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。\n\n比如下面这个例子：\n\nlet vectorlist = new array(100);\nlet vector = new vector();\nvectorlist.push(vector);\n\n\n1\n2\n3\n\n\n由于javascript 数组的大小是动态可变的，引擎会删除大小为100 的数组，再创建一个新的大小为200 的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，必须事先想好这个数组有多大。\n\n笔记\n\n静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。",charsets:{cjk:!0},lastUpdated:"2024/08/25, 00:09:49",lastUpdatedTimestamp:1724515789e3},{title:"语法基础（二）",frontmatter:{title:"语法基础（二）",date:"2024-08-03T19:29:27.000Z",permalink:"/pages/546def/",categories:["前端","JavaScript"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/05.%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89.html",relativePath:"01.前端/03.JavaScript高级程序设计/05.语法基础（二）.md",key:"v-7873b251",path:"/pages/546def/",headers:[{level:2,title:"操作符",slug:"操作符",normalizedTitle:"操作符",charIndex:2},{level:3,title:"一元操作符",slug:"一元操作符",normalizedTitle:"一元操作符",charIndex:10},{level:4,title:"递增与递减",slug:"递增与递减",normalizedTitle:"递增与递减",charIndex:19},{level:4,title:"一元 加减",slug:"一元-加减",normalizedTitle:"一元 加减",charIndex:537},{level:3,title:"位操作符",slug:"位操作符",normalizedTitle:"位操作符",charIndex:570},{level:4,title:"按位非（NOT）",slug:"按位非-not",normalizedTitle:"按位非（not）",charIndex:1047},{level:4,title:"按位与（AND）",slug:"按位与-and",normalizedTitle:"按位与（and）",charIndex:1186},{level:4,title:"按位或（OR）",slug:"按位或-or",normalizedTitle:"按位或（or）",charIndex:1349},{level:4,title:"按位异或（XOR）",slug:"按位异或-xor",normalizedTitle:"按位异或（xor）",charIndex:1512},{level:4,title:"左移（Shift Left）",slug:"左移-shift-left",normalizedTitle:"左移（shift left）",charIndex:1677},{level:4,title:"有符号右移（Shift Right）",slug:"有符号右移-shift-right",normalizedTitle:"有符号右移（shift right）",charIndex:1817},{level:4,title:"无符号右移（Shift Right Unsigned）",slug:"无符号右移-shift-right-unsigned",normalizedTitle:"无符号右移（shift right unsigned）",charIndex:1994},{level:3,title:"布尔操作符",slug:"布尔操作符",normalizedTitle:"布尔操作符",charIndex:2185},{level:4,title:"逻辑非（NOT）",slug:"逻辑非-not",normalizedTitle:"逻辑非（not）",charIndex:2194},{level:4,title:"逻辑与（AND）",slug:"逻辑与-and",normalizedTitle:"逻辑与（and）",charIndex:2290},{level:4,title:"逻辑或（OR）",slug:"逻辑或-or",normalizedTitle:"逻辑或（or）",charIndex:2461},{level:3,title:"乘性操作符",slug:"乘性操作符",normalizedTitle:"乘性操作符",charIndex:2633},{level:4,title:"乘法（Multiplication）",slug:"乘法-multiplication",normalizedTitle:"乘法（multiplication）",charIndex:2642},{level:4,title:"除法（Division）",slug:"除法-division",normalizedTitle:"除法（division）",charIndex:2780},{level:4,title:"求模（Modulus）",slug:"求模-modulus",normalizedTitle:"求模（modulus）",charIndex:2929},{level:3,title:"指数操作符",slug:"指数操作符",normalizedTitle:"指数操作符",charIndex:3061},{level:4,title:"指数（Exponentiation）",slug:"指数-exponentiation",normalizedTitle:"指数（exponentiation）",charIndex:3070},{level:2,title:"语句",slug:"语句",normalizedTitle:"语句",charIndex:3219},{level:3,title:"do-while 语句",slug:"do-while-语句",normalizedTitle:"do-while 语句",charIndex:3226},{level:3,title:"for-in 语句",slug:"for-in-语句",normalizedTitle:"for-in 语句",charIndex:3410},{level:3,title:"for-of 语句",slug:"for-of-语句",normalizedTitle:"for-of 语句",charIndex:3595},{level:3,title:"for-await-of 语句",slug:"for-await-of-语句",normalizedTitle:"for-await-of 语句",charIndex:3850},{level:3,title:"标签语句",slug:"标签语句",normalizedTitle:"标签语句",charIndex:4147},{level:3,title:"with 语句",slug:"with-语句",normalizedTitle:"with 语句",charIndex:4748},{level:3,title:"switch 语句",slug:"switch-语句",normalizedTitle:"switch 语句",charIndex:5357}],headersStr:"操作符 一元操作符 递增与递减 一元 加减 位操作符 按位非（NOT） 按位与（AND） 按位或（OR） 按位异或（XOR） 左移（Shift Left） 有符号右移（Shift Right） 无符号右移（Shift Right Unsigned） 布尔操作符 逻辑非（NOT） 逻辑与（AND） 逻辑或（OR） 乘性操作符 乘法（Multiplication） 除法（Division） 求模（Modulus） 指数操作符 指数（Exponentiation） 语句 do-while 语句 for-in 语句 for-of 语句 for-await-of 语句 标签语句 with 语句 switch 语句",content:'# 操作符\n\n\n# 一元操作符\n\n# 递增与递减\n\n++ 和 -- 放在变量前面时符合直接，返回值为对应运算后的结果，放在变量后面时，会先返回运算前的结果，再进行对应的运算。\n\nlet num1 = 2\nlet num2 = 20\nlet num3 = num1++ + num2\nlet num4 = num1 + num2\nconsole.log(num3) // 22\nconsole.log(num4) // 23\n\n\n1\n2\n3\n4\n5\n6\n\n * 规则\n   * 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。\n   * 对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成 数值。\n   * 对于布尔值，如果是false，则转换为0 再应用改变。变量类型从布尔值变成数值。\n   * 对于布尔值，如果是true，则转换为1 再应用改变。变量类型从布尔值变成数值。\n   * 对于浮点值，加1 或减1。\n   * 如果是对象，则调用其valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是NaN，则调用toString()并再次应用其他规则。变量类型从对象变成数值。\n\n# 一元 加减\n\n主要用于基本的算术，也可以进行数据类型转换\n\n\n# 位操作符\n\njs中的位运算\n\n笔记\n\nECMAScript中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为64 位。对开发者而言，就好像只有32 位整数一样，因为64 位整数存储格式是不可见的。既然知道了这些，就只需要考虑32 位整数即可。\n\n有符号整数使用32 位的前31 位表示整数值。第32 位表示数值的符号，如0 表示正，1 表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式。\n\n负数使用补码进行存储，方便直接和正数进行加法计算。\n\n补码计算方式，原码取反加一\n\n注意\n\n在对ECMAScript 中的数值应用位操作符时，后台会发生转换：64 位数值会转换为32 位数值，然后执行位操作，最后再把结果从32 位转换为64 位存储起来。整个过程就像处理32 位数值一样，这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，即特殊值NaN 和Infinity在位操作中都会被当成0 处理。\n\n# 按位非（NOT）\n\n按位非操作符由一个波浪线（~）表示，执行操作数的二进制表示的按位非。简单说，就是将操作数的二进制表示中的所有位都取反。\n\nlet num1 = 25\nlet num2 = ~num1\nconsole.log(num2) // -26\n\n\n1\n2\n3\n\n\n# 按位与（AND）\n\n按位与操作符由和号（&）表示，它将两个数的二进制形式对齐，然后进行逐位比较。如果两个相应的位都为1，则该位的结果为1，否则为0。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 & num2\nconsole.log(num3) // 1\n\n\n1\n2\n3\n4\n\n\n# 按位或（OR）\n\n按位或操作符由符号（|）表示，它将两个数的二进制形式对齐，然后进行逐位比较。如果两个相应的位都为0，则该位的结果为0，否则为1。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 | num2\nconsole.log(num3) // 27\n\n\n1\n2\n3\n4\n\n\n# 按位异或（XOR）\n\n按位异或操作符由符号（^）表示，它将两个数的二进制形式对齐，然后进行逐位比较。如果两个相应的位不同，则该位的结果为1，否则为0。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 ^ num2\nconsole.log(num3) // 26\n\n\n1\n2\n3\n4\n\n\n# 左移（Shift Left）\n\n左移操作符由两个小于号（<<）表示，它将数值的所有位向左移动指定的位数。左移时，右侧空出的位用0 填充。\n\nlet num1 = 2\nlet num2 = num1 << 5\nconsole.log(num2) // 64\n\n\n1\n2\n3\n\n\n# 有符号右移（Shift Right）\n\n有符号右移操作符由两个大于号（>>）表示，它将数值的所有位向右移动指定的位数。使用有符号右移时，会保留符号位（最左侧位）。如果该位为0，表示负数；如果该位为1，表示正数。\n\nlet num1 = 64\nlet num2 = num1 >> 5\nconsole.log(num2) // 2\n\n\n1\n2\n3\n\n\n# 无符号右移（Shift Right Unsigned）\n\n无符号右移操作符由三个大于号（>>>）表示，它将数值的所有位向右移动指定的位数。使用无符号右移时，会将符号位也一起移动，因此符号位的值变为0，结果总是非负的。\n\nlet num1 = -64\nlet num2 = num1 >>> 5\nconsole.log(num2) // 134217726\n\n\n1\n2\n3\n\n\n\n# 布尔操作符\n\n# 逻辑非（NOT）\n\n逻辑非操作符由一个叹号（!）表示，它将操作数转换为布尔值，然后取反。\n\nlet num = 25\nconsole.log(!num) // false\n\n\n1\n2\n\n\n# 逻辑与（AND）\n\n逻辑与操作符由两个和号（&&）表示，它将两个操作数都转换为布尔值，然后返回第一个操作数的值（如果该值为假）或第二个操作数的值（如果该值为真）。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 && num2\nconsole.log(num3) // 3\n\n\n1\n2\n3\n4\n\n\n# 逻辑或（OR）\n\n逻辑或操作符由两个竖线（||）表示，它将两个操作数都转换为布尔值，然后返回第一个操作数的值（如果该值为真）或第二个操作数的值（如果该值为假）。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 || num2\nconsole.log(num3) // 25\n\n\n1\n2\n3\n4\n\n\n\n# 乘性操作符\n\n# 乘法（Multiplication）\n\n乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 * num2\nconsole.log(num3) // 75\n\n\n1\n2\n3\n4\n\n\n# 除法（Division）\n\n除法操作符由一个斜线（/）表示，用于计算两个数值的商。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 / num2\n\nconsole.log(num3) // 8.333333333333334\n\n\n1\n2\n3\n4\n5\n\n\n# 求模（Modulus）\n\n求模操作符由一个百分号（%）表示，用于计算两个数值的余数。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 % num2\nconsole.log(num3) // 2\n\n\n1\n2\n3\n4\n\n\n\n# 指数操作符\n\n# 指数（Exponentiation）\n\n指数操作符由两个星号（**）表示，用于计算一个数的指数值。\n\nlet num1 = 2\nlet num2 = num1 ** 5\nconsole.log(num2) // 32\n\n\n1\n2\n3\n\n\nES7新增 ** 操作符，代替Math.pow()\n\n\n# 语句\n\n\n# do-while 语句\n\ndo-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。do-while 的语法如下：\n\ndo {\nstatement\n} while (expression);\n\n\n1\n2\n3\n\n\n提示\n\ndo-while循环是后测试循环，while和for循环是先测试循环\n\n\n# for-in 语句\n\nfor-in 语句是一种精准的迭代语句，用于枚举对象中的非符号键属性，语法如下：\n\nfor (property in expression) statement\n\n\n1\n\n\n提示\n\nfor-in循环用于遍历对象的可枚举属性，包括对象自身的属性和继承的属性。如果需要遍历对象自身的属性，可以使用hasOwnProperty()方法进行过滤。\n\n\n# for-of 语句\n\nfor-of 语句是一种迭代语句，用于遍历可迭代对象（如数组、字符串、Map、Set等）中的元素，语法如下：\n\nfor (variable of iterable) statement\n\n\n1\n\n\n提示\n\nfor-of循环用于遍历可迭代对象中的元素，包括数组、字符串、Map、Set等。如果需要遍历对象的可枚举属性，可以使用Object.keys()、Object.values()、Object.entries()等方法获取对象的可枚举属性，然后使用for-of循环进行遍历。\n\n\n# for-await-of 语句\n\nfor-await-of 语句是一种迭代语句，用于遍历异步可迭代对象（如异步迭代器、Promise等）中的元素，语法如下：\n\nfor await (variable of iterable) statement\n\n\n1\n\n\n提示\n\nfor-await-of循环用于遍历异步可迭代对象中的元素，包括异步迭代器、Promise等。如果需要遍历异步可迭代对象的可枚举属性，可以使用Object.keys()、Object.values()、Object.entries()等方法获取异步可迭代对象的可枚举属性，然后使用for-await-of循环进行遍历。\n\n\n# 标签语句\n\n标签语句用于给语句加标签，语法如下：\n\nlabel: statement 下面是一个例子：\n\nstart: for (let i = 0; i < count; i++) {\nconsole.log(i);\n}\n\n\n1\n2\n3\n\n\n在这个例子中，start 是一个标签，可以在后面通过break 或continue 语句引用。标签语句的典型应用场景是嵌套循环。\n\nlet num = 0;\noutermost:\nfor (let i = 0; i < 10; i++) {\nfor (let j = 0; j < 10; j++) {\nif (i == 5 && j == 5) {\nbreak outermost;\n}\nnum++;\n}\n}\nconsole.log(num); // 55\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nlet num = 0;\noutermost: for (let i = 0; i < 10; i++) {\n  for (let j = 0; j < 10; j++) {\n    if (i == 5 && j == 5) {\n      continue outermost;\n    }\n    num++;\n  }\n}\n\nconsole.log(num); // 95\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# with 语句\n\nwith 语句的用途是将代码作用域设置为特定的对象，其语法是：\n\nwith (expression) statement;\n\n\n1\n\n\n使用with 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利，如下面的例子所示：\n\nlet qs = location.search.substring(1);\nlet hostName = location.hostname;\nlet url = location.href;\n\n\n1\n2\n3\n\n\n上面代码中的每一行都用到了location 对象。如果使用with 语句，就可以少写一些代码：\n\nwith(location) {\n  let qs = search.substring(1);\n  let hostName = hostname;\n  let url = href;\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里，with 语句用于连接location 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索location 对象，看它是否有一个同名的属性。如果有，则该变量会被求值为location 对象的属性。\n\n严格模式不允许使用with 语句，否则会抛出错误。\n\n提示\n\n由于with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用with语句。\n\n\n# switch 语句\n\n能够在条件判断中使用表达式，就可以在判断中加入更多逻辑：\n\nlet num = 25;\nswitch (true) {\n  case num < 0:\n    console.log("Less than 0.");\n    break;\n  case num >= 0 && num <= 10:\n    console.log("Between 0 and 10.");\n    break;\n  case num > 10 && num <= 20:\n    console.log("Between 10 and 20.");\n    break;\n  default:\n    console.log("More than 20.");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\nswitch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类 型（比如，字符串"10"不等于数值10）\n\n',normalizedContent:'# 操作符\n\n\n# 一元操作符\n\n# 递增与递减\n\n++ 和 -- 放在变量前面时符合直接，返回值为对应运算后的结果，放在变量后面时，会先返回运算前的结果，再进行对应的运算。\n\nlet num1 = 2\nlet num2 = 20\nlet num3 = num1++ + num2\nlet num4 = num1 + num2\nconsole.log(num3) // 22\nconsole.log(num4) // 23\n\n\n1\n2\n3\n4\n5\n6\n\n * 规则\n   * 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。\n   * 对于字符串，如果不是有效的数值形式，则将变量的值设置为 nan 。变量类型从字符串变成 数值。\n   * 对于布尔值，如果是false，则转换为0 再应用改变。变量类型从布尔值变成数值。\n   * 对于布尔值，如果是true，则转换为1 再应用改变。变量类型从布尔值变成数值。\n   * 对于浮点值，加1 或减1。\n   * 如果是对象，则调用其valueof()方法取得可以操作的值。对得到的值应用上述规则。如果是nan，则调用tostring()并再次应用其他规则。变量类型从对象变成数值。\n\n# 一元 加减\n\n主要用于基本的算术，也可以进行数据类型转换\n\n\n# 位操作符\n\njs中的位运算\n\n笔记\n\necmascript中的所有数值都以 ieee 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为64 位。对开发者而言，就好像只有32 位整数一样，因为64 位整数存储格式是不可见的。既然知道了这些，就只需要考虑32 位整数即可。\n\n有符号整数使用32 位的前31 位表示整数值。第32 位表示数值的符号，如0 表示正，1 表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式。\n\n负数使用补码进行存储，方便直接和正数进行加法计算。\n\n补码计算方式，原码取反加一\n\n注意\n\n在对ecmascript 中的数值应用位操作符时，后台会发生转换：64 位数值会转换为32 位数值，然后执行位操作，最后再把结果从32 位转换为64 位存储起来。整个过程就像处理32 位数值一样，这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，即特殊值nan 和infinity在位操作中都会被当成0 处理。\n\n# 按位非（not）\n\n按位非操作符由一个波浪线（~）表示，执行操作数的二进制表示的按位非。简单说，就是将操作数的二进制表示中的所有位都取反。\n\nlet num1 = 25\nlet num2 = ~num1\nconsole.log(num2) // -26\n\n\n1\n2\n3\n\n\n# 按位与（and）\n\n按位与操作符由和号（&）表示，它将两个数的二进制形式对齐，然后进行逐位比较。如果两个相应的位都为1，则该位的结果为1，否则为0。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 & num2\nconsole.log(num3) // 1\n\n\n1\n2\n3\n4\n\n\n# 按位或（or）\n\n按位或操作符由符号（|）表示，它将两个数的二进制形式对齐，然后进行逐位比较。如果两个相应的位都为0，则该位的结果为0，否则为1。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 | num2\nconsole.log(num3) // 27\n\n\n1\n2\n3\n4\n\n\n# 按位异或（xor）\n\n按位异或操作符由符号（^）表示，它将两个数的二进制形式对齐，然后进行逐位比较。如果两个相应的位不同，则该位的结果为1，否则为0。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 ^ num2\nconsole.log(num3) // 26\n\n\n1\n2\n3\n4\n\n\n# 左移（shift left）\n\n左移操作符由两个小于号（<<）表示，它将数值的所有位向左移动指定的位数。左移时，右侧空出的位用0 填充。\n\nlet num1 = 2\nlet num2 = num1 << 5\nconsole.log(num2) // 64\n\n\n1\n2\n3\n\n\n# 有符号右移（shift right）\n\n有符号右移操作符由两个大于号（>>）表示，它将数值的所有位向右移动指定的位数。使用有符号右移时，会保留符号位（最左侧位）。如果该位为0，表示负数；如果该位为1，表示正数。\n\nlet num1 = 64\nlet num2 = num1 >> 5\nconsole.log(num2) // 2\n\n\n1\n2\n3\n\n\n# 无符号右移（shift right unsigned）\n\n无符号右移操作符由三个大于号（>>>）表示，它将数值的所有位向右移动指定的位数。使用无符号右移时，会将符号位也一起移动，因此符号位的值变为0，结果总是非负的。\n\nlet num1 = -64\nlet num2 = num1 >>> 5\nconsole.log(num2) // 134217726\n\n\n1\n2\n3\n\n\n\n# 布尔操作符\n\n# 逻辑非（not）\n\n逻辑非操作符由一个叹号（!）表示，它将操作数转换为布尔值，然后取反。\n\nlet num = 25\nconsole.log(!num) // false\n\n\n1\n2\n\n\n# 逻辑与（and）\n\n逻辑与操作符由两个和号（&&）表示，它将两个操作数都转换为布尔值，然后返回第一个操作数的值（如果该值为假）或第二个操作数的值（如果该值为真）。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 && num2\nconsole.log(num3) // 3\n\n\n1\n2\n3\n4\n\n\n# 逻辑或（or）\n\n逻辑或操作符由两个竖线（||）表示，它将两个操作数都转换为布尔值，然后返回第一个操作数的值（如果该值为真）或第二个操作数的值（如果该值为假）。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 || num2\nconsole.log(num3) // 25\n\n\n1\n2\n3\n4\n\n\n\n# 乘性操作符\n\n# 乘法（multiplication）\n\n乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 * num2\nconsole.log(num3) // 75\n\n\n1\n2\n3\n4\n\n\n# 除法（division）\n\n除法操作符由一个斜线（/）表示，用于计算两个数值的商。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 / num2\n\nconsole.log(num3) // 8.333333333333334\n\n\n1\n2\n3\n4\n5\n\n\n# 求模（modulus）\n\n求模操作符由一个百分号（%）表示，用于计算两个数值的余数。\n\nlet num1 = 25\nlet num2 = 3\nlet num3 = num1 % num2\nconsole.log(num3) // 2\n\n\n1\n2\n3\n4\n\n\n\n# 指数操作符\n\n# 指数（exponentiation）\n\n指数操作符由两个星号（**）表示，用于计算一个数的指数值。\n\nlet num1 = 2\nlet num2 = num1 ** 5\nconsole.log(num2) // 32\n\n\n1\n2\n3\n\n\nes7新增 ** 操作符，代替math.pow()\n\n\n# 语句\n\n\n# do-while 语句\n\ndo-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。do-while 的语法如下：\n\ndo {\nstatement\n} while (expression);\n\n\n1\n2\n3\n\n\n提示\n\ndo-while循环是后测试循环，while和for循环是先测试循环\n\n\n# for-in 语句\n\nfor-in 语句是一种精准的迭代语句，用于枚举对象中的非符号键属性，语法如下：\n\nfor (property in expression) statement\n\n\n1\n\n\n提示\n\nfor-in循环用于遍历对象的可枚举属性，包括对象自身的属性和继承的属性。如果需要遍历对象自身的属性，可以使用hasownproperty()方法进行过滤。\n\n\n# for-of 语句\n\nfor-of 语句是一种迭代语句，用于遍历可迭代对象（如数组、字符串、map、set等）中的元素，语法如下：\n\nfor (variable of iterable) statement\n\n\n1\n\n\n提示\n\nfor-of循环用于遍历可迭代对象中的元素，包括数组、字符串、map、set等。如果需要遍历对象的可枚举属性，可以使用object.keys()、object.values()、object.entries()等方法获取对象的可枚举属性，然后使用for-of循环进行遍历。\n\n\n# for-await-of 语句\n\nfor-await-of 语句是一种迭代语句，用于遍历异步可迭代对象（如异步迭代器、promise等）中的元素，语法如下：\n\nfor await (variable of iterable) statement\n\n\n1\n\n\n提示\n\nfor-await-of循环用于遍历异步可迭代对象中的元素，包括异步迭代器、promise等。如果需要遍历异步可迭代对象的可枚举属性，可以使用object.keys()、object.values()、object.entries()等方法获取异步可迭代对象的可枚举属性，然后使用for-await-of循环进行遍历。\n\n\n# 标签语句\n\n标签语句用于给语句加标签，语法如下：\n\nlabel: statement 下面是一个例子：\n\nstart: for (let i = 0; i < count; i++) {\nconsole.log(i);\n}\n\n\n1\n2\n3\n\n\n在这个例子中，start 是一个标签，可以在后面通过break 或continue 语句引用。标签语句的典型应用场景是嵌套循环。\n\nlet num = 0;\noutermost:\nfor (let i = 0; i < 10; i++) {\nfor (let j = 0; j < 10; j++) {\nif (i == 5 && j == 5) {\nbreak outermost;\n}\nnum++;\n}\n}\nconsole.log(num); // 55\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nlet num = 0;\noutermost: for (let i = 0; i < 10; i++) {\n  for (let j = 0; j < 10; j++) {\n    if (i == 5 && j == 5) {\n      continue outermost;\n    }\n    num++;\n  }\n}\n\nconsole.log(num); // 95\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# with 语句\n\nwith 语句的用途是将代码作用域设置为特定的对象，其语法是：\n\nwith (expression) statement;\n\n\n1\n\n\n使用with 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利，如下面的例子所示：\n\nlet qs = location.search.substring(1);\nlet hostname = location.hostname;\nlet url = location.href;\n\n\n1\n2\n3\n\n\n上面代码中的每一行都用到了location 对象。如果使用with 语句，就可以少写一些代码：\n\nwith(location) {\n  let qs = search.substring(1);\n  let hostname = hostname;\n  let url = href;\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里，with 语句用于连接location 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索location 对象，看它是否有一个同名的属性。如果有，则该变量会被求值为location 对象的属性。\n\n严格模式不允许使用with 语句，否则会抛出错误。\n\n提示\n\n由于with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用with语句。\n\n\n# switch 语句\n\n能够在条件判断中使用表达式，就可以在判断中加入更多逻辑：\n\nlet num = 25;\nswitch (true) {\n  case num < 0:\n    console.log("less than 0.");\n    break;\n  case num >= 0 && num <= 10:\n    console.log("between 0 and 10.");\n    break;\n  case num > 10 && num <= 20:\n    console.log("between 10 and 20.");\n    break;\n  default:\n    console.log("more than 20.");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\nswitch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类 型（比如，字符串"10"不等于数值10）\n\n',charsets:{cjk:!0},lastUpdated:"2024/08/24, 00:05:47",lastUpdatedTimestamp:1724429147e3},{title:"基本引用类型",frontmatter:{title:"基本引用类型",date:"2024-08-25T00:07:06.000Z",permalink:"/pages/58a981/",categories:["前端","JavaScript高级程序设计"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/07.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html",relativePath:"01.前端/03.JavaScript高级程序设计/07.基本引用类型.md",key:"v-766e8bf2",path:"/pages/58a981/",headers:[{level:2,title:"Date",slug:"date",normalizedTitle:"date",charIndex:259},{level:3,title:"Date.UTC() 和 Date.parse()",slug:"date-utc-和-date-parse",normalizedTitle:"date.utc() 和 date.parse()",charIndex:268},{level:2,title:"RegExp",slug:"regexp",normalizedTitle:"regexp",charIndex:590},{level:3,title:"表示匹配模式的标记",slug:"表示匹配模式的标记",normalizedTitle:"表示匹配模式的标记",charIndex:759},{level:3,title:"RegExp 实例属性",slug:"regexp-实例属性",normalizedTitle:"regexp 实例属性",charIndex:997},{level:3,title:"RegExp 实例方法",slug:"regexp-实例方法",normalizedTitle:"regexp 实例方法",charIndex:1960},{level:3,title:"RegExp 构造函数属性",slug:"regexp-构造函数属性",normalizedTitle:"regexp 构造函数属性",charIndex:4109},{level:3,title:"模式局限",slug:"模式局限",normalizedTitle:"模式局限",charIndex:5344},{level:2,title:"原始值包装类型",slug:"原始值包装类型",normalizedTitle:"原始值包装类型",charIndex:5605},{level:3,title:"String",slug:"string",normalizedTitle:"string",charIndex:539},{level:3,title:"normalize() 方法",slug:"normalize-方法",normalizedTitle:"normalize() 方法",charIndex:5966},{level:3,title:"字符串迭代与解构",slug:"字符串迭代与解构",normalizedTitle:"字符串迭代与解构",charIndex:8223},{level:3,title:"字符串模式匹配方法",slug:"字符串模式匹配方法",normalizedTitle:"字符串模式匹配方法",charIndex:8766},{level:3,title:"localeCompare 方法",slug:"localecompare-方法",normalizedTitle:"localecompare 方法",charIndex:10398},{level:2,title:"单例内置对象",slug:"单例内置对象",normalizedTitle:"单例内置对象",charIndex:10546},{level:3,title:"Global 对象",slug:"global-对象",normalizedTitle:"global 对象",charIndex:10557},{level:4,title:"URL 编码方法",slug:"url-编码方法",normalizedTitle:"url 编码方法",charIndex:10812},{level:4,title:"eval",slug:"eval",normalizedTitle:"eval",charIndex:11283}],headersStr:"Date Date.UTC() 和 Date.parse() RegExp 表示匹配模式的标记 RegExp 实例属性 RegExp 实例方法 RegExp 构造函数属性 模式局限 原始值包装类型 String normalize() 方法 字符串迭代与解构 字符串模式匹配方法 localeCompare 方法 单例内置对象 Global 对象 URL 编码方法 eval",content:'笔记\n\n引用类型与类是不等同的概念。\n\n引用值（或者对象）是某个特定引用类型的实例。在ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。\n\n引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆，本章后面不会使用术语“类”。\n\n函数也是一种引用类型。\n\n\n# Date\n\n\n# Date.UTC() 和 Date.parse()\n\nDate.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。\n\nDate.UTC 方法返回自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。这个方法接受年、月、日、小时、分钟、秒和毫秒作为参数，并返回一个表示该日期和时间的毫秒数。\n\nECMAScript 还提供了Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中。\n\n提示\n\nDate 引用类型的 toLocaleString() toString() ValueOf()在不同的浏览器表现不同，需要注意。\n\n\n# RegExp\n\n正则表达式使用类似 Perl 的简洁语法进行创建\n\nlet expression = /pattern/flags\n\n这个正则表达式的pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个flags（标记），用于控制正则表达式的行为。\n\n\n# 表示匹配模式的标记\n\n * g：全局模式，表示查找字符串的全部内容，而不是在找到第一个匹配项时停止。\n * i：不区分大小写，表示在查找匹配项时忽略pattern和字符串的大小写。\n * m：多行模式，表示查找到一行文本末尾时会继续查找下一行。\n * y: 粘附模式，表示只查找从 lastIndex 开始及之后的字符串\n * u: Unicode 模式，表示使用 Unicode 来匹配字符\n * s: dotAll 模式，表示元字符.匹配任何字符，包括\\n和\\r\n\n\n# RegExp 实例属性\n\n每个RegExp 实例都有下列属性，提供有关模式的各方面信息。\n\n * global：布尔值，表示是否设置了g 标记。\n * ignoreCase：布尔值，表示是否设置了i 标记。\n * unicode：布尔值，表示是否设置了u 标记。\n * sticky：布尔值，表示是否设置了y 标记。\n * lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从0 开始。\n * multiline：布尔值，表示是否设置了m 标记。\n * dotAll：布尔值，表示是否设置了s 标记。\n * source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。\n * flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。\n\nlet pattern1 = /\\[bc\\]at/i;\nconsole.log(pattern1.global); // false\nconsole.log(pattern1.ignoreCase); // true\nconsole.log(pattern1.multiline); // false\nconsole.log(pattern1.lastIndex); // 0\nconsole.log(pattern1.source); // "\\[bc\\]at"\nconsole.log(pattern1.flags); // "i"\nlet pattern2 = new RegExp("\\\\[bc\\\\]at", "i");\nconsole.log(pattern2.global); // false\nconsole.log(pattern2.ignoreCase); // true\nconsole.log(pattern2.multiline); // false\nconsole.log(pattern2.lastIndex); // 0\nconsole.log(pattern2.source); // "\\[bc\\]at"\nconsole.log(pattern2.flags); // "i"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# RegExp 实例方法\n\nRegExp 实例的主要方法是exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。\n\n如果模式中没有捕获组，则数组只包含一个元素\n\nlet text = "mom and dad and baby";\nlet pattern = /mom( and dad( and baby)?)?/gi;\nlet matches = pattern.exec(text);\nconsole.log(matches.index); // 0\nconsole.log(matches.input); // "mom and dad and baby"\nconsole.log(matches[0]); // "mom and dad and baby"\nconsole.log(matches[1]); // " and dad and baby"\nconsole.log(matches[2]); // " and baby"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在这个例子中，模式包含两个捕获组：最内部的匹配项" and baby"，以及外部的匹配项" and dad"或" and dad and baby"。调用exec()后找到了一个匹配项。因为整个字符串匹配模式，所以matchs数组的index 属性就是0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。\n\n如果模式设置了全局标记，则每次调用exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次exec()，也只会返回第一个匹配的信息。\n\nlet text = "cat, bat, sat, fat";\nlet pattern = /.at/;\nlet matches = pattern.exec(text);\nconsole.log(matches.index); // 0\nconsole.log(matches[0]); // cat\nconsole.log(pattern.lastIndex); // 0\nmatches = pattern.exec(text);\nconsole.log(matches.index); // 0\nconsole.log(matches[0]); // cat\nconsole.log(pattern.lastIndex); // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这次模式设置了全局标记，因此每次调用exec()都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的lastIndex 属性每次都会变化。在全局匹配模式下，每次调用exec()都会更新lastIndex 值，以反映上次匹配的最后一个字符的索引。\n\n如果模式设置了粘附标记y，则每次调用exec()就只会在lastIndex 的位置上寻找匹配项。粘附标记覆盖全局标记。\n\nlet text = "cat, bat, sat, fat";\nlet pattern = /.at/y;\nlet matches = pattern.exec(text);\nconsole.log(matches.index); // 0\nconsole.log(matches[0]); // cat\nconsole.log(pattern.lastIndex); // 3\n// 以索引3 对应的字符开头找不到匹配项，因此exec()返回null\n// exec()没找到匹配项，于是将lastIndex 设置为0\nmatches = pattern.exec(text);\nconsole.log(matches); // null\nconsole.log(pattern.lastIndex); // 0\n// 向前设置lastIndex 可以让粘附的模式通过exec()找到下一个匹配项：\npattern.lastIndex = 5;\nmatches = pattern.exec(text);\nconsole.log(matches.index); // 5\nconsole.log(matches[0]); // bat\nconsole.log(pattern.lastIndex); // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n正则表达式的另一个方法是test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数 返回true，否则返回false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。 test()经常用在if 语句中。\n\n\n# RegExp 构造函数属性\n\nRegExp 构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了 RegExp 构造函数的属性。\n\n * input $_ 最后搜索的字符串\n * lastMatch $& 最后匹配的文本\n * lastParen $+ 最后匹配的捕获组\n * leftContext $` input 字符串中 lastMatch 之前的文本\n * rightContext $\' input 字符串中 lastMatch 之后的文本\n\nlet text = "this has been a short summer";\nlet pattern = /(.)hort/g;\nif (pattern.test(text)) {\n  console.log(RegExp.input); // this has been a short summer\n  console.log(RegExp.leftContext); // this has been a\n  console.log(RegExp.rightContext); // summer\n  console.log(RegExp.lastMatch); // short\n  console.log(RegExp.lastParen); // s\n  console.log(RegExp.$_); // this has been a short summer\n  console.log(RegExp["$`"]); // this has been a\n  console.log(RegExp["$\'"]); // summer\n  console.log(RegExp["$&"]); // short\n  console.log(RegExp["$+"]); // s\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nRegExp 还有其他几个构造函数属性，可以存储最多9 个捕获组的匹配项。这些属性通过RegExp.$1~RegExp.$9 来访问，分别包含第1~9 个捕获组的匹配项。在调用exec()或test()时，这些属性就会被填充，然后就可以像下面这样使用它们：\n\nlet text = "this has been a short summer";\nlet pattern = /(..)or(.)/g;\nif (pattern.test(text)) {\n  console.log(RegExp.$1); // sh\n  console.log(RegExp.$2); // t\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 模式局限\n\n笔记\n\n虽然ECMAScript 对正则表达式的支持有了长足的进步，但仍然缺少Perl 语言中的一些高级特性。下列特性目前还没有得到ECMAScript 的支持（想要了解更多信息，可以参考Regular-Expressions.info网站）\n\n * \\A 和\\Z 锚（分别匹配字符串的开始和末尾）\n * 联合及交叉类\n * 原子组\n * x（忽略空格）匹配模式\n * 条件式匹配\n * 正则表达式注释 虽然还有这些局限，但ECMAScript 的正则表达式已经非常强大，可以用于大多数模式匹配任务。\n\n\n# 原始值包装类型\n\n\n# String\n\n对于U+0000~U+FFFF 范围内的字符，length、charAt()、charCodeAt()和fromCharCode()返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用16 位表示的，而这几个方法也都基于16 位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。\n\n这个对应关系在扩展到Unicode 增补字符平面时就不成立了。问题很简单，即16 位只能唯一表示65 536 个字符。这对于大多数语言字符集是足够了，在Unicode 中称为基本多语言平面（BMP）。**为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外16 位去选择一个增补平面。**这种每个字符使用两个16 位码元的策略称为代理对。\n\n\n# normalize() 方法\n\n某些Unicode 字符可以有多种编码方式。有的字符既可以通过一个BMP 字符表示，也可以通过一个代理对表示。比如：\n\n// U+00C5：上面带圆圈的大写拉丁字母A\nconsole.log(String.fromCharCode(0x00C5)); // Å\n// U+212B：长度单位“埃”\nconsole.log(String.fromCharCode(0x212B)); // Å\n// U+004：大写拉丁字母A\n// U+030A：上面加个圆圈\nconsole.log(String.fromCharCode(0x0041, 0x030A)); // Å\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n比较操作符不在乎字符看起来是什么样的，因此这3 个字符互不相等。\n\nlet a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A);\nconsole.log(a1, a2, a3); // Å, Å, Å\nconsole.log(a1 === a2); // false\nconsole.log(a1 === a3); // false\nconsole.log(a2 === a3); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为解决这个问题，Unicode 提供了4 种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这4 种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和NFKC（Normalization Form KC）。可以使用normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串："NFD"、"NFC"、"NFKD"或"NFKC"。\n\n提示\n\n这4 种规范化形式的具体细节超出了本书范围，有兴趣的读者可以自行参考UAX15#: Unicode Normalization Forms 中的1.2 节“Normalization Forms”。\n\n通过比较字符串与其调用normalize()的返回值，就可以知道该字符串是否已经规范化了：\n\nlet a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A);\n// U+00C5 是对0+212B 进行NFC/NFKC 规范化之后的结果\nconsole.log(a1 === a1.normalize("NFD")); // false\nconsole.log(a1 === a1.normalize("NFC")); // true\nconsole.log(a1 === a1.normalize("NFKD")); // false\nconsole.log(a1 === a1.normalize("NFKC")); // true\n// U+212B 是未规范化的\nconsole.log(a2 === a2.normalize("NFD")); // false\nconsole.log(a2 === a2.normalize("NFC")); // false\nconsole.log(a2 === a2.normalize("NFKD")); // false\nconsole.log(a2 === a2.normalize("NFKC")); // false\n// U+0041/U+030A 是对0+212B 进行NFD/NFKD 规范化之后的结果\nconsole.log(a3 === a3.normalize("NFD")); // true\nconsole.log(a3 === a3.normalize("NFC")); // false\nconsole.log(a3 === a3.normalize("NFKD")); // true\nconsole.log(a3 === a3.normalize("NFKC")); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n选择同一种规范化形式可以让比较操作符返回正确的结果：\n\nlet a1 = String.fromCharCode(0x00C5),\na2 = String.fromCharCode(0x212B),\na3 = String.fromCharCode(0x0041, 0x030A);\nconsole.log(a1.normalize("NFD") === a2.normalize("NFD")); // true\nconsole.log(a2.normalize("NFKC") === a3.normalize("NFKC")); // true\nconsole.log(a1.normalize("NFC") === a3.normalize("NFC")); // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 字符串迭代与解构\n\n字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：\n\nlet message = "abc";\nlet stringIterator = message[Symbol.iterator]();\nconsole.log(stringIterator.next()); // {value: "a", done: false}\nconsole.log(stringIterator.next()); // {value: "b", done: false}\nconsole.log(stringIterator.next()); // {value: "c", done: false}\nconsole.log(stringIterator.next()); // {value: undefined, done: true}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在for-of 循环中可以通过这个迭代器按序访问每个字符：\n\nfor (const c of "abcde") {\nconsole.log(c);\n}\n// a\n// b\n// c\n// d\n// e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 字符串模式匹配方法\n\n为简化子字符串替换操作，ECMAScript 提供了replace()方法。这个方法接收两个参数，第一个参数可以是一个RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：\n\nlet text = "cat, bat, sat, fat";\nlet result = text.replace("at", "ond");\nconsole.log(result); // "cond, bat, sat, fat"\nresult = text.replace(/at/g, "ond");\nconsole.log(result); // "cond, bond, sond, fond"\n\n\n1\n2\n3\n4\n5\n\n\n字符序列 替换文本 $$😒 $&:匹配整个模式的子字符串。与RegExp.lastMatch 相同 $\':匹配的子字符串之前的字符串。与RegExp.rightContext 相同 $\\``:匹配的子字符串之后的字符串。与RegExp.leftContext 相同$n:匹配第n 个捕获组的字符串，其中n 是0~9。比如，$1 是匹配第一个捕获组的字符串，$2 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串$nn`:匹配第nn 个捕获组字符串，其中nn 是01~99。比如，$01 是匹配第一个捕获组的字符串，$02 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串\n\n使用这些特殊的序列，可以在替换文本中使用之前匹配的内容，如下面的例子所示：\n\nlet text = "cat, bat, sat, fat";\nresult = text.replace(/(.at)/g, "word ($1)");\nconsole.log(result); // word (cat), word (bat), word (sat), word (fat)\n\n\n1\n2\n3\n\n\n这里，每个以"at"结尾的词都会被替换成"word"后跟一对小括号，其中包含捕获组匹配的内容$1。replace()的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数可以更细致地控制替换过程，如下所示：\n\nfunction htmlEscape(text) {\n  return text.replace(/[<>"&]/g, function(match, pos, originalText) {\n    switch(match) {\n      case "<":\n        return "&lt;";\n      case ">":\n        return "&gt;";\n      case "&":\n        return "&amp;";\n      case "\\"":\n        return "&quot;";\n    }\n  });\n}\nconsole.log(htmlEscape("<p class=\\"greeting\\">Hello world!</p>"));\n// "&lt;p class=&quot;greeting&quot;&gt;Hello world!</p>"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# localeCompare 方法\n\nlocaleCompare()的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是ECMAScript 实现的标准语言，localeCompare()区分大小写，大写字母排在小写字母前面。但其他地区未必是这种情况。\n\n\n# 单例内置对象\n\n\n# Global 对象\n\nGlobal 对象是ECMAScript 中最特别的对象，因为代码不会显式地访问它。ECMA-262 规定Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成Global 对象的属性 。本书前面介绍的函数，包括isNaN()、isFinite()、parseInt()和parseFloat()，实际上都是Global 对象的方法。除了这些，Global 对象上还有另外一些方法。\n\n# URL 编码方法\n\nencodeURI()和encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI 不能包含某些字符，比如空格。使用URI 编码方法来编码URI 可以让浏览器能够理解它们，同时又以特殊的UTF-8 编码替换掉所有无效字符。\n\n这两个方法的主要区别是，encodeURI()不会编码属于URL 组件的特殊字符，比如冒号、斜杠、问号、井号，而encodeURIComponent()会编码它发现的所有非标准字符。\n\n与encodeURI()和encodeURIComponent()相对的是decodeURI()和decodeURIComponent()。decodeURI()只对使用encodeURI()编码过的字符解码。例如，%20 会被替换为空格，但%23 不会被替换为井号（#），因为井号不是由encodeURI()替换的。类似地，decodeURIComponent()解码所有被encodeURIComponent()编码的字符，基本上就是解码所有特殊值。\n\n# eval\n\neval方法就是一个完整的ECMAScript 解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。\n\neval("console.log(\'hi\')");\n\n\n1\n\n\n等价\n\nconsole.log("hi");\n\n\n1\n\n\n注意\n\n注意 解释代码字符串的能力是非常强大的，但也非常危险。在使用eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对XSS 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。\n\n',normalizedContent:'笔记\n\n引用类型与类是不等同的概念。\n\n引用值（或者对象）是某个特定引用类型的实例。在ecmascript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲javascript 是一门面向对象语言，但ecmascript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。\n\n引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆，本章后面不会使用术语“类”。\n\n函数也是一种引用类型。\n\n\n# date\n\n\n# date.utc() 和 date.parse()\n\ndate.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。\n\ndate.utc 方法返回自 1970 年 1 月 1 日 00:00:00 utc（协调世界时）以来的毫秒数。这个方法接受年、月、日、小时、分钟、秒和毫秒作为参数，并返回一个表示该日期和时间的毫秒数。\n\necmascript 还提供了date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中。\n\n提示\n\ndate 引用类型的 tolocalestring() tostring() valueof()在不同的浏览器表现不同，需要注意。\n\n\n# regexp\n\n正则表达式使用类似 perl 的简洁语法进行创建\n\nlet expression = /pattern/flags\n\n这个正则表达式的pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个flags（标记），用于控制正则表达式的行为。\n\n\n# 表示匹配模式的标记\n\n * g：全局模式，表示查找字符串的全部内容，而不是在找到第一个匹配项时停止。\n * i：不区分大小写，表示在查找匹配项时忽略pattern和字符串的大小写。\n * m：多行模式，表示查找到一行文本末尾时会继续查找下一行。\n * y: 粘附模式，表示只查找从 lastindex 开始及之后的字符串\n * u: unicode 模式，表示使用 unicode 来匹配字符\n * s: dotall 模式，表示元字符.匹配任何字符，包括\\n和\\r\n\n\n# regexp 实例属性\n\n每个regexp 实例都有下列属性，提供有关模式的各方面信息。\n\n * global：布尔值，表示是否设置了g 标记。\n * ignorecase：布尔值，表示是否设置了i 标记。\n * unicode：布尔值，表示是否设置了u 标记。\n * sticky：布尔值，表示是否设置了y 标记。\n * lastindex：整数，表示在源字符串中下一次搜索的开始位置，始终从0 开始。\n * multiline：布尔值，表示是否设置了m 标记。\n * dotall：布尔值，表示是否设置了s 标记。\n * source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。\n * flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。\n\nlet pattern1 = /\\[bc\\]at/i;\nconsole.log(pattern1.global); // false\nconsole.log(pattern1.ignorecase); // true\nconsole.log(pattern1.multiline); // false\nconsole.log(pattern1.lastindex); // 0\nconsole.log(pattern1.source); // "\\[bc\\]at"\nconsole.log(pattern1.flags); // "i"\nlet pattern2 = new regexp("\\\\[bc\\\\]at", "i");\nconsole.log(pattern2.global); // false\nconsole.log(pattern2.ignorecase); // true\nconsole.log(pattern2.multiline); // false\nconsole.log(pattern2.lastindex); // 0\nconsole.log(pattern2.source); // "\\[bc\\]at"\nconsole.log(pattern2.flags); // "i"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# regexp 实例方法\n\nregexp 实例的主要方法是exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是array 的实例，但包含两个额外的属性：index 和input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。\n\n如果模式中没有捕获组，则数组只包含一个元素\n\nlet text = "mom and dad and baby";\nlet pattern = /mom( and dad( and baby)?)?/gi;\nlet matches = pattern.exec(text);\nconsole.log(matches.index); // 0\nconsole.log(matches.input); // "mom and dad and baby"\nconsole.log(matches[0]); // "mom and dad and baby"\nconsole.log(matches[1]); // " and dad and baby"\nconsole.log(matches[2]); // " and baby"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在这个例子中，模式包含两个捕获组：最内部的匹配项" and baby"，以及外部的匹配项" and dad"或" and dad and baby"。调用exec()后找到了一个匹配项。因为整个字符串匹配模式，所以matchs数组的index 属性就是0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。\n\n如果模式设置了全局标记，则每次调用exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次exec()，也只会返回第一个匹配的信息。\n\nlet text = "cat, bat, sat, fat";\nlet pattern = /.at/;\nlet matches = pattern.exec(text);\nconsole.log(matches.index); // 0\nconsole.log(matches[0]); // cat\nconsole.log(pattern.lastindex); // 0\nmatches = pattern.exec(text);\nconsole.log(matches.index); // 0\nconsole.log(matches[0]); // cat\nconsole.log(pattern.lastindex); // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这次模式设置了全局标记，因此每次调用exec()都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的lastindex 属性每次都会变化。在全局匹配模式下，每次调用exec()都会更新lastindex 值，以反映上次匹配的最后一个字符的索引。\n\n如果模式设置了粘附标记y，则每次调用exec()就只会在lastindex 的位置上寻找匹配项。粘附标记覆盖全局标记。\n\nlet text = "cat, bat, sat, fat";\nlet pattern = /.at/y;\nlet matches = pattern.exec(text);\nconsole.log(matches.index); // 0\nconsole.log(matches[0]); // cat\nconsole.log(pattern.lastindex); // 3\n// 以索引3 对应的字符开头找不到匹配项，因此exec()返回null\n// exec()没找到匹配项，于是将lastindex 设置为0\nmatches = pattern.exec(text);\nconsole.log(matches); // null\nconsole.log(pattern.lastindex); // 0\n// 向前设置lastindex 可以让粘附的模式通过exec()找到下一个匹配项：\npattern.lastindex = 5;\nmatches = pattern.exec(text);\nconsole.log(matches.index); // 5\nconsole.log(matches[0]); // bat\nconsole.log(pattern.lastindex); // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n正则表达式的另一个方法是test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数 返回true，否则返回false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。 test()经常用在if 语句中。\n\n\n# regexp 构造函数属性\n\nregexp 构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了 regexp 构造函数的属性。\n\n * input $_ 最后搜索的字符串\n * lastmatch $& 最后匹配的文本\n * lastparen $+ 最后匹配的捕获组\n * leftcontext $` input 字符串中 lastmatch 之前的文本\n * rightcontext $\' input 字符串中 lastmatch 之后的文本\n\nlet text = "this has been a short summer";\nlet pattern = /(.)hort/g;\nif (pattern.test(text)) {\n  console.log(regexp.input); // this has been a short summer\n  console.log(regexp.leftcontext); // this has been a\n  console.log(regexp.rightcontext); // summer\n  console.log(regexp.lastmatch); // short\n  console.log(regexp.lastparen); // s\n  console.log(regexp.$_); // this has been a short summer\n  console.log(regexp["$`"]); // this has been a\n  console.log(regexp["$\'"]); // summer\n  console.log(regexp["$&"]); // short\n  console.log(regexp["$+"]); // s\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nregexp 还有其他几个构造函数属性，可以存储最多9 个捕获组的匹配项。这些属性通过regexp.$1~regexp.$9 来访问，分别包含第1~9 个捕获组的匹配项。在调用exec()或test()时，这些属性就会被填充，然后就可以像下面这样使用它们：\n\nlet text = "this has been a short summer";\nlet pattern = /(..)or(.)/g;\nif (pattern.test(text)) {\n  console.log(regexp.$1); // sh\n  console.log(regexp.$2); // t\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 模式局限\n\n笔记\n\n虽然ecmascript 对正则表达式的支持有了长足的进步，但仍然缺少perl 语言中的一些高级特性。下列特性目前还没有得到ecmascript 的支持（想要了解更多信息，可以参考regular-expressions.info网站）\n\n * \\a 和\\z 锚（分别匹配字符串的开始和末尾）\n * 联合及交叉类\n * 原子组\n * x（忽略空格）匹配模式\n * 条件式匹配\n * 正则表达式注释 虽然还有这些局限，但ecmascript 的正则表达式已经非常强大，可以用于大多数模式匹配任务。\n\n\n# 原始值包装类型\n\n\n# string\n\n对于u+0000~u+ffff 范围内的字符，length、charat()、charcodeat()和fromcharcode()返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用16 位表示的，而这几个方法也都基于16 位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。\n\n这个对应关系在扩展到unicode 增补字符平面时就不成立了。问题很简单，即16 位只能唯一表示65 536 个字符。这对于大多数语言字符集是足够了，在unicode 中称为基本多语言平面（bmp）。**为了表示更多的字符，unicode 采用了一个策略，即每个字符使用另外16 位去选择一个增补平面。**这种每个字符使用两个16 位码元的策略称为代理对。\n\n\n# normalize() 方法\n\n某些unicode 字符可以有多种编码方式。有的字符既可以通过一个bmp 字符表示，也可以通过一个代理对表示。比如：\n\n// u+00c5：上面带圆圈的大写拉丁字母a\nconsole.log(string.fromcharcode(0x00c5)); // a\n// u+212b：长度单位“埃”\nconsole.log(string.fromcharcode(0x212b)); // a\n// u+004：大写拉丁字母a\n// u+030a：上面加个圆圈\nconsole.log(string.fromcharcode(0x0041, 0x030a)); // a\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n比较操作符不在乎字符看起来是什么样的，因此这3 个字符互不相等。\n\nlet a1 = string.fromcharcode(0x00c5),\na2 = string.fromcharcode(0x212b),\na3 = string.fromcharcode(0x0041, 0x030a);\nconsole.log(a1, a2, a3); // a, a, a\nconsole.log(a1 === a2); // false\nconsole.log(a1 === a3); // false\nconsole.log(a2 === a3); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为解决这个问题，unicode 提供了4 种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这4 种规范化形式是：nfd（normalization form d）、nfc（normalization form c）、nfkd（normalization form kd）和nfkc（normalization form kc）。可以使用normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串："nfd"、"nfc"、"nfkd"或"nfkc"。\n\n提示\n\n这4 种规范化形式的具体细节超出了本书范围，有兴趣的读者可以自行参考uax15#: unicode normalization forms 中的1.2 节“normalization forms”。\n\n通过比较字符串与其调用normalize()的返回值，就可以知道该字符串是否已经规范化了：\n\nlet a1 = string.fromcharcode(0x00c5),\na2 = string.fromcharcode(0x212b),\na3 = string.fromcharcode(0x0041, 0x030a);\n// u+00c5 是对0+212b 进行nfc/nfkc 规范化之后的结果\nconsole.log(a1 === a1.normalize("nfd")); // false\nconsole.log(a1 === a1.normalize("nfc")); // true\nconsole.log(a1 === a1.normalize("nfkd")); // false\nconsole.log(a1 === a1.normalize("nfkc")); // true\n// u+212b 是未规范化的\nconsole.log(a2 === a2.normalize("nfd")); // false\nconsole.log(a2 === a2.normalize("nfc")); // false\nconsole.log(a2 === a2.normalize("nfkd")); // false\nconsole.log(a2 === a2.normalize("nfkc")); // false\n// u+0041/u+030a 是对0+212b 进行nfd/nfkd 规范化之后的结果\nconsole.log(a3 === a3.normalize("nfd")); // true\nconsole.log(a3 === a3.normalize("nfc")); // false\nconsole.log(a3 === a3.normalize("nfkd")); // true\nconsole.log(a3 === a3.normalize("nfkc")); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n选择同一种规范化形式可以让比较操作符返回正确的结果：\n\nlet a1 = string.fromcharcode(0x00c5),\na2 = string.fromcharcode(0x212b),\na3 = string.fromcharcode(0x0041, 0x030a);\nconsole.log(a1.normalize("nfd") === a2.normalize("nfd")); // true\nconsole.log(a2.normalize("nfkc") === a3.normalize("nfkc")); // true\nconsole.log(a1.normalize("nfc") === a3.normalize("nfc")); // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 字符串迭代与解构\n\n字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：\n\nlet message = "abc";\nlet stringiterator = message[symbol.iterator]();\nconsole.log(stringiterator.next()); // {value: "a", done: false}\nconsole.log(stringiterator.next()); // {value: "b", done: false}\nconsole.log(stringiterator.next()); // {value: "c", done: false}\nconsole.log(stringiterator.next()); // {value: undefined, done: true}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在for-of 循环中可以通过这个迭代器按序访问每个字符：\n\nfor (const c of "abcde") {\nconsole.log(c);\n}\n// a\n// b\n// c\n// d\n// e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 字符串模式匹配方法\n\n为简化子字符串替换操作，ecmascript 提供了replace()方法。这个方法接收两个参数，第一个参数可以是一个regexp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：\n\nlet text = "cat, bat, sat, fat";\nlet result = text.replace("at", "ond");\nconsole.log(result); // "cond, bat, sat, fat"\nresult = text.replace(/at/g, "ond");\nconsole.log(result); // "cond, bond, sond, fond"\n\n\n1\n2\n3\n4\n5\n\n\n字符序列 替换文本 $$😒 $&:匹配整个模式的子字符串。与regexp.lastmatch 相同 $\':匹配的子字符串之前的字符串。与regexp.rightcontext 相同 $\\``:匹配的子字符串之后的字符串。与regexp.leftcontext 相同$n:匹配第n 个捕获组的字符串，其中n 是0~9。比如，$1 是匹配第一个捕获组的字符串，$2 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串$nn`:匹配第nn 个捕获组字符串，其中nn 是01~99。比如，$01 是匹配第一个捕获组的字符串，$02 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串\n\n使用这些特殊的序列，可以在替换文本中使用之前匹配的内容，如下面的例子所示：\n\nlet text = "cat, bat, sat, fat";\nresult = text.replace(/(.at)/g, "word ($1)");\nconsole.log(result); // word (cat), word (bat), word (sat), word (fat)\n\n\n1\n2\n3\n\n\n这里，每个以"at"结尾的词都会被替换成"word"后跟一对小括号，其中包含捕获组匹配的内容$1。replace()的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数可以更细致地控制替换过程，如下所示：\n\nfunction htmlescape(text) {\n  return text.replace(/[<>"&]/g, function(match, pos, originaltext) {\n    switch(match) {\n      case "<":\n        return "&lt;";\n      case ">":\n        return "&gt;";\n      case "&":\n        return "&amp;";\n      case "\\"":\n        return "&quot;";\n    }\n  });\n}\nconsole.log(htmlescape("<p class=\\"greeting\\">hello world!</p>"));\n// "&lt;p class=&quot;greeting&quot;&gt;hello world!</p>"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# localecompare 方法\n\nlocalecompare()的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是ecmascript 实现的标准语言，localecompare()区分大小写，大写字母排在小写字母前面。但其他地区未必是这种情况。\n\n\n# 单例内置对象\n\n\n# global 对象\n\nglobal 对象是ecmascript 中最特别的对象，因为代码不会显式地访问它。ecma-262 规定global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成global 对象的属性 。本书前面介绍的函数，包括isnan()、isfinite()、parseint()和parsefloat()，实际上都是global 对象的方法。除了这些，global 对象上还有另外一些方法。\n\n# url 编码方法\n\nencodeuri()和encodeuricomponent()方法用于编码统一资源标识符（uri），以便传给浏览器。有效的uri 不能包含某些字符，比如空格。使用uri 编码方法来编码uri 可以让浏览器能够理解它们，同时又以特殊的utf-8 编码替换掉所有无效字符。\n\n这两个方法的主要区别是，encodeuri()不会编码属于url 组件的特殊字符，比如冒号、斜杠、问号、井号，而encodeuricomponent()会编码它发现的所有非标准字符。\n\n与encodeuri()和encodeuricomponent()相对的是decodeuri()和decodeuricomponent()。decodeuri()只对使用encodeuri()编码过的字符解码。例如，%20 会被替换为空格，但%23 不会被替换为井号（#），因为井号不是由encodeuri()替换的。类似地，decodeuricomponent()解码所有被encodeuricomponent()编码的字符，基本上就是解码所有特殊值。\n\n# eval\n\neval方法就是一个完整的ecmascript 解释器，它接收一个参数，即一个要执行的ecmascript（javascript）字符串。\n\neval("console.log(\'hi\')");\n\n\n1\n\n\n等价\n\nconsole.log("hi");\n\n\n1\n\n\n注意\n\n注意 解释代码字符串的能力是非常强大的，但也非常危险。在使用eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对xss 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。\n\n',charsets:{cjk:!0},lastUpdated:"2024/08/26, 22:47:01",lastUpdatedTimestamp:1724683621e3},{title:"集合引用类型",frontmatter:{title:"集合引用类型",date:"2024-08-26T22:49:35.000Z",permalink:"/pages/f63386/",categories:["前端","JavaScript高级程序设计"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/08.%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html",relativePath:"01.前端/03.JavaScript高级程序设计/08.集合引用类型.md",key:"v-51e54f4e",path:"/pages/f63386/",headers:[{level:2,title:"Array",slug:"array",normalizedTitle:"array",charIndex:2},{level:3,title:"from",slug:"from",normalizedTitle:"from",charIndex:12},{level:3,title:"数组复制与填充",slug:"数组复制与填充",normalizedTitle:"数组复制与填充",charIndex:1731},{level:2,title:"定型数组",slug:"定型数组",normalizedTitle:"定型数组",charIndex:3135},{level:3,title:"ArrayBuffer",slug:"arraybuffer",normalizedTitle:"arraybuffer",charIndex:3393},{level:3,title:"DataView",slug:"dataview",normalizedTitle:"dataview",charIndex:4033},{level:4,title:"ElementType",slug:"elementtype",normalizedTitle:"elementtype",charIndex:5060},{level:4,title:"字节序",slug:"字节序",normalizedTitle:"字节序",charIndex:5121},{level:4,title:"边界情形",slug:"边界情形",normalizedTitle:"边界情形",charIndex:6926},{level:3,title:"定型数组",slug:"定型数组-2",normalizedTitle:"定型数组",charIndex:3135},{level:4,title:"上溢和下溢",slug:"上溢和下溢",normalizedTitle:"上溢和下溢",charIndex:11372},{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:209},{level:3,title:"选择 Object 还是Map",slug:"选择-object-还是map",normalizedTitle:"选择 object 还是map",charIndex:12834},{level:2,title:"WeakMap",slug:"weakmap",normalizedTitle:"weakmap",charIndex:12910},{level:3,title:"使用弱映射",slug:"使用弱映射",normalizedTitle:"使用弱映射",charIndex:13366},{level:3,title:"DOM 元数据",slug:"dom-元数据",normalizedTitle:"dom 元数据",charIndex:15129},{level:2,title:"Set",slug:"set",normalizedTitle:"set",charIndex:250},{level:2,title:"WeakSet",slug:"weakset",normalizedTitle:"weakset",charIndex:17634}],headersStr:"Array from 数组复制与填充 定型数组 ArrayBuffer DataView ElementType 字节序 边界情形 定型数组 上溢和下溢 Map 选择 Object 还是Map WeakMap 使用弱映射 DOM 元数据 Set WeakSet",content:"# Array\n\n\n# from\n\nArray.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length 属性和可索引元素的结构。这种方式可用于很多场合：\n\n// 字符串会被拆分为单字符数组\nconsole.log(Array.from(\"Matt\")); // [\"M\", \"a\", \"t\", \"t\"]\n// 可以使用from()将集合和映射转换为一个新数组\nconst m = new Map().set(1, 2).set(3, 4);\nconst s = new Set().add(1)\n                    .add(2)\n                    .add(3)\n                    .add(4);\nconsole.log(Array.from(m)); // [[1, 2], [3, 4]]\nconsole.log(Array.from(s)); // [1, 2, 3, 4]\n// Array.from()对现有数组执行浅复制\nconst a1 = [1, 2, 3, 4];\nconst a2 = Array.from(a1);\nconsole.log(a1); // [1, 2, 3, 4]\nalert(a1 === a2); // false\n// 可以使用任何可迭代对象\nconst iter = {\n  *[Symbol.iterator]() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n  }\n};\nconsole.log(Array.from(iter)); // [1, 2, 3, 4]\n// arguments 对象可以被轻松地转换为数组\nfunction getArgsArray() {\n  return Array.from(arguments);\n}\nconsole.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]\n// from()也能转换带有必要属性的自定义对象\nconst arrayLikeObject = {\n  0: 1,\n  1: 2,\n  2: 3,\n  3: 4,\n  length: 4\n};\nconsole.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nArray.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中this 的值。但这个重写的this 值在箭头函数中不适用。\n\nconst a1 = [1, 2, 3, 4];\nconst a2 = Array.from(a1, x => x**2);\nconst a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});\nconsole.log(a2); // [1, 4, 9, 16]\nconsole.log(a3); // [1, 4, 9, 16]\n\n\n1\n2\n3\n4\n5\n\n\nArray.of()可以把一组参数转换为数组。这个方法用于替代在ES6 之前常用的Array.prototype.slice.call(arguments)，一种异常笨拙的将arguments 对象转换为数组的写法：\n\nconsole.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]\nconsole.log(Array.of(undefined)); // [undefined]\n\n\n1\n2\n\n\n\n# 数组复制与填充\n\ncopyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与fill()使用同样的计算方法：\n\nlet ints,\nreset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n// 从ints 中复制索引0 开始的内容，插入到索引5 开始的位置\n// 在源索引或目标索引到达数组边界时停止\nints.copyWithin(5);\nconsole.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\nreset();\n// 从ints 中复制索引5 开始的内容，插入到索引0 开始的位置\nints.copyWithin(0, 5);\nconsole.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]\nreset();\n// 从ints 中复制索引0 开始到索引3 结束的内容\n// 插入到索引4 开始的位置\nints.copyWithin(4, 0, 3);\nalert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]\nreset();\n// JavaScript 引擎在插值前会完整复制范围内的值\n// 因此复制期间不存在重写的风险\nints.copyWithin(2, 0, 6);\nalert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]\nreset();\n// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的\nints.copyWithin(-4, -7, -3);\nalert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\ncopyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：\n\nlet ints,\nreset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n// 索引过低，忽略\nints.copyWithin(1, -15, -12);\nalert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset()\n// 索引过高，忽略\nints.copyWithin(1, 12, 15);\nalert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n// 索引反向，忽略\nints.copyWithin(2, 4, 2);\nalert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n// 索引部分可用，复制、填充可用部分\nints.copyWithin(4, 7, 10)\nalert(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 定型数组\n\n定型数组（typed array）是ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。\n\n早在2006 年，Mozilla、Opera 等浏览器提供商就实验性地在浏览器中增加了用于渲染复杂图形应用程序的编程平台，无须安装任何插件。其目标是开发一套JavaScript API，从而充分利用3D 图形API 和GPU 加速，以便在<canvas>元素上渲染复杂的图形。\n\n\n# ArrayBuffer\n\nFloat32Array 实际上是一种“视图”，可以允许JavaScript 运行时访问一块名为ArrayBuffer 的预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位。\n\n笔记\n\nSharedArrayBuffer 是ArrayBuffer 的一个变体，可以无须复制就在执行上下文间传递它。\n\nArrayBuffer()是一个普通的JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。\n\nArrayBuffer与C++的malloc的区别\n\n * malloc()在分配失败时会返回一个null指针，ArrayBuffer分配失败时会抛出错误。\n * malloc()可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。ArrayBuffer分配的内存不能超过Number.MAX_SAFE_INTEGER。\n * malloc()调用成功不会初始化实际的地址，声明ArrayBuffer 则会将所有二进制位初始化为0。\n * 通过malloc()分配的堆内存除非调用free()或程序退出，否则系统不能再使用。而通过声明ArrayBuffer 分配的堆内存可以被当成垃圾回收，不用手动释放。\n\n笔记\n\n不能仅通过对ArrayBuffer 的引用就读取或写入其内容。要读取或写入ArrayBuffer，就必须通过视图。视图有不同的类型，但引用的都是ArrayBuffer 中存储的二进制数据。\n\n\n# DataView\n\n第一种允许你读写ArrayBuffer 的视图是DataView。这个视图专为文件I/O 和网络I/O 设计，其API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。\n\nconst buf = new ArrayBuffer(16);\n// DataView 默认使用整个ArrayBuffer\nconst fullDataView = new DataView(buf);\nalert(fullDataView.byteOffset); // 0\nalert(fullDataView.byteLength); // 16\nalert(fullDataView.buffer === buf); // true\n// 构造函数接收一个可选的字节偏移量和字节长度\n// byteOffset=0 表示视图从缓冲起点开始\n// byteLength=8 限制视图为前8 个字节\nconst firstHalfDataView = new DataView(buf, 0, 8);\nalert(firstHalfDataView.byteOffset); // 0\nalert(firstHalfDataView.byteLength); // 8\nalert(firstHalfDataView.buffer === buf); // true\n// 如果不指定，则DataView 会使用剩余的缓冲\n// byteOffset=8 表示视图从缓冲的第9 个字节开始\n// byteLength 未指定，默认为剩余缓冲\nconst secondHalfDataView = new DataView(buf, 8);\nalert(secondHalfDataView.byteOffset); // 8\nalert(secondHalfDataView.byteLength); // 8\nalert(secondHalfDataView.buffer === buf); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n要通过DataView 读取缓冲，还需要几个组件。\n\n * 首先是要读或写的字节偏移量。可以看成DataView 中的某种“地址”。\n * DataView 应该使用ElementType 来实现JavaScript 的Number 类型到缓冲内二进制格式的转换。\n * 最后是内存中值的字节序。默认为大端字节序。\n\n# ElementType\n\nDataView 对存储在缓冲内的数据类型没有预设。它暴露的API 强制开发者在读、写时指定一个ElementType，然后DataView 就会忠实地为读、写而完成相应的转换。\n\nECMAScript 6 支持8 种不同的ElementType（见下表）。\n\n\n\nDataView 为上表中的每种类型都暴露了get 和set 方法，这些方法使用byteOffset（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的，如下例所示：\n\n// 在内存中分配两个字节并声明一个DataView\nconst buf = new ArrayBuffer(2);\nconst view = new DataView(buf);\n// 说明整个缓冲确实所有二进制位都是0\n// 检查第一个和第二个字符\nalert(view.getInt8(0)); // 0\nalert(view.getInt8(1)); // 0\n// 检查整个缓冲\nalert(view.getInt16(0)); // 0\n// 将整个缓冲都设置为1\n// 255 的二进制表示是11111111（2^8 - 1）\nview.setUint8(0, 255);\n// DataView 会自动将数据转换为特定的ElementType\n// 255 的十六进制表示是0xFF\nview.setUint8(1, 0xFF);\n// 现在，缓冲里都是1 了\n// 如果把它当成二补数的有符号整数，则应该是-1\nalert(view.getInt16(0)); // -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 字节序\n\n字节序指的是多字节数据在内存中的存储方式。常见的是大端字节序和小端字节序。\n\n * 大端字节序：高位字节在前，低位字节在后。\n * 小端字节序：低位字节在前，高位字节在后。\n\nDataView 默认使用大端字节序，但可以指定小端字节序。如下例所示：\n\n// 在内存中分配两个字节并声明一个DataView\nconst buf = new ArrayBuffer(2);\nconst view = new DataView(buf);\n// 填充缓冲，让第一位和最后一位都是1\nview.setUint8(0, 0x80); // 设置最左边的位等于1\nview.setUint8(1, 0x01); // 设置最右边的位等于1\n// 缓冲内容（为方便阅读，人为加了空格）\n// 0x8 0x0 0x0 0x1\n// 1000 0000 0000 0001\n// 按大端字节序读取Uint16\n// 0x80 是高字节，0x01 是低字节\n// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769\nalert(view.getUint16(0)); // 32769\n// 按小端字节序读取Uint16\n// 0x01 是高字节，0x80 是低字节\n// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384\nalert(view.getUint16(0, true)); // 384\n// 按大端字节序写入Uint16\nview.setUint16(0, 0x0004);\n// 缓冲内容（为方便阅读，人为加了空格）\n// 0x0 0x0 0x0 0x4\n// 0000 0000 0000 0100\nalert(view.getUint8(0)); // 0\nalert(view.getUint8(1)); // 4\n// 按小端字节序写入Uint16\nview.setUint16(0, 0x0002, true);\n// 缓冲内容（为方便阅读，人为加了空格）\n// 0x0 0x2 0x0 0x0\n// 0000 0010 0000 0000\nalert(view.getUint8(0)); // 2\nalert(view.getUint8(1)); // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 边界情形\n\nDataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出RangeError：\n\nconst buf = new ArrayBuffer(6);\nconst view = new DataView(buf);\n// 尝试读取部分超出缓冲范围的值\nview.getInt32(4);\n// RangeError\n// 尝试读取超出缓冲范围的值\nview.getInt32(8);\n// RangeError\n// 尝试读取超出缓冲范围的值\nview.getInt32(-1);\n// RangeError\n// 尝试写入超出缓冲范围的值\nview.setInt32(4, 123);\n// RangeError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nDataView 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为0。如果无法转换，则抛出错误：\n\nconst buf = new ArrayBuffer(1);\nconst view = new DataView(buf);\nview.setInt8(0, 1.5);\nalert(view.getInt8(0)); // 1\nview.setInt8(0, [4]);\nalert(view.getInt8(0)); // 4\nview.setInt8(0, 'f');\nalert(view.getInt8(0)); // 0\nview.setInt8(0, Symbol());\n// TypeError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 定型数组\n\n定型数组是另一种形式的ArrayBuffer 视图。虽然概念上与DataView 接近，但定型数组的区别在于，它特定于一种ElementType 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API 和更高的性能。设计定型数组的目的就是提高与WebGL 等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript 引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快。\n\n创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类 型的定型数组。另外，通过<ElementType>.from()和<ElementType>.of()也可以创建定型数组：\n\n// 创建一个12 字节的缓冲\nconst buf = new ArrayBuffer(12);\n// 创建一个引用该缓冲的Int32Array\nconst ints = new Int32Array(buf);\n// 这个定型数组知道自己的每个元素需要4 字节\n// 因此长度为3\nalert(ints.length); // 3\n// 创建一个长度为6 的Int32Array\nconst ints2 = new Int32Array(6);\n// 每个数值使用4 字节，因此ArrayBuffer 是24 字节\nalert(ints2.length); // 6\n// 类似DataView，定型数组也有一个指向关联缓冲的引用\nalert(ints2.buffer.byteLength); // 24\n// 创建一个包含[2, 4, 6, 8]的Int32Array\nconst ints3 = new Int32Array([2, 4, 6, 8]);\nalert(ints3.length); // 4\nalert(ints3.buffer.byteLength); // 16\nalert(ints3[2]); // 6\n// 通过复制ints3 的值创建一个Int16Array\nconst ints4 = new Int16Array(ints3);\n// 这个新类型数组会分配自己的缓冲\n// 对应索引的每个值会相应地转换为新格式\nalert(ints4.length); // 4\nalert(ints4.buffer.byteLength); // 8\nalert(ints4[2]); // 6\n// 基于普通数组来创建一个Int16Array\nconst ints5 = Int16Array.from([3, 5, 7, 9]);\nalert(ints5.length); // 4\nalert(ints5.buffer.byteLength); // 8\nalert(ints5[2]); // 7\n// 基于传入的参数创建一个Float32Array\nconst floats = Float32Array.of(3.14, 2.718, 1.618);\nalert(floats.length); // 3\nalert(floats.buffer.byteLength); // 12\nalert(floats[2]); // 1.6180000305175781\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n定型数组的构造函数和实例都有一个BYTES_PER_ELEMENT 属性，返回该类型数组中每个元素的大小：\n\nalert(Int16Array.BYTES_PER_ELEMENT); // 2\nalert(Int32Array.BYTES_PER_ELEMENT); // 4\nconst ints = new Int32Array(1),\nfloats = new Float64Array(1);\nalert(ints.BYTES_PER_ELEMENT); // 4\nalert(floats.BYTES_PER_ELEMENT); // 8\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果定型数组没有用任何值初始化，则其关联的缓冲会以0 填充：\n\nconst ints = new Int32Array(4);\nalert(ints[0]); // 0\nalert(ints[1]); // 0\nalert(ints[2]); // 0\nalert(ints[3]); // 0\n\n\n1\n2\n3\n4\n5\n\n\n笔记\n\n从很多方面看，定型数组与普通数组都很相似。\n\n笔记\n\n定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。\n\n下列方法不适用于定性数组\n\n * concat\n * pop\n * push\n * shift\n * splice\n * unshift\n\n不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：set()和subarray()。set()从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：\n\n// 创建长度为8 的int16 数组\nconst container = new Int16Array(8);\n// 把定型数组复制为前4 个值\n// 偏移量默认为索引0\ncontainer.set(Int8Array.of(1, 2, 3, 4));\nconsole.log(container); // [1,2,3,4,0,0,0,0]\n// 把普通数组复制为后4 个值\n// 偏移量4 表示从索引4 开始插入\ncontainer.set([5,6,7,8], 4);\nconsole.log(container); // [1,2,3,4,5,6,7,8]\n// 溢出会抛出错误\ncontainer.set([5,6,7,8], 7);\n// RangeError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nsubarray()执行与set()相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的：\n\nconst source = Int16Array.of(2, 4, 6, 8);\n// 把整个数组复制为一个同类型的新数组\nconst fullCopy = source.subarray();\nconsole.log(fullCopy); // [2, 4, 6, 8]\n// 从索引2 开始复制数组\nconst halfCopy = source.subarray(2);\nconsole.log(halfCopy); // [6, 8]\n// 从索引1 开始复制到索引3\nconst partialCopy = source.subarray(1, 3);\nconsole.log(partialCopy); // [4, 6]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n定型数组没有原生的拼接能力，但使用定型数组API 提供的很多工具可以手动构建：\n\n// 第一个参数是应该返回的数组类型\n// 其余参数是应该拼接在一起的定型数组\nfunction typedArrayConcat(typedArrayConstructor, ...typedArrays) {\n// 计算所有数组中包含的元素总数\n  const numElements = typedArrays.reduce((x,y) => (x.length || x) + y.length);\n  // 按照提供的类型创建一个数组，为所有元素留出空间\n  const resultArray = new typedArrayConstructor(numElements);\n  // 依次转移数组\n  let currentOffset = 0;\n  typedArrays.map(x => {\n    resultArray.set(x, currentOffset);\n    currentOffset += x.length;\n  });\n  return resultArray;\n}\nconst concatArray = typedArrayConcat(Int32Array,\nInt8Array.of(1, 2, 3),\nInt16Array.of(4, 5, 6),\nFloat32Array.of(7, 8, 9));\nconsole.log(concatArray); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(concatArray instanceof Int32Array); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 上溢和下溢\n\n定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了如何处理下溢和上溢：\n\n// 长度为2 的有符号整数数组\n// 每个索引保存一个二补数形式的有符号整数\n// 范围是-128（-1 * 2^7）~127（2^7 - 1）\nconst ints = new Int8Array(2);\n// 长度为2 的无符号整数数组\n// 每个索引保存一个无符号整数\n// 范围是0~255（2^7 - 1）\nconst unsignedInts = new Uint8Array(2);\n// 上溢的位不会影响相邻索引\n// 索引只取最低有效位上的8 位\nunsignedInts[1] = 256; // 0x100\nconsole.log(unsignedInts); // [0, 0]\nunsignedInts[1] = 511; // 0x1FF\nconsole.log(unsignedInts); // [0, 255]\n// 下溢的位会被转换为其无符号的等价值\n// 0xFF 是以二补数形式表示的-1（截取到8 位）,\n// 但255 是一个无符号整数\nunsignedInts[1] = -1 // 0xFF (truncated to 8 bits)\nconsole.log(unsignedInts); // [0, 255]\n// 上溢自动变成二补数形式\n// 0x80 是无符号整数的128，是二补数形式的-128\nints[1] = 128; // 0x80\nconsole.log(ints); // [0, -128]\n// 下溢自动变成二补数形式\n// 0xFF 是无符号整数的255，是二补数形式的-1\nints[1] = 255; // 0xFF\nconsole.log(ints); // [0, -1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n除了8 种元素类型，还有一种“夹板”数组类型：Uint8ClampedArray，不允许任何方向溢出。超出最大值255 的值会被向下舍入为255，而小于最小值0 的值会被向上舍入为0。\n\nconst clampedInts = new Uint8ClampedArray([-1, 0, 255, 256]);\nconsole.log(clampedInts); // [0, 0, 255, 255]\n\n\n1\n2\n\n\n笔记\n\n按照JavaScript 之父Brendan Eich 的说法：“Uint8ClampedArray 完全是HTML5canvas 元素的历史留存。除非真的做跟canvas 相关的开发，否则不要使用它。”\n\n\n# Map\n\n笔记\n\n与Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何JavaScript 数据类型作为键。Map 内部使用SameValueZero 比较操作（ECMAScript 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。与Object 类似，映射的值是没有限制的。\n\n与Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。\n\n\n# 选择 Object 还是Map\n\n内存占用：Map可以多存储50%左右 插入性能：Map更好 查找速度：Object更好 删除性能：Map更好\n\n\n# WeakMap\n\n笔记\n\nWeakMap 中的“weak”（弱），描述的是JavaScript 垃圾回收程序对待“弱映射”中键的方式。\n\nWeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。\n\n因为WeakMap 中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。当然，也用不着像clear()这样一次性销毁所有键/值的方法。WeakMap 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问WeakMap 实例，也没办法看到其中的内容。\n\nWeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。\n\n\n# 使用弱映射\n\nWeakMap 实例与现有JavaScript 对象有着很大不同，可能一时不容易说清楚应该怎么使用它。这个问题没有唯一的答案，但已经出现了很多相关策略。\n\n弱映射造就了在JavaScript 中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。\n\nconst wm = new WeakMap();\nclass User {\n  constructor(id) {\n    this.idProperty = Symbol('id');\n    this.setId(id);\n  }\n  setPrivate(property, value) {\n    const privateMembers = wm.get(this) || {};\n    privateMembers[property] = value;\n    wm.set(this, privateMembers);\n  }\n  getPrivate(property) {\n    return wm.get(this)[property];\n  }\n  setId(id) {\n    this.setPrivate(this.idProperty, id);\n  }\n  getId() {\n    return this.getPrivate(this.idProperty);\n  }\n}\nconst user = new User(123);\nalert(user.getId()); // 123\nuser.setId(456);\nalert(user.getId()); // 456\n// 并不是真正私有的\nalert(wm.get(user)[user.idProperty]); // 456\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n慧眼独具的读者会发现，对于上面的实现，外部代码只需要拿到对象实例的引用和弱映射，就可以取得“私有”变量了。为了避免这种访问，可以用一个闭包把WeakMap 包装起来，这样就可以把弱映射与外界完全隔离开了：\n\nconst User = (() => {\n  const wm = new WeakMap()\n\n  class User {\n    constructor(id) {\n      this.idProperty = Symbol('id')\n      this.setId(id)\n    }\n    setPrivate(property, value) {\n      const privateMembers = wm.get(this) || {}\n      privateMembers[property] = value\n      wm.set(this, privateMembers)\n    }\n\n    getPrivate(property) {\n      return wm.get(this)[property]\n    }\n\n    setId(id) {\n      this.setPrivate(this.idProperty, id)\n    }\n\n    getId() {\n      return this.getPrivate(this.idProperty)\n    }\n  }\n  return User\n})()\nconst user = new User(123);\nalert(user.getId()); // 123\nuser.setId(456);\nalert(user.getId()); // 456\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这样，拿不到弱映射中的健，也就无法取得弱映射中对应的值。虽然这防止了前面提到的访问，但整个代码也完全陷入了ES6 之前的闭包私有变量模式。\n\n\n# DOM 元数据\n\n因为WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据。来看下面这个例子，其中使用了常规的Map：\n\nconst m = new Map();\nconst loginButton = document.querySelector('#login');\n// 给这个节点关联一些元数据\nm.set(loginButton, {disabled: true});\n\n\n1\n2\n3\n4\n\n\n假设在上面的代码执行后，页面被JavaScript 改变了，原来的登录按钮从DOM 树中被删掉了。但由于映射中还保存着按钮的引用，所以对应的DOM 节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。\n\n如果这里使用的是弱映射，如以下代码所示，那么当节点从DOM 树中被删除后，垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）：\n\nconst wm = new WeakMap();\nconst loginButton = document.querySelector('#login');\n// 给这个节点关联一些元数据\nwm.set(loginButton, {disabled: true});\n\n\n1\n2\n3\n4\n\n\n\n# Set\n\n笔记\n\n与Map 类似，Set 可以包含任何JavaScript 数据类型作为值。集合也使用SameValueZero 操作（ECMAScript 内部定义，无法在语言中使用），基本上相当于使用严格对象相等的标准来检查值的匹配性。\n\n实现正式集合操作的示例\n\nclass Xset extends Set {\n  union(...sets) {\n    return XSet.union(this, ...sets)\n  }\n  intersection(...sets) {\n    return XSet.intersection(this, ...sets)\n  }\n  difference(set) {\n    return XSet.difference(this, set);\n  }\n  symmetricDifference(set) {\n    return XSet.symmetricDifference(this, set);\n  }\n  cartesianProduct(set) {\n    return XSet.cartesianProduct(this, set);\n  }\n  powerSet() {\n    return XSet.powerSet(this);\n  }\n  static union(a, ...bSets) {\n    const unionSet = new XSet(a)\n    for (const b of bSets) {\n      for (const value of b) {\n        unionSet.add(value)\n      }\n    }\n    return unionSet\n  }\n  static intersection(a, ...bSets) {\n    const intersectionSet = new XSet(a)\n    for (const b of bSets) {\n      for (const value of b) {\n        if (!intersectionSet.has(value)) {\n          intersectionSet.delete(value)\n        }\n      }\n    }\n    return intersectionSet\n  }\n  static difference(a, b) {\n    const differenceSet = new XSet(a)\n    for (const value of b) {\n      differenceSet.delete(value)\n    }\n    return differenceSet\n  }\n  static symmetricDifference(a, b) {\n    return a.union(b).difference(a.intersection(b))\n  }\n  static cartesianProduct(a, b) {\n    const cartesianProductSet = new XSet();\n    for (const aValue of a) {\n      for (const bValue of b) {\n        cartesianProductSet.add([aValue, bValue]);\n      }\n    }\n    return cartesianProductSet;\n  }\n  static powerSet(a) {\n    const powerSet = new XSet().add(new XSet());\n    for (const value of a) {\n      for (const set of new Xset(powerSet)) {\n        powerSet.add(new XSet(set).add(value))\n      }\n    }\n    return powerSet;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# WeakSet\n\n笔记\n\n弱集合中的值只能是Object 或者继承自Object 的类型，尝试使用非对象设置值会抛出TypeError。\n\nWeakSet 中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，这些值不属于正式的引用，不会阻止垃圾回收。\n\n相比于WeakMap 实例，WeakSet 实例的用处没有那么大。不过，弱集合在给对象打标签时还是有价值的。\n\nconst disabledElements = new Set();\nconst loginButton = document.querySelector('#login');\n// 通过加入对应集合，给这个节点打上“禁用”标签\ndisabledElements.add(loginButton);\n\n\n1\n2\n3\n4\n",normalizedContent:"# array\n\n\n# from\n\narray.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length 属性和可索引元素的结构。这种方式可用于很多场合：\n\n// 字符串会被拆分为单字符数组\nconsole.log(array.from(\"matt\")); // [\"m\", \"a\", \"t\", \"t\"]\n// 可以使用from()将集合和映射转换为一个新数组\nconst m = new map().set(1, 2).set(3, 4);\nconst s = new set().add(1)\n                    .add(2)\n                    .add(3)\n                    .add(4);\nconsole.log(array.from(m)); // [[1, 2], [3, 4]]\nconsole.log(array.from(s)); // [1, 2, 3, 4]\n// array.from()对现有数组执行浅复制\nconst a1 = [1, 2, 3, 4];\nconst a2 = array.from(a1);\nconsole.log(a1); // [1, 2, 3, 4]\nalert(a1 === a2); // false\n// 可以使用任何可迭代对象\nconst iter = {\n  *[symbol.iterator]() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n  }\n};\nconsole.log(array.from(iter)); // [1, 2, 3, 4]\n// arguments 对象可以被轻松地转换为数组\nfunction getargsarray() {\n  return array.from(arguments);\n}\nconsole.log(getargsarray(1, 2, 3, 4)); // [1, 2, 3, 4]\n// from()也能转换带有必要属性的自定义对象\nconst arraylikeobject = {\n  0: 1,\n  1: 2,\n  2: 3,\n  3: 4,\n  length: 4\n};\nconsole.log(array.from(arraylikeobject)); // [1, 2, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\narray.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中this 的值。但这个重写的this 值在箭头函数中不适用。\n\nconst a1 = [1, 2, 3, 4];\nconst a2 = array.from(a1, x => x**2);\nconst a3 = array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});\nconsole.log(a2); // [1, 4, 9, 16]\nconsole.log(a3); // [1, 4, 9, 16]\n\n\n1\n2\n3\n4\n5\n\n\narray.of()可以把一组参数转换为数组。这个方法用于替代在es6 之前常用的array.prototype.slice.call(arguments)，一种异常笨拙的将arguments 对象转换为数组的写法：\n\nconsole.log(array.of(1, 2, 3, 4)); // [1, 2, 3, 4]\nconsole.log(array.of(undefined)); // [undefined]\n\n\n1\n2\n\n\n\n# 数组复制与填充\n\ncopywithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与fill()使用同样的计算方法：\n\nlet ints,\nreset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n// 从ints 中复制索引0 开始的内容，插入到索引5 开始的位置\n// 在源索引或目标索引到达数组边界时停止\nints.copywithin(5);\nconsole.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\nreset();\n// 从ints 中复制索引5 开始的内容，插入到索引0 开始的位置\nints.copywithin(0, 5);\nconsole.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]\nreset();\n// 从ints 中复制索引0 开始到索引3 结束的内容\n// 插入到索引4 开始的位置\nints.copywithin(4, 0, 3);\nalert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]\nreset();\n// javascript 引擎在插值前会完整复制范围内的值\n// 因此复制期间不存在重写的风险\nints.copywithin(2, 0, 6);\nalert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]\nreset();\n// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的\nints.copywithin(-4, -7, -3);\nalert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\ncopywithin()静默忽略超出数组边界、零长度及方向相反的索引范围：\n\nlet ints,\nreset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n// 索引过低，忽略\nints.copywithin(1, -15, -12);\nalert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset()\n// 索引过高，忽略\nints.copywithin(1, 12, 15);\nalert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n// 索引反向，忽略\nints.copywithin(2, 4, 2);\nalert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\nreset();\n// 索引部分可用，复制、填充可用部分\nints.copywithin(4, 7, 10)\nalert(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 定型数组\n\n定型数组（typed array）是ecmascript 新增的结构，目的是提升向原生库传输数据的效率。实际上，javascript 并没有“typedarray”类型，它所指的其实是一种特殊的包含数值类型的数组。\n\n早在2006 年，mozilla、opera 等浏览器提供商就实验性地在浏览器中增加了用于渲染复杂图形应用程序的编程平台，无须安装任何插件。其目标是开发一套javascript api，从而充分利用3d 图形api 和gpu 加速，以便在<canvas>元素上渲染复杂的图形。\n\n\n# arraybuffer\n\nfloat32array 实际上是一种“视图”，可以允许javascript 运行时访问一块名为arraybuffer 的预分配内存。arraybuffer 是所有定型数组及视图引用的基本单位。\n\n笔记\n\nsharedarraybuffer 是arraybuffer 的一个变体，可以无须复制就在执行上下文间传递它。\n\narraybuffer()是一个普通的javascript 构造函数，可用于在内存中分配特定数量的字节空间。\n\narraybuffer与c++的malloc的区别\n\n * malloc()在分配失败时会返回一个null指针，arraybuffer分配失败时会抛出错误。\n * malloc()可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。arraybuffer分配的内存不能超过number.max_safe_integer。\n * malloc()调用成功不会初始化实际的地址，声明arraybuffer 则会将所有二进制位初始化为0。\n * 通过malloc()分配的堆内存除非调用free()或程序退出，否则系统不能再使用。而通过声明arraybuffer 分配的堆内存可以被当成垃圾回收，不用手动释放。\n\n笔记\n\n不能仅通过对arraybuffer 的引用就读取或写入其内容。要读取或写入arraybuffer，就必须通过视图。视图有不同的类型，但引用的都是arraybuffer 中存储的二进制数据。\n\n\n# dataview\n\n第一种允许你读写arraybuffer 的视图是dataview。这个视图专为文件i/o 和网络i/o 设计，其api 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。dataview 对缓冲内容没有任何预设，也不能迭代。\n\nconst buf = new arraybuffer(16);\n// dataview 默认使用整个arraybuffer\nconst fulldataview = new dataview(buf);\nalert(fulldataview.byteoffset); // 0\nalert(fulldataview.bytelength); // 16\nalert(fulldataview.buffer === buf); // true\n// 构造函数接收一个可选的字节偏移量和字节长度\n// byteoffset=0 表示视图从缓冲起点开始\n// bytelength=8 限制视图为前8 个字节\nconst firsthalfdataview = new dataview(buf, 0, 8);\nalert(firsthalfdataview.byteoffset); // 0\nalert(firsthalfdataview.bytelength); // 8\nalert(firsthalfdataview.buffer === buf); // true\n// 如果不指定，则dataview 会使用剩余的缓冲\n// byteoffset=8 表示视图从缓冲的第9 个字节开始\n// bytelength 未指定，默认为剩余缓冲\nconst secondhalfdataview = new dataview(buf, 8);\nalert(secondhalfdataview.byteoffset); // 8\nalert(secondhalfdataview.bytelength); // 8\nalert(secondhalfdataview.buffer === buf); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n要通过dataview 读取缓冲，还需要几个组件。\n\n * 首先是要读或写的字节偏移量。可以看成dataview 中的某种“地址”。\n * dataview 应该使用elementtype 来实现javascript 的number 类型到缓冲内二进制格式的转换。\n * 最后是内存中值的字节序。默认为大端字节序。\n\n# elementtype\n\ndataview 对存储在缓冲内的数据类型没有预设。它暴露的api 强制开发者在读、写时指定一个elementtype，然后dataview 就会忠实地为读、写而完成相应的转换。\n\necmascript 6 支持8 种不同的elementtype（见下表）。\n\n\n\ndataview 为上表中的每种类型都暴露了get 和set 方法，这些方法使用byteoffset（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的，如下例所示：\n\n// 在内存中分配两个字节并声明一个dataview\nconst buf = new arraybuffer(2);\nconst view = new dataview(buf);\n// 说明整个缓冲确实所有二进制位都是0\n// 检查第一个和第二个字符\nalert(view.getint8(0)); // 0\nalert(view.getint8(1)); // 0\n// 检查整个缓冲\nalert(view.getint16(0)); // 0\n// 将整个缓冲都设置为1\n// 255 的二进制表示是11111111（2^8 - 1）\nview.setuint8(0, 255);\n// dataview 会自动将数据转换为特定的elementtype\n// 255 的十六进制表示是0xff\nview.setuint8(1, 0xff);\n// 现在，缓冲里都是1 了\n// 如果把它当成二补数的有符号整数，则应该是-1\nalert(view.getint16(0)); // -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 字节序\n\n字节序指的是多字节数据在内存中的存储方式。常见的是大端字节序和小端字节序。\n\n * 大端字节序：高位字节在前，低位字节在后。\n * 小端字节序：低位字节在前，高位字节在后。\n\ndataview 默认使用大端字节序，但可以指定小端字节序。如下例所示：\n\n// 在内存中分配两个字节并声明一个dataview\nconst buf = new arraybuffer(2);\nconst view = new dataview(buf);\n// 填充缓冲，让第一位和最后一位都是1\nview.setuint8(0, 0x80); // 设置最左边的位等于1\nview.setuint8(1, 0x01); // 设置最右边的位等于1\n// 缓冲内容（为方便阅读，人为加了空格）\n// 0x8 0x0 0x0 0x1\n// 1000 0000 0000 0001\n// 按大端字节序读取uint16\n// 0x80 是高字节，0x01 是低字节\n// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769\nalert(view.getuint16(0)); // 32769\n// 按小端字节序读取uint16\n// 0x01 是高字节，0x80 是低字节\n// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384\nalert(view.getuint16(0, true)); // 384\n// 按大端字节序写入uint16\nview.setuint16(0, 0x0004);\n// 缓冲内容（为方便阅读，人为加了空格）\n// 0x0 0x0 0x0 0x4\n// 0000 0000 0000 0100\nalert(view.getuint8(0)); // 0\nalert(view.getuint8(1)); // 4\n// 按小端字节序写入uint16\nview.setuint16(0, 0x0002, true);\n// 缓冲内容（为方便阅读，人为加了空格）\n// 0x0 0x2 0x0 0x0\n// 0000 0010 0000 0000\nalert(view.getuint8(0)); // 2\nalert(view.getuint8(1)); // 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 边界情形\n\ndataview 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出rangeerror：\n\nconst buf = new arraybuffer(6);\nconst view = new dataview(buf);\n// 尝试读取部分超出缓冲范围的值\nview.getint32(4);\n// rangeerror\n// 尝试读取超出缓冲范围的值\nview.getint32(8);\n// rangeerror\n// 尝试读取超出缓冲范围的值\nview.getint32(-1);\n// rangeerror\n// 尝试写入超出缓冲范围的值\nview.setint32(4, 123);\n// rangeerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ndataview 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为0。如果无法转换，则抛出错误：\n\nconst buf = new arraybuffer(1);\nconst view = new dataview(buf);\nview.setint8(0, 1.5);\nalert(view.getint8(0)); // 1\nview.setint8(0, [4]);\nalert(view.getint8(0)); // 4\nview.setint8(0, 'f');\nalert(view.getint8(0)); // 0\nview.setint8(0, symbol());\n// typeerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 定型数组\n\n定型数组是另一种形式的arraybuffer 视图。虽然概念上与dataview 接近，但定型数组的区别在于，它特定于一种elementtype 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的api 和更高的性能。设计定型数组的目的就是提高与webgl 等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，javascript 引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快。\n\n创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类 型的定型数组。另外，通过<elementtype>.from()和<elementtype>.of()也可以创建定型数组：\n\n// 创建一个12 字节的缓冲\nconst buf = new arraybuffer(12);\n// 创建一个引用该缓冲的int32array\nconst ints = new int32array(buf);\n// 这个定型数组知道自己的每个元素需要4 字节\n// 因此长度为3\nalert(ints.length); // 3\n// 创建一个长度为6 的int32array\nconst ints2 = new int32array(6);\n// 每个数值使用4 字节，因此arraybuffer 是24 字节\nalert(ints2.length); // 6\n// 类似dataview，定型数组也有一个指向关联缓冲的引用\nalert(ints2.buffer.bytelength); // 24\n// 创建一个包含[2, 4, 6, 8]的int32array\nconst ints3 = new int32array([2, 4, 6, 8]);\nalert(ints3.length); // 4\nalert(ints3.buffer.bytelength); // 16\nalert(ints3[2]); // 6\n// 通过复制ints3 的值创建一个int16array\nconst ints4 = new int16array(ints3);\n// 这个新类型数组会分配自己的缓冲\n// 对应索引的每个值会相应地转换为新格式\nalert(ints4.length); // 4\nalert(ints4.buffer.bytelength); // 8\nalert(ints4[2]); // 6\n// 基于普通数组来创建一个int16array\nconst ints5 = int16array.from([3, 5, 7, 9]);\nalert(ints5.length); // 4\nalert(ints5.buffer.bytelength); // 8\nalert(ints5[2]); // 7\n// 基于传入的参数创建一个float32array\nconst floats = float32array.of(3.14, 2.718, 1.618);\nalert(floats.length); // 3\nalert(floats.buffer.bytelength); // 12\nalert(floats[2]); // 1.6180000305175781\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n定型数组的构造函数和实例都有一个bytes_per_element 属性，返回该类型数组中每个元素的大小：\n\nalert(int16array.bytes_per_element); // 2\nalert(int32array.bytes_per_element); // 4\nconst ints = new int32array(1),\nfloats = new float64array(1);\nalert(ints.bytes_per_element); // 4\nalert(floats.bytes_per_element); // 8\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果定型数组没有用任何值初始化，则其关联的缓冲会以0 填充：\n\nconst ints = new int32array(4);\nalert(ints[0]); // 0\nalert(ints[1]); // 0\nalert(ints[2]); // 0\nalert(ints[3]); // 0\n\n\n1\n2\n3\n4\n5\n\n\n笔记\n\n从很多方面看，定型数组与普通数组都很相似。\n\n笔记\n\n定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。\n\n下列方法不适用于定性数组\n\n * concat\n * pop\n * push\n * shift\n * splice\n * unshift\n\n不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：set()和subarray()。set()从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：\n\n// 创建长度为8 的int16 数组\nconst container = new int16array(8);\n// 把定型数组复制为前4 个值\n// 偏移量默认为索引0\ncontainer.set(int8array.of(1, 2, 3, 4));\nconsole.log(container); // [1,2,3,4,0,0,0,0]\n// 把普通数组复制为后4 个值\n// 偏移量4 表示从索引4 开始插入\ncontainer.set([5,6,7,8], 4);\nconsole.log(container); // [1,2,3,4,5,6,7,8]\n// 溢出会抛出错误\ncontainer.set([5,6,7,8], 7);\n// rangeerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nsubarray()执行与set()相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的：\n\nconst source = int16array.of(2, 4, 6, 8);\n// 把整个数组复制为一个同类型的新数组\nconst fullcopy = source.subarray();\nconsole.log(fullcopy); // [2, 4, 6, 8]\n// 从索引2 开始复制数组\nconst halfcopy = source.subarray(2);\nconsole.log(halfcopy); // [6, 8]\n// 从索引1 开始复制到索引3\nconst partialcopy = source.subarray(1, 3);\nconsole.log(partialcopy); // [4, 6]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n定型数组没有原生的拼接能力，但使用定型数组api 提供的很多工具可以手动构建：\n\n// 第一个参数是应该返回的数组类型\n// 其余参数是应该拼接在一起的定型数组\nfunction typedarrayconcat(typedarrayconstructor, ...typedarrays) {\n// 计算所有数组中包含的元素总数\n  const numelements = typedarrays.reduce((x,y) => (x.length || x) + y.length);\n  // 按照提供的类型创建一个数组，为所有元素留出空间\n  const resultarray = new typedarrayconstructor(numelements);\n  // 依次转移数组\n  let currentoffset = 0;\n  typedarrays.map(x => {\n    resultarray.set(x, currentoffset);\n    currentoffset += x.length;\n  });\n  return resultarray;\n}\nconst concatarray = typedarrayconcat(int32array,\nint8array.of(1, 2, 3),\nint16array.of(4, 5, 6),\nfloat32array.of(7, 8, 9));\nconsole.log(concatarray); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(concatarray instanceof int32array); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 上溢和下溢\n\n定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了如何处理下溢和上溢：\n\n// 长度为2 的有符号整数数组\n// 每个索引保存一个二补数形式的有符号整数\n// 范围是-128（-1 * 2^7）~127（2^7 - 1）\nconst ints = new int8array(2);\n// 长度为2 的无符号整数数组\n// 每个索引保存一个无符号整数\n// 范围是0~255（2^7 - 1）\nconst unsignedints = new uint8array(2);\n// 上溢的位不会影响相邻索引\n// 索引只取最低有效位上的8 位\nunsignedints[1] = 256; // 0x100\nconsole.log(unsignedints); // [0, 0]\nunsignedints[1] = 511; // 0x1ff\nconsole.log(unsignedints); // [0, 255]\n// 下溢的位会被转换为其无符号的等价值\n// 0xff 是以二补数形式表示的-1（截取到8 位）,\n// 但255 是一个无符号整数\nunsignedints[1] = -1 // 0xff (truncated to 8 bits)\nconsole.log(unsignedints); // [0, 255]\n// 上溢自动变成二补数形式\n// 0x80 是无符号整数的128，是二补数形式的-128\nints[1] = 128; // 0x80\nconsole.log(ints); // [0, -128]\n// 下溢自动变成二补数形式\n// 0xff 是无符号整数的255，是二补数形式的-1\nints[1] = 255; // 0xff\nconsole.log(ints); // [0, -1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n除了8 种元素类型，还有一种“夹板”数组类型：uint8clampedarray，不允许任何方向溢出。超出最大值255 的值会被向下舍入为255，而小于最小值0 的值会被向上舍入为0。\n\nconst clampedints = new uint8clampedarray([-1, 0, 255, 256]);\nconsole.log(clampedints); // [0, 0, 255, 255]\n\n\n1\n2\n\n\n笔记\n\n按照javascript 之父brendan eich 的说法：“uint8clampedarray 完全是html5canvas 元素的历史留存。除非真的做跟canvas 相关的开发，否则不要使用它。”\n\n\n# map\n\n笔记\n\n与object 只能使用数值、字符串或符号作为键不同，map 可以使用任何javascript 数据类型作为键。map 内部使用samevaluezero 比较操作（ecmascript 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。与object 类似，映射的值是没有限制的。\n\n与object 类型的一个主要差异是，map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。\n\n\n# 选择 object 还是map\n\n内存占用：map可以多存储50%左右 插入性能：map更好 查找速度：object更好 删除性能：map更好\n\n\n# weakmap\n\n笔记\n\nweakmap 中的“weak”（弱），描述的是javascript 垃圾回收程序对待“弱映射”中键的方式。\n\nweakmap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。\n\n因为weakmap 中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。当然，也用不着像clear()这样一次性销毁所有键/值的方法。weakmap 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问weakmap 实例，也没办法看到其中的内容。\n\nweakmap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。\n\n\n# 使用弱映射\n\nweakmap 实例与现有javascript 对象有着很大不同，可能一时不容易说清楚应该怎么使用它。这个问题没有唯一的答案，但已经出现了很多相关策略。\n\n弱映射造就了在javascript 中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。\n\nconst wm = new weakmap();\nclass user {\n  constructor(id) {\n    this.idproperty = symbol('id');\n    this.setid(id);\n  }\n  setprivate(property, value) {\n    const privatemembers = wm.get(this) || {};\n    privatemembers[property] = value;\n    wm.set(this, privatemembers);\n  }\n  getprivate(property) {\n    return wm.get(this)[property];\n  }\n  setid(id) {\n    this.setprivate(this.idproperty, id);\n  }\n  getid() {\n    return this.getprivate(this.idproperty);\n  }\n}\nconst user = new user(123);\nalert(user.getid()); // 123\nuser.setid(456);\nalert(user.getid()); // 456\n// 并不是真正私有的\nalert(wm.get(user)[user.idproperty]); // 456\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n慧眼独具的读者会发现，对于上面的实现，外部代码只需要拿到对象实例的引用和弱映射，就可以取得“私有”变量了。为了避免这种访问，可以用一个闭包把weakmap 包装起来，这样就可以把弱映射与外界完全隔离开了：\n\nconst user = (() => {\n  const wm = new weakmap()\n\n  class user {\n    constructor(id) {\n      this.idproperty = symbol('id')\n      this.setid(id)\n    }\n    setprivate(property, value) {\n      const privatemembers = wm.get(this) || {}\n      privatemembers[property] = value\n      wm.set(this, privatemembers)\n    }\n\n    getprivate(property) {\n      return wm.get(this)[property]\n    }\n\n    setid(id) {\n      this.setprivate(this.idproperty, id)\n    }\n\n    getid() {\n      return this.getprivate(this.idproperty)\n    }\n  }\n  return user\n})()\nconst user = new user(123);\nalert(user.getid()); // 123\nuser.setid(456);\nalert(user.getid()); // 456\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这样，拿不到弱映射中的健，也就无法取得弱映射中对应的值。虽然这防止了前面提到的访问，但整个代码也完全陷入了es6 之前的闭包私有变量模式。\n\n\n# dom 元数据\n\n因为weakmap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据。来看下面这个例子，其中使用了常规的map：\n\nconst m = new map();\nconst loginbutton = document.queryselector('#login');\n// 给这个节点关联一些元数据\nm.set(loginbutton, {disabled: true});\n\n\n1\n2\n3\n4\n\n\n假设在上面的代码执行后，页面被javascript 改变了，原来的登录按钮从dom 树中被删掉了。但由于映射中还保存着按钮的引用，所以对应的dom 节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。\n\n如果这里使用的是弱映射，如以下代码所示，那么当节点从dom 树中被删除后，垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）：\n\nconst wm = new weakmap();\nconst loginbutton = document.queryselector('#login');\n// 给这个节点关联一些元数据\nwm.set(loginbutton, {disabled: true});\n\n\n1\n2\n3\n4\n\n\n\n# set\n\n笔记\n\n与map 类似，set 可以包含任何javascript 数据类型作为值。集合也使用samevaluezero 操作（ecmascript 内部定义，无法在语言中使用），基本上相当于使用严格对象相等的标准来检查值的匹配性。\n\n实现正式集合操作的示例\n\nclass xset extends set {\n  union(...sets) {\n    return xset.union(this, ...sets)\n  }\n  intersection(...sets) {\n    return xset.intersection(this, ...sets)\n  }\n  difference(set) {\n    return xset.difference(this, set);\n  }\n  symmetricdifference(set) {\n    return xset.symmetricdifference(this, set);\n  }\n  cartesianproduct(set) {\n    return xset.cartesianproduct(this, set);\n  }\n  powerset() {\n    return xset.powerset(this);\n  }\n  static union(a, ...bsets) {\n    const unionset = new xset(a)\n    for (const b of bsets) {\n      for (const value of b) {\n        unionset.add(value)\n      }\n    }\n    return unionset\n  }\n  static intersection(a, ...bsets) {\n    const intersectionset = new xset(a)\n    for (const b of bsets) {\n      for (const value of b) {\n        if (!intersectionset.has(value)) {\n          intersectionset.delete(value)\n        }\n      }\n    }\n    return intersectionset\n  }\n  static difference(a, b) {\n    const differenceset = new xset(a)\n    for (const value of b) {\n      differenceset.delete(value)\n    }\n    return differenceset\n  }\n  static symmetricdifference(a, b) {\n    return a.union(b).difference(a.intersection(b))\n  }\n  static cartesianproduct(a, b) {\n    const cartesianproductset = new xset();\n    for (const avalue of a) {\n      for (const bvalue of b) {\n        cartesianproductset.add([avalue, bvalue]);\n      }\n    }\n    return cartesianproductset;\n  }\n  static powerset(a) {\n    const powerset = new xset().add(new xset());\n    for (const value of a) {\n      for (const set of new xset(powerset)) {\n        powerset.add(new xset(set).add(value))\n      }\n    }\n    return powerset;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# weakset\n\n笔记\n\n弱集合中的值只能是object 或者继承自object 的类型，尝试使用非对象设置值会抛出typeerror。\n\nweakset 中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，这些值不属于正式的引用，不会阻止垃圾回收。\n\n相比于weakmap 实例，weakset 实例的用处没有那么大。不过，弱集合在给对象打标签时还是有价值的。\n\nconst disabledelements = new set();\nconst loginbutton = document.queryselector('#login');\n// 通过加入对应集合，给这个节点打上“禁用”标签\ndisabledelements.add(loginbutton);\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2024/08/27, 16:54:46",lastUpdatedTimestamp:1724748886e3},{title:"对象、类与面向对象编程",frontmatter:{title:"对象、类与面向对象编程",date:"2024-08-28T12:02:36.000Z",permalink:"/pages/ab17e4/",categories:["前端","JavaScript高级程序设计"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/10.%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html",relativePath:"01.前端/03.JavaScript高级程序设计/10.对象、类与面向对象编程.md",key:"v-e8175582",path:"/pages/ab17e4/",headers:[{level:2,title:"理解对象",slug:"理解对象",normalizedTitle:"理解对象",charIndex:2},{level:3,title:"属性类型",slug:"属性类型",normalizedTitle:"属性类型",charIndex:11},{level:4,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:19},{level:3,title:"定义多个属性",slug:"定义多个属性",normalizedTitle:"定义多个属性",charIndex:1001},{level:3,title:"读取属性的特性",slug:"读取属性的特性",normalizedTitle:"读取属性的特性",charIndex:1505},{level:3,title:"合并对象",slug:"合并对象",normalizedTitle:"合并对象",charIndex:1694},{level:3,title:"对象标识及相等判定",slug:"对象标识及相等判定",normalizedTitle:"对象标识及相等判定",charIndex:1886},{level:3,title:"增强的属性语法",slug:"增强的属性语法",normalizedTitle:"增强的属性语法",charIndex:2919},{level:4,title:"属性简写",slug:"属性简写",normalizedTitle:"属性简写",charIndex:2930},{level:4,title:"可计算属性",slug:"可计算属性",normalizedTitle:"可计算属性",charIndex:2961},{level:4,title:"简写方法名",slug:"简写方法名",normalizedTitle:"简写方法名",charIndex:3070},{level:3,title:"对象解构",slug:"对象解构",normalizedTitle:"对象解构",charIndex:3156},{level:2,title:"创建对象",slug:"创建对象",normalizedTitle:"创建对象",charIndex:3202},{level:3,title:"工厂模式创建",slug:"工厂模式创建",normalizedTitle:"工厂模式创建",charIndex:3211},{level:3,title:"构造函数模式",slug:"构造函数模式",normalizedTitle:"构造函数模式",charIndex:3500},{level:4,title:"构造函数也是函数",slug:"构造函数也是函数",normalizedTitle:"构造函数也是函数",charIndex:4057},{level:4,title:"构造函数的问题",slug:"构造函数的问题",normalizedTitle:"构造函数的问题",charIndex:4180},{level:3,title:"原型模式",slug:"原型模式",normalizedTitle:"原型模式",charIndex:4247},{level:4,title:"理解原型",slug:"理解原型",normalizedTitle:"理解原型",charIndex:4325},{level:4,title:"原型的问题",slug:"原型的问题",normalizedTitle:"原型的问题",charIndex:7891},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:6270},{level:3,title:"原型链",slug:"原型链",normalizedTitle:"原型链",charIndex:4797},{level:4,title:"原型链的问题",slug:"原型链的问题",normalizedTitle:"原型链的问题",charIndex:8390},{level:3,title:"盗用构造函数",slug:"盗用构造函数",normalizedTitle:"盗用构造函数",charIndex:8673},{level:3,title:"组合继承",slug:"组合继承",normalizedTitle:"组合继承",charIndex:9691},{level:3,title:"原型式继承",slug:"原型式继承",normalizedTitle:"原型式继承",charIndex:10700},{level:3,title:"寄生式继承",slug:"寄生式继承",normalizedTitle:"寄生式继承",charIndex:11907},{level:3,title:"寄生组合继承",slug:"寄生组合继承",normalizedTitle:"寄生组合继承",charIndex:12294},{level:2,title:"类",slug:"类",normalizedTitle:"类",charIndex:13},{level:3,title:"类的构成",slug:"类的构成",normalizedTitle:"类的构成",charIndex:13079},{level:4,title:"类的实例化",slug:"类的实例化",normalizedTitle:"类的实例化",charIndex:13573},{level:4,title:"非函数原型和类成员",slug:"非函数原型和类成员",normalizedTitle:"非函数原型和类成员",charIndex:14616},{level:4,title:"迭代器与生成器方法",slug:"迭代器与生成器方法",normalizedTitle:"迭代器与生成器方法",charIndex:14770},{level:3,title:"类的继承",slug:"类的继承",normalizedTitle:"类的继承",charIndex:16175},{level:4,title:"构造函数、HomeObject和 super()",slug:"构造函数、homeobject和-super",normalizedTitle:"构造函数、homeobject和 super()",charIndex:16183},{level:4,title:"抽象基类",slug:"抽象基类",normalizedTitle:"抽象基类",charIndex:16882},{level:4,title:"类混入",slug:"类混入",normalizedTitle:"类混入",charIndex:17173}],headersStr:"理解对象 属性类型 数据类型 定义多个属性 读取属性的特性 合并对象 对象标识及相等判定 增强的属性语法 属性简写 可计算属性 简写方法名 对象解构 创建对象 工厂模式创建 构造函数模式 构造函数也是函数 构造函数的问题 原型模式 理解原型 原型的问题 继承 原型链 原型链的问题 盗用构造函数 组合继承 原型式继承 寄生式继承 寄生组合继承 类 类的构成 类的实例化 非函数原型和类成员 迭代器与生成器方法 类的继承 构造函数、HomeObject和 super() 抽象基类 类混入",content:'# 理解对象\n\n\n# 属性类型\n\n# 数据类型\n\n数据有四种类型，Configurable、Enumerable、Writable、Value\n\n使用 Object.defineProperty 可以修改默认属性类型\n\n访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4 个特性描述它们的行为。\n\nConfigurable表示是否可以通过 delete 删除并重新定义，默认为true\n\nEnumerable表示是否可以通过 for-in 循环返回属性，默认为true\n\nWritable表示是否可以修改属性的值，默认为true\n\nValue表示属性的值，默认为undefined\n\n访问器属性是不能直接定义的，必须使用Object.defineProperty()。下面是一个例子：\n\nlet book = {\n    _year: 2004,\n    edition: 1\n};\n\nObject.defineProperty(book, "year", {\n    get: function() {\n        return this._year;\n    },\n    set: function(newValue) {\n        if (newValue > 2004) {\n            this._year = newValue;\n            this.edition += newValue - 2004;\n        }\n    }\n});\n\nbook.year = 2005;\nalert(book.edition); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n笔记\n\n在ECMAScript 5 以前，开发者会使用两个非标准的访问创建访问器属性：__define-Getter__()和__defineSetter__()。这两个方法最早是Firefox 引入的，后来Safari、Chrome 和Opera 也实现了。\n\n\n# 定义多个属性\n\nObject.defineProperties()方法可以定义多个属性\n\nlet book = {};\n\nObject.defineProperties(book, {\n    _year: {\n        value: 2004\n    },\n    edition: {\n        value: 1\n    },\n    year: {\n        get: function() {\n            return this._year;\n        },\n        set: function(newValue) {\n            if (newValue > 2004) {\n                this._year = newValue;\n                this.edition += newValue - 2004;\n            }\n        }\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 读取属性的特性\n\n使用 Object.getOwnPropertyDescriptor() 方法可以读取属性的属性描述符\n\nECMAScript 2017 新增了Object.getOwnPropertyDescriptors()静态方法。这个方法实际上会在每个自有属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回它们。\n\n\n# 合并对象\n\nObject.assign()方法用于将所有可枚举的自有属性从一个或多个源对象复制到目标对象。它将返回目标对象。\n\nObject.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。\n\n\n# 对象标识及相等判定\n\n在ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：\n\n// 这些是===符合预期的情况\nconsole.log(true === 1); // false\nconsole.log({} === {}); // false\nconsole.log("2" === 2); // false\n// 这些情况在不同JavaScript 引擎中表现不同，但仍被认为相等\nconsole.log(+0 === -0); // true\nconsole.log(+0 === 0); // true\nconsole.log(-0 === 0); // true\n// 要确定NaN 的相等性，必须使用极为讨厌的isNaN()\nconsole.log(NaN === NaN); // false\nconsole.log(isNaN(NaN)); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为改善这类情况，ECMAScript 6 规范新增了Object.is()，这个方法与===很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：\n\nconsole.log(Object.is(true, 1)); // false\nconsole.log(Object.is({}, {})); // false\nconsole.log(Object.is("2", 2)); // false\n// 正确的0、-0、+0 相等/不等判定\nconsole.log(Object.is(+0, -0)); // false\nconsole.log(Object.is(+0, 0)); // true\nconsole.log(Object.is(-0, 0)); // false\n// 正确的NaN 相等判定\nconsole.log(Object.is(NaN, NaN)); // true\n// 要检查超过两个值，递归地利用相等性传递即可：\nfunction recursivelyCheckEqual(x, ...rest) {\n  return Object.is(x, rest[0]) &&\n    (rest.length < 2 || recursivelyCheckEqual(...rest));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 增强的属性语法\n\n# 属性简写\n\n在属性名和变量名一致的时候，可以不用写两次\n\n# 可计算属性\n\n用[]包裹属性名，可以动态计算属性名\n\n注意\n\n可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。\n\n# 简写方法名\n\n不需要使用 object = { key: [Function] } 这种形式，可以直接使用 object = { key() { } } 这种形式\n\n\n# 对象解构\n\n可以使用对象解构语法从对象中进行嵌套解构、部分解构、对函数参数进行解构\n\n\n# 创建对象\n\n\n# 工厂模式创建\n\n使用函数方式，通过new一个Object并声明属性来批量创建对象。\n\n缺点：没有解决对象标识类型\n\nfunction createPerson(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function() {\n        console.log(this.name);\n    };\n    return o;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 构造函数模式\n\n自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。\n\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.sayName = function() {\n    console.log(this.name);\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n笔记\n\n按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在ECMAScript 中区分构造函数和普通函数。毕竟ECMAScript 的构造函数就是能创建对象的函数。\n\n通过构造函数创建实例会执行如下操作：\n\n * 在内存中创建一个新对象\n * 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数的 prototype 属性\n * 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）\n * 执行构造函数内部的代码（给新对象添加属性）\n * 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象\n\n笔记\n\n在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加\n\n# 构造函数也是函数\n\n笔记\n\n构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用new 操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数。\n\n# 构造函数的问题\n\n笔记\n\n构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。\n\n\n# 原型模式\n\n笔记\n\n使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型\n\n# 理解原型\n\n/**\n * 构造函数可以是函数表达式\n * 也可以是函数声明，因此以下两种形式都可以：\n * function Person() {}\n * let Person = function() {}\n */\nfunction Person() {}\n/**\n * 声明之后，构造函数就有了一个\n * 与之关联的原型对象：\n */\nconsole.log(typeof Person.prototype);\nconsole.log(Person.prototype);\n// {\n// constructor: f Person(),\n// __proto__: Object\n// }\n/**\n * 如前所述，构造函数有一个prototype 属性\n * 引用其原型对象，而这个原型对象也有一个\n * constructor 属性，引用这个构造函数\n * 换句话说，两者循环引用：\n */\nconsole.log(Person.prototype.constructor === Person); // true\n/**\n * 正常的原型链都会终止于Object 的原型对象\n * Object 原型的原型是null\n */\nconsole.log(Person.prototype.__proto__ === Object.prototype); // true\nconsole.log(Person.prototype.__proto__.constructor === Object); // true\nconsole.log(Person.prototype.__proto__.__proto__ === null); // true\nconsole.log(Person.prototype.__proto__);\n// {\n// constructor: f Object(),\n// toString: ...\n// hasOwnProperty: ...\n// isPrototypeOf: ...\n// ...\n// }\nlet person1 = new Person(),\nperson2 = new Person();\n/**\n * 构造函数、原型对象和实例\n * 是3 个完全不同的对象：\n */\nconsole.log(person1 !== Person); // true\nconsole.log(person1 !== Person.prototype); // true\nconsole.log(Person.prototype !== Person); // true\n/**\n * 实例通过__proto__链接到原型对象，\n * 它实际上指向隐藏特性[[Prototype]]\n *\n * 构造函数通过prototype 属性链接到原型对象\n *\n * 实例与构造函数没有直接联系，与原型对象有直接联系\n */\nconsole.log(person1.__proto__ === Person.prototype); // true\nconosle.log(person1.__proto__.constructor === Person); // true\n/**\n * 同一个构造函数创建的两个实例\n * 共享同一个原型对象：\n */\nconsole.log(person1.__proto__ === person2.__proto__); // true\n/**\n * instanceof 检查实例的原型链中\n * 是否包含指定构造函数的原型：\n */\nconsole.log(person1 instanceof Person); // true\nconsole.log(person1 instanceof Object); // true\nconsole.log(Person.prototype instanceof Object); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n\nObject 类型还有一个setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系：\n\nlet biped = {\n  numLegs: 2\n};\nlet person = {\n  name: \'Matt\'\n};\nObject.setPrototypeOf(person, biped);\nconsole.log(person.name); // Matt\nconsole.log(person.numLegs); // 2\nconsole.log(Object.getPrototypeOf(person) === biped); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意\n\nObject.setPrototypeOf() 可能会严重影响代码性能。Mozilla 文档说得很清楚：“在所有浏览器和JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行Object.setPrototypeOf()语句那么简单，而是会涉及所有访问了那些修改过[[Prototype]]的对象的代码。”\n\n为避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：\n\nlet biped = {\n  numLegs: 2\n};\nlet person = Object.create(biped);\nperson.name = \'Matt\';\nconsole.log(person.name); // Matt\nconsole.log(person.numLegs); // 2\nconsole.log(Object.getPrototypeOf(person) === biped); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n笔记\n\n如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyNames()\n\nObject.keys()和Object.getOwnPropertyNames()在适当的时候都可用来代替for-in 循环。\n\n在ECMAScript 6 新增符号类型之后，相应地出现了增加一个Object.getOwnPropertyNames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，Object.getOwnProperty-Symbols()方法就出现了，这个方法与Object.getOwnPropertyNames()类似，只是针对符号而已。\n\nfor-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnProperty-Symbols()以及Object.assign()在属性枚举顺序方面有很大区别。for-in 循环和Object.keys()的枚举顺序是不确定的，取决于JavaScript 引擎，可能因浏览器而异。\n\n笔记\n\n因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。\n\n重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。\n\nfunction Person() {}\nlet friend = new Person();\nPerson.prototype = {\n  constructor: Person,\n  name: "Nicholas",\n  age: 29,\n  job: "Software Engineer",\n  sayName() {\n    console.log(this.name);\n  }\n};\nfriend.sayName(); // 错误\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 原型的问题\n\n 1. 它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值\n 2. 最主要问题源自它的共享特性。\n\n提示\n\n一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。\n\n\n# 继承\n\n提示\n\n继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript 中是不可能的，因为函数没有签名。实现继承是ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。\n\n\n# 原型链\n\n提示\n\n每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例，意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数，这就是原型链。\n\n笔记\n\n确认原型的两种方式：instanceof 和 Object.isPrototypeOf 方法\n\n通过对象字面量添加新方法会导致覆盖后的原型是 Object 的实例，而不是原先原型的实例。\n\n# 原型链的问题\n\n提示\n\n原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。\n\n原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。\n\n\n# 盗用构造函数\n\n在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。\n\nfunction SuperType() {\n  this.colors = [\'red\', \'blue\', \'green\']\n}\n\nfunction SubType() {\n  // 继承 SuperType\n  SuperType.call(this)\n}\n\nlet instance1 = new SubType()\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\nlet instance2 = new SubType();\nconsole.log(instance2.colors); // "red,blue,green"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n示例中加粗的代码展示了盗用构造函数的调用。通过使用call()（或apply()）方法，SuperType构造函数在为SubType 的实例创建的新对象的上下文中执行了。这相当于新的SubType 对象上运行了SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的colors 属性。\n\n相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。\n\nfunction SuperType(name) {\n  this.name = name\n}\n\nfunction SubType() {\n  // 继承 SuperType 并传参\n  SuperType.call(this, "Nicholas")\n  // 实例属性\n  this.age = 29\n}\n\nlet instance = new SubType()\nconsole.log(instance.name) // "Nicholas"\nconsole.log(instance.age) // 29\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n盗用构造函数的主要缺点：必须在构造函数中定义方法，这样函数复用就无从谈起了。而且子类也不能访问父类原型上定义的方法。\n\n\n# 组合继承\n\n组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n\nfunction SuperType(name){\n  this.name = name;\n  this.colors = ["red", "blue", "green"];\n}\nSuperType.prototype.sayName = function() {\n  console.log(this.name);\n};\nfunction SubType(name, age){\n  // 继承属性\n  SuperType.call(this, name);\n  this.age = age;\n}\n// 继承方法\nSubType.prototype = new SuperType();\nSubType.prototype.sayAge = function() {\n  console.log(this.age);\n};\nlet instance1 = new SubType("Nicholas", 29);\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\ninstance1.sayName(); // "Nicholas";\ninstance1.sayAge(); // 29\nlet instance2 = new SubType("Greg", 27);\nconsole.log(instance2.colors); // "red,blue,green"\ninstance2.sayName(); // "Greg";\ninstance2.sayAge(); // 27\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n组合继承弥补了原型链和盗用构造函数的不足，是JavaScript 中使用最多的继承模式。而且组合继承也保留了instanceof 操作符和isPrototypeOf()方法识别合成对象的能力。\n\n\n# 原型式继承\n\n提示\n\n2006 年，Douglas Crockford 写了一篇文章：《JavaScript 中的原型式继承》（“Prototypal Inheritance inJavaScript”）。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。\n\n这个object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。\n\nlet person = {\n  name: "Nicholas",\n  friends: ["Shelby", "Court", "Van"]\n};\nlet anotherPerson = object(person);\nanotherPerson.name = "Greg";\nanotherPerson.friends.push("Rob");\nlet yetAnotherPerson = object(person);\nyetAnotherPerson.name = "Linda";\nyetAnotherPerson.friends.push("Barbie");\nconsole.log(person.friends); // "Shelby,Court,Van,Rob,Barbie"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nCrockford 推荐的原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给object()，然后再对返回的对象进行适当修改。在这个例子中，person 对象定义了另一个对象也应该共享的信息，把它传给object()之后会返回一个新对象。这个新对象的原型是person，意味着它的原型上既有原始值属性又有引用值属性。这也意味着person.friends 不仅是person 的属性，也会跟anotherPerson 和yetAnotherPerson 共享。这里实际上克隆了两个person。\n\nECMAScript 5 通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。\n\nECMAScript 5 通过增加Object.create()方法将原型式继承的概念规范化了。\n\nObject.create()的第二个参数与Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。\n\n提示\n\n原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。\n\n\n# 寄生式继承\n\n与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是Crockford 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下\n\nfunction createAnother(original){\n  let clone = object(original); // 通过调用函数创建一个新对象\n  clone.sayHi = function() { // 以某种方式增强这个对象\n    console.log("hi");\n  };\n  return clone; // 返回这个对象\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。\n\n\n# 寄生组合继承\n\n组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。\n\n寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。\n\n寄生式组合继承的基本模式如下所示：\n\nfunction inheritPrototype(subType, superType) {\n  let prototype = Object.create(superType.prototype); // 创建对象\n  prototype.constructor = subType; // 增强对象\n  subType.prototype = prototype; // 赋值对象\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个inheritPrototype()函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype 对象设置constructor 属性，解决由于重写原型导致默认constructor 丢失的问题。最后将新创建的对象赋值给子类型的原型。\n\n寄生式组合继承可以算是引用类型继承的最佳模式。\n\n\n# 类\n\n类（class）是ECMAScript 中新的基础性语法糖结构，因此刚开始接触时可能会不太习惯。虽然ECMAScript 6 类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。\n\n\n# 类的构成\n\n类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。\n\n与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例\n\n类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。\n\nlet Person = class PersonName {\n  identify() {\n    console.log(Person.name, PersonName.name);\n  }\n}\nlet p = new Person();\np.identify(); // PersonName PersonName\nconsole.log(Person.name); // PersonName\nconsole.log(PersonName); // ReferenceError: PersonName is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 类的实例化\n\n使用new 调用类的构造函数会执行如下操作。\n\n(1) 在内存中创建一个新对象。 (2) 这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype 属性。 (3) 构造函数内部的this 被赋值为这个新对象（即this 指向新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。\n\n如果返回的不是this 对象，而是其他对象，那么这个对象不会通过instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。\n\n提示\n\n类构造函数与构造函数的主要区别是，调用类构造函数必须使用new 操作符。而普通构造函数如果不使用new 调用，那么就会以全局的this（通常是window）作为内部对象。\n\n类本身具有与普通构造函数一样的行为。在类的上下文中，类本身在使用new 调用时就会被当成构造函数。重点在于，类中定义的constructor 方法不会被当成构造函数，在对它使用instanceof 操作符时会返回false。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof 操作符的返回值会反转。\n\nclass Person {}\nlet p1 = new Person();\nconsole.log(p1.constructor === Person); // true\nconsole.log(p1 instanceof Person); // true\nconsole.log(p1 instanceof Person.constructor); // false\nlet p2 = new Person.constructor();\nconsole.log(p2.constructor === Person); // false\nconsole.log(p2 instanceof Person); // false\nconsole.log(p2 instanceof Person.constructor); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n笔记\n\n类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键\n\n类定义也支持获取和设置访问器。语法与行为跟普通对象一样\n\n可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。\n\n# 非函数原型和类成员\n\n虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加\n\nclass Person {\n  sayName() {\n    console.log(`${Person.greeting} ${this.name}`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 迭代器与生成器方法\n\n类定义语法支持在原型和类本身上定义生成器方法：\n\nclass Person {\n  // 在原型上定义生成器方法\n  *createNicknameIterator() {\n    yield \'Jack\';\n    yield \'Jake\';\n    yield \'J-Dog\';\n  }\n  // 在类上定义生成器方法\n  static *createJobIterator() {\n    yield \'Butcher\';\n    yield \'Baker\';\n    yield \'Candlestick maker\';\n  }\n}\nlet jobIter = Person.createJobIterator();\nconsole.log(jobIter.next().value); // Butcher\nconsole.log(jobIter.next().value); // Baker\nconsole.log(jobIter.next().value); // Candlestick maker\nlet p = new Person();\nlet nicknameIter = p.createNicknameIterator();\nconsole.log(nicknameIter.next().value); // Jack\nconsole.log(nicknameIter.next().value); // Jake\nconsole.log(nicknameIter.next().value); // J-Dog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象：\n\nclass Person {\n  constructor() {\n    this.nicknames = [\'Jack\', \'Jake\', \'J-Dog\'];\n  }\n  *[Symbol.iterator]() {\n    yield *this.nicknames.entries();\n  }\n}\nlet p = new Person();\nfor (let [idx, nickname] of p) {\n  console.log(nickname);\n}\n// Jack\n// Jake\n// J-Dog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n也可以只返回迭代器实例：\n\nclass Person {\n  constructor() {\n    this.nicknames = [\'Jack\', \'Jake\', \'J-Dog\'];\n  }\n  [Symbol.iterator]() {\n    return this.nicknames.entries();\n  }\n}\nlet p = new Person();\nfor (let [idx, nickname] of p) {\n  console.log(nickname);\n}\n// Jack\n// Jake\n// J-Dog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 类的继承\n\n# 构造函数、HomeObject和 super()\n\n派生类的方法可以通过super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super 可以调用父类构造函数。\n\n注意\n\n不要在调用super()之前引用this，否则会抛出ReferenceError\n\n在静态方法中可以通过super 调用继承的类上定义的静态方法\n\nclass Vehicle {\n  static identify() {\n    console.log(\'vehicle\');\n  }\n}\nclass Bus extends Vehicle {\n  static identify() {\n    super.identify();\n  }\n}\nBus.identify(); // vehicle\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用super的注意事项\n\n * super 只能在派生类构造函数和静态方法中使用\n * 不能单独引用super关键字，要么用super调用构造函数，要么用super引用静态方法\n * 调用super会调用父类构造函数，并将返回的实例赋值给this\n * super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入\n * 如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数\n * 在类构造函数中，不能再调用super之前引用this\n * 如果再派生类中显式定义了构造函数，则要么必须再其中调用super，要么在其中返回一个对象。\n\n# 抽象基类\n\n有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然ECMAScript 没有专门支持这种类的语法 ，但通过new.target 也很容易实现。new.target 保存通过new 关键字调用的类或函数。通过在实例化时检测new.target 是不是抽象基类，可以阻止对抽象基类的实例化。\n\n另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this 关键字来检查相应的方法。\n\n笔记\n\nES6 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型\n\n# 类混入\n\n把不同类的行为集中到一个类是一种常见的JavaScript 模式。虽然ES6 没有显式支持多类继承，但通过现有特性可以轻松地模拟这种行为。\n\n提示\n\nObject.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用Object.assign()就可以了。\n\n一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式。通过写一个辅助函数，可以把嵌套调用展开。\n\nclass Vehicle {}\nlet FooMixin = (Superclass) => class extends Superclass {\n  foo() {\n    console.log(\'foo\');\n  }\n};\nlet BarMixin = (Superclass) => class extends Superclass {\n  bar() {\n    console.log(\'bar\');\n  }\n};\nlet BazMixin = (Superclass) => class extends Superclass {\n  baz() {\n    console.log(\'baz\');\n  }\n};\nfunction mix(BaseClass, ...Mixins) {\n  return Mixins.reduce((accumulator, current) => current(accumulator), BaseClass);\n}\nclass Bus extends mix(Vehicle, FooMixin, BarMixin, BazMixin) {}\nlet b = new Bus();\nb.foo(); // foo\nb.bar(); // bar\nb.baz(); // baz\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n提示\n\n很多JavaScript 框架（特别是React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。',normalizedContent:'# 理解对象\n\n\n# 属性类型\n\n# 数据类型\n\n数据有四种类型，configurable、enumerable、writable、value\n\n使用 object.defineproperty 可以修改默认属性类型\n\n访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4 个特性描述它们的行为。\n\nconfigurable表示是否可以通过 delete 删除并重新定义，默认为true\n\nenumerable表示是否可以通过 for-in 循环返回属性，默认为true\n\nwritable表示是否可以修改属性的值，默认为true\n\nvalue表示属性的值，默认为undefined\n\n访问器属性是不能直接定义的，必须使用object.defineproperty()。下面是一个例子：\n\nlet book = {\n    _year: 2004,\n    edition: 1\n};\n\nobject.defineproperty(book, "year", {\n    get: function() {\n        return this._year;\n    },\n    set: function(newvalue) {\n        if (newvalue > 2004) {\n            this._year = newvalue;\n            this.edition += newvalue - 2004;\n        }\n    }\n});\n\nbook.year = 2005;\nalert(book.edition); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n笔记\n\n在ecmascript 5 以前，开发者会使用两个非标准的访问创建访问器属性：__define-getter__()和__definesetter__()。这两个方法最早是firefox 引入的，后来safari、chrome 和opera 也实现了。\n\n\n# 定义多个属性\n\nobject.defineproperties()方法可以定义多个属性\n\nlet book = {};\n\nobject.defineproperties(book, {\n    _year: {\n        value: 2004\n    },\n    edition: {\n        value: 1\n    },\n    year: {\n        get: function() {\n            return this._year;\n        },\n        set: function(newvalue) {\n            if (newvalue > 2004) {\n                this._year = newvalue;\n                this.edition += newvalue - 2004;\n            }\n        }\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 读取属性的特性\n\n使用 object.getownpropertydescriptor() 方法可以读取属性的属性描述符\n\necmascript 2017 新增了object.getownpropertydescriptors()静态方法。这个方法实际上会在每个自有属性上调用object.getownpropertydescriptor()并在一个新对象中返回它们。\n\n\n# 合并对象\n\nobject.assign()方法用于将所有可枚举的自有属性从一个或多个源对象复制到目标对象。它将返回目标对象。\n\nobject.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。\n\n\n# 对象标识及相等判定\n\n在ecmascript 6 之前，有些特殊情况即使是===操作符也无能为力：\n\n// 这些是===符合预期的情况\nconsole.log(true === 1); // false\nconsole.log({} === {}); // false\nconsole.log("2" === 2); // false\n// 这些情况在不同javascript 引擎中表现不同，但仍被认为相等\nconsole.log(+0 === -0); // true\nconsole.log(+0 === 0); // true\nconsole.log(-0 === 0); // true\n// 要确定nan 的相等性，必须使用极为讨厌的isnan()\nconsole.log(nan === nan); // false\nconsole.log(isnan(nan)); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为改善这类情况，ecmascript 6 规范新增了object.is()，这个方法与===很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：\n\nconsole.log(object.is(true, 1)); // false\nconsole.log(object.is({}, {})); // false\nconsole.log(object.is("2", 2)); // false\n// 正确的0、-0、+0 相等/不等判定\nconsole.log(object.is(+0, -0)); // false\nconsole.log(object.is(+0, 0)); // true\nconsole.log(object.is(-0, 0)); // false\n// 正确的nan 相等判定\nconsole.log(object.is(nan, nan)); // true\n// 要检查超过两个值，递归地利用相等性传递即可：\nfunction recursivelycheckequal(x, ...rest) {\n  return object.is(x, rest[0]) &&\n    (rest.length < 2 || recursivelycheckequal(...rest));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 增强的属性语法\n\n# 属性简写\n\n在属性名和变量名一致的时候，可以不用写两次\n\n# 可计算属性\n\n用[]包裹属性名，可以动态计算属性名\n\n注意\n\n可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。\n\n# 简写方法名\n\n不需要使用 object = { key: [function] } 这种形式，可以直接使用 object = { key() { } } 这种形式\n\n\n# 对象解构\n\n可以使用对象解构语法从对象中进行嵌套解构、部分解构、对函数参数进行解构\n\n\n# 创建对象\n\n\n# 工厂模式创建\n\n使用函数方式，通过new一个object并声明属性来批量创建对象。\n\n缺点：没有解决对象标识类型\n\nfunction createperson(name, age, job) {\n    var o = new object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayname = function() {\n        console.log(this.name);\n    };\n    return o;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 构造函数模式\n\n自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。\n\nfunction person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.sayname = function() {\n    console.log(this.name);\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n笔记\n\n按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在ecmascript 中区分构造函数和普通函数。毕竟ecmascript 的构造函数就是能创建对象的函数。\n\n通过构造函数创建实例会执行如下操作：\n\n * 在内存中创建一个新对象\n * 这个新对象内部的 [[prototype]] 特性被赋值为构造函数的 prototype 属性\n * 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）\n * 执行构造函数内部的代码（给新对象添加属性）\n * 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象\n\n笔记\n\n在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加\n\n# 构造函数也是函数\n\n笔记\n\n构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用new 操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数。\n\n# 构造函数的问题\n\n笔记\n\n构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。\n\n\n# 原型模式\n\n笔记\n\n使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型\n\n# 理解原型\n\n/**\n * 构造函数可以是函数表达式\n * 也可以是函数声明，因此以下两种形式都可以：\n * function person() {}\n * let person = function() {}\n */\nfunction person() {}\n/**\n * 声明之后，构造函数就有了一个\n * 与之关联的原型对象：\n */\nconsole.log(typeof person.prototype);\nconsole.log(person.prototype);\n// {\n// constructor: f person(),\n// __proto__: object\n// }\n/**\n * 如前所述，构造函数有一个prototype 属性\n * 引用其原型对象，而这个原型对象也有一个\n * constructor 属性，引用这个构造函数\n * 换句话说，两者循环引用：\n */\nconsole.log(person.prototype.constructor === person); // true\n/**\n * 正常的原型链都会终止于object 的原型对象\n * object 原型的原型是null\n */\nconsole.log(person.prototype.__proto__ === object.prototype); // true\nconsole.log(person.prototype.__proto__.constructor === object); // true\nconsole.log(person.prototype.__proto__.__proto__ === null); // true\nconsole.log(person.prototype.__proto__);\n// {\n// constructor: f object(),\n// tostring: ...\n// hasownproperty: ...\n// isprototypeof: ...\n// ...\n// }\nlet person1 = new person(),\nperson2 = new person();\n/**\n * 构造函数、原型对象和实例\n * 是3 个完全不同的对象：\n */\nconsole.log(person1 !== person); // true\nconsole.log(person1 !== person.prototype); // true\nconsole.log(person.prototype !== person); // true\n/**\n * 实例通过__proto__链接到原型对象，\n * 它实际上指向隐藏特性[[prototype]]\n *\n * 构造函数通过prototype 属性链接到原型对象\n *\n * 实例与构造函数没有直接联系，与原型对象有直接联系\n */\nconsole.log(person1.__proto__ === person.prototype); // true\nconosle.log(person1.__proto__.constructor === person); // true\n/**\n * 同一个构造函数创建的两个实例\n * 共享同一个原型对象：\n */\nconsole.log(person1.__proto__ === person2.__proto__); // true\n/**\n * instanceof 检查实例的原型链中\n * 是否包含指定构造函数的原型：\n */\nconsole.log(person1 instanceof person); // true\nconsole.log(person1 instanceof object); // true\nconsole.log(person.prototype instanceof object); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n\nobject 类型还有一个setprototypeof()方法，可以向实例的私有特性[[prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系：\n\nlet biped = {\n  numlegs: 2\n};\nlet person = {\n  name: \'matt\'\n};\nobject.setprototypeof(person, biped);\nconsole.log(person.name); // matt\nconsole.log(person.numlegs); // 2\nconsole.log(object.getprototypeof(person) === biped); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n注意\n\nobject.setprototypeof() 可能会严重影响代码性能。mozilla 文档说得很清楚：“在所有浏览器和javascript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行object.setprototypeof()语句那么简单，而是会涉及所有访问了那些修改过[[prototype]]的对象的代码。”\n\n为避免使用object.setprototypeof()可能造成的性能下降，可以通过object.create()来创建一个新对象，同时为其指定原型：\n\nlet biped = {\n  numlegs: 2\n};\nlet person = object.create(biped);\nperson.name = \'matt\';\nconsole.log(person.name); // matt\nconsole.log(person.numlegs); // 2\nconsole.log(object.getprototypeof(person) === biped); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n笔记\n\n如果想列出所有实例属性，无论是否可以枚举，都可以使用object.getownpropertynames()\n\nobject.keys()和object.getownpropertynames()在适当的时候都可用来代替for-in 循环。\n\n在ecmascript 6 新增符号类型之后，相应地出现了增加一个object.getownpropertynames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，object.getownproperty-symbols()方法就出现了，这个方法与object.getownpropertynames()类似，只是针对符号而已。\n\nfor-in 循环、object.keys()、object.getownpropertynames()、object.getownproperty-symbols()以及object.assign()在属性枚举顺序方面有很大区别。for-in 循环和object.keys()的枚举顺序是不确定的，取决于javascript 引擎，可能因浏览器而异。\n\n笔记\n\n因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。\n\n重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。\n\nfunction person() {}\nlet friend = new person();\nperson.prototype = {\n  constructor: person,\n  name: "nicholas",\n  age: 29,\n  job: "software engineer",\n  sayname() {\n    console.log(this.name);\n  }\n};\nfriend.sayname(); // 错误\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 原型的问题\n\n 1. 它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值\n 2. 最主要问题源自它的共享特性。\n\n提示\n\n一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。\n\n\n# 继承\n\n提示\n\n继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ecmascript 中是不可能的，因为函数没有签名。实现继承是ecmascript 唯一支持的继承方式，而这主要是通过原型链实现的。\n\n\n# 原型链\n\n提示\n\n每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例，意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数，这就是原型链。\n\n笔记\n\n确认原型的两种方式：instanceof 和 object.isprototypeof 方法\n\n通过对象字面量添加新方法会导致覆盖后的原型是 object 的实例，而不是原先原型的实例。\n\n# 原型链的问题\n\n提示\n\n原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。\n\n原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。\n\n\n# 盗用构造函数\n\n在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。\n\nfunction supertype() {\n  this.colors = [\'red\', \'blue\', \'green\']\n}\n\nfunction subtype() {\n  // 继承 supertype\n  supertype.call(this)\n}\n\nlet instance1 = new subtype()\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\nlet instance2 = new subtype();\nconsole.log(instance2.colors); // "red,blue,green"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n示例中加粗的代码展示了盗用构造函数的调用。通过使用call()（或apply()）方法，supertype构造函数在为subtype 的实例创建的新对象的上下文中执行了。这相当于新的subtype 对象上运行了supertype()函数中的所有初始化代码。结果就是每个实例都会有自己的colors 属性。\n\n相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。\n\nfunction supertype(name) {\n  this.name = name\n}\n\nfunction subtype() {\n  // 继承 supertype 并传参\n  supertype.call(this, "nicholas")\n  // 实例属性\n  this.age = 29\n}\n\nlet instance = new subtype()\nconsole.log(instance.name) // "nicholas"\nconsole.log(instance.age) // 29\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n盗用构造函数的主要缺点：必须在构造函数中定义方法，这样函数复用就无从谈起了。而且子类也不能访问父类原型上定义的方法。\n\n\n# 组合继承\n\n组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。\n\nfunction supertype(name){\n  this.name = name;\n  this.colors = ["red", "blue", "green"];\n}\nsupertype.prototype.sayname = function() {\n  console.log(this.name);\n};\nfunction subtype(name, age){\n  // 继承属性\n  supertype.call(this, name);\n  this.age = age;\n}\n// 继承方法\nsubtype.prototype = new supertype();\nsubtype.prototype.sayage = function() {\n  console.log(this.age);\n};\nlet instance1 = new subtype("nicholas", 29);\ninstance1.colors.push("black");\nconsole.log(instance1.colors); // "red,blue,green,black"\ninstance1.sayname(); // "nicholas";\ninstance1.sayage(); // 29\nlet instance2 = new subtype("greg", 27);\nconsole.log(instance2.colors); // "red,blue,green"\ninstance2.sayname(); // "greg";\ninstance2.sayage(); // 27\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n组合继承弥补了原型链和盗用构造函数的不足，是javascript 中使用最多的继承模式。而且组合继承也保留了instanceof 操作符和isprototypeof()方法识别合成对象的能力。\n\n\n# 原型式继承\n\n提示\n\n2006 年，douglas crockford 写了一篇文章：《javascript 中的原型式继承》（“prototypal inheritance injavascript”）。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。\n\n这个object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。\n\nlet person = {\n  name: "nicholas",\n  friends: ["shelby", "court", "van"]\n};\nlet anotherperson = object(person);\nanotherperson.name = "greg";\nanotherperson.friends.push("rob");\nlet yetanotherperson = object(person);\nyetanotherperson.name = "linda";\nyetanotherperson.friends.push("barbie");\nconsole.log(person.friends); // "shelby,court,van,rob,barbie"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ncrockford 推荐的原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给object()，然后再对返回的对象进行适当修改。在这个例子中，person 对象定义了另一个对象也应该共享的信息，把它传给object()之后会返回一个新对象。这个新对象的原型是person，意味着它的原型上既有原始值属性又有引用值属性。这也意味着person.friends 不仅是person 的属性，也会跟anotherperson 和yetanotherperson 共享。这里实际上克隆了两个person。\n\necmascript 5 通过增加object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。\n\necmascript 5 通过增加object.create()方法将原型式继承的概念规范化了。\n\nobject.create()的第二个参数与object.defineproperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。\n\n提示\n\n原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。\n\n\n# 寄生式继承\n\n与原型式继承比较接近的一种继承方式是寄生式继承（parasitic inheritance），也是crockford 首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下\n\nfunction createanother(original){\n  let clone = object(original); // 通过调用函数创建一个新对象\n  clone.sayhi = function() { // 以某种方式增强这个对象\n    console.log("hi");\n  };\n  return clone; // 返回这个对象\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。\n\n\n# 寄生组合继承\n\n组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。\n\n寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。\n\n寄生式组合继承的基本模式如下所示：\n\nfunction inheritprototype(subtype, supertype) {\n  let prototype = object.create(supertype.prototype); // 创建对象\n  prototype.constructor = subtype; // 增强对象\n  subtype.prototype = prototype; // 赋值对象\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个inheritprototype()函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype 对象设置constructor 属性，解决由于重写原型导致默认constructor 丢失的问题。最后将新创建的对象赋值给子类型的原型。\n\n寄生式组合继承可以算是引用类型继承的最佳模式。\n\n\n# 类\n\n类（class）是ecmascript 中新的基础性语法糖结构，因此刚开始接触时可能会不太习惯。虽然ecmascript 6 类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。\n\n\n# 类的构成\n\n类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。\n\n与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例\n\n类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。\n\nlet person = class personname {\n  identify() {\n    console.log(person.name, personname.name);\n  }\n}\nlet p = new person();\np.identify(); // personname personname\nconsole.log(person.name); // personname\nconsole.log(personname); // referenceerror: personname is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 类的实例化\n\n使用new 调用类的构造函数会执行如下操作。\n\n(1) 在内存中创建一个新对象。 (2) 这个新对象内部的[[prototype]]指针被赋值为构造函数的prototype 属性。 (3) 构造函数内部的this 被赋值为这个新对象（即this 指向新对象）。 (4) 执行构造函数内部的代码（给新对象添加属性）。 (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。\n\n如果返回的不是this 对象，而是其他对象，那么这个对象不会通过instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。\n\n提示\n\n类构造函数与构造函数的主要区别是，调用类构造函数必须使用new 操作符。而普通构造函数如果不使用new 调用，那么就会以全局的this（通常是window）作为内部对象。\n\n类本身具有与普通构造函数一样的行为。在类的上下文中，类本身在使用new 调用时就会被当成构造函数。重点在于，类中定义的constructor 方法不会被当成构造函数，在对它使用instanceof 操作符时会返回false。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么instanceof 操作符的返回值会反转。\n\nclass person {}\nlet p1 = new person();\nconsole.log(p1.constructor === person); // true\nconsole.log(p1 instanceof person); // true\nconsole.log(p1 instanceof person.constructor); // false\nlet p2 = new person.constructor();\nconsole.log(p2.constructor === person); // false\nconsole.log(p2 instanceof person); // false\nconsole.log(p2 instanceof person.constructor); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n笔记\n\n类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键\n\n类定义也支持获取和设置访问器。语法与行为跟普通对象一样\n\n可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。\n\n# 非函数原型和类成员\n\n虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加\n\nclass person {\n  sayname() {\n    console.log(`${person.greeting} ${this.name}`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 迭代器与生成器方法\n\n类定义语法支持在原型和类本身上定义生成器方法：\n\nclass person {\n  // 在原型上定义生成器方法\n  *createnicknameiterator() {\n    yield \'jack\';\n    yield \'jake\';\n    yield \'j-dog\';\n  }\n  // 在类上定义生成器方法\n  static *createjobiterator() {\n    yield \'butcher\';\n    yield \'baker\';\n    yield \'candlestick maker\';\n  }\n}\nlet jobiter = person.createjobiterator();\nconsole.log(jobiter.next().value); // butcher\nconsole.log(jobiter.next().value); // baker\nconsole.log(jobiter.next().value); // candlestick maker\nlet p = new person();\nlet nicknameiter = p.createnicknameiterator();\nconsole.log(nicknameiter.next().value); // jack\nconsole.log(nicknameiter.next().value); // jake\nconsole.log(nicknameiter.next().value); // j-dog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象：\n\nclass person {\n  constructor() {\n    this.nicknames = [\'jack\', \'jake\', \'j-dog\'];\n  }\n  *[symbol.iterator]() {\n    yield *this.nicknames.entries();\n  }\n}\nlet p = new person();\nfor (let [idx, nickname] of p) {\n  console.log(nickname);\n}\n// jack\n// jake\n// j-dog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n也可以只返回迭代器实例：\n\nclass person {\n  constructor() {\n    this.nicknames = [\'jack\', \'jake\', \'j-dog\'];\n  }\n  [symbol.iterator]() {\n    return this.nicknames.entries();\n  }\n}\nlet p = new person();\nfor (let [idx, nickname] of p) {\n  console.log(nickname);\n}\n// jack\n// jake\n// j-dog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 类的继承\n\n# 构造函数、homeobject和 super()\n\n派生类的方法可以通过super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super 可以调用父类构造函数。\n\n注意\n\n不要在调用super()之前引用this，否则会抛出referenceerror\n\n在静态方法中可以通过super 调用继承的类上定义的静态方法\n\nclass vehicle {\n  static identify() {\n    console.log(\'vehicle\');\n  }\n}\nclass bus extends vehicle {\n  static identify() {\n    super.identify();\n  }\n}\nbus.identify(); // vehicle\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用super的注意事项\n\n * super 只能在派生类构造函数和静态方法中使用\n * 不能单独引用super关键字，要么用super调用构造函数，要么用super引用静态方法\n * 调用super会调用父类构造函数，并将返回的实例赋值给this\n * super的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入\n * 如果没有定义类构造函数，在实例化派生类时会调用super，而且会传入所有传给派生类的参数\n * 在类构造函数中，不能再调用super之前引用this\n * 如果再派生类中显式定义了构造函数，则要么必须再其中调用super，要么在其中返回一个对象。\n\n# 抽象基类\n\n有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然ecmascript 没有专门支持这种类的语法 ，但通过new.target 也很容易实现。new.target 保存通过new 关键字调用的类或函数。通过在实例化时检测new.target 是不是抽象基类，可以阻止对抽象基类的实例化。\n\n另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过this 关键字来检查相应的方法。\n\n笔记\n\nes6 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型\n\n# 类混入\n\n把不同类的行为集中到一个类是一种常见的javascript 模式。虽然es6 没有显式支持多类继承，但通过现有特性可以轻松地模拟这种行为。\n\n提示\n\nobject.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用object.assign()就可以了。\n\n一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式。通过写一个辅助函数，可以把嵌套调用展开。\n\nclass vehicle {}\nlet foomixin = (superclass) => class extends superclass {\n  foo() {\n    console.log(\'foo\');\n  }\n};\nlet barmixin = (superclass) => class extends superclass {\n  bar() {\n    console.log(\'bar\');\n  }\n};\nlet bazmixin = (superclass) => class extends superclass {\n  baz() {\n    console.log(\'baz\');\n  }\n};\nfunction mix(baseclass, ...mixins) {\n  return mixins.reduce((accumulator, current) => current(accumulator), baseclass);\n}\nclass bus extends mix(vehicle, foomixin, barmixin, bazmixin) {}\nlet b = new bus();\nb.foo(); // foo\nb.bar(); // bar\nb.baz(); // baz\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n提示\n\n很多javascript 框架（特别是react）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。',charsets:{cjk:!0},lastUpdated:"2024/08/30, 17:20:05",lastUpdatedTimestamp:1725009605e3},{title:"迭代器与生成器",frontmatter:{title:"迭代器与生成器",date:"2024-08-27T16:55:10.000Z",permalink:"/pages/e9a165/",categories:["前端","JavaScript高级程序设计"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/09.%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8.html",relativePath:"01.前端/03.JavaScript高级程序设计/09.迭代器与生成器.md",key:"v-50d25313",path:"/pages/e9a165/",headers:[{level:2,title:"迭代器",slug:"迭代器",normalizedTitle:"迭代器",charIndex:2},{level:3,title:"迭代器模式",slug:"迭代器模式",normalizedTitle:"迭代器模式",charIndex:10},{level:3,title:"迭代器协议",slug:"迭代器协议",normalizedTitle:"迭代器协议",charIndex:315},{level:3,title:"自定义迭代器",slug:"自定义迭代器",normalizedTitle:"自定义迭代器",charIndex:1525},{level:3,title:"提前终止迭代器",slug:"提前终止迭代器",normalizedTitle:"提前终止迭代器",charIndex:2889},{level:2,title:"生成器",slug:"生成器",normalizedTitle:"生成器",charIndex:255},{level:3,title:"生成器对象作为可迭代对象",slug:"生成器对象作为可迭代对象",normalizedTitle:"生成器对象作为可迭代对象",charIndex:5255},{level:3,title:"使用 yield 实现输入输出",slug:"使用-yield-实现输入输出",normalizedTitle:"使用 yield 实现输入输出",charIndex:5487},{level:3,title:"产生可迭代对象",slug:"产生可迭代对象",normalizedTitle:"产生可迭代对象",charIndex:5921},{level:3,title:"使用 yield*实现递归算法",slug:"使用-yield-实现递归算法",normalizedTitle:"使用 yield*实现递归算法",charIndex:6275},{level:3,title:"生成器作为默认迭代器",slug:"生成器作为默认迭代器",normalizedTitle:"生成器作为默认迭代器",charIndex:8569},{level:3,title:"提前终止生成器",slug:"提前终止生成器",normalizedTitle:"提前终止生成器",charIndex:8922}],headersStr:"迭代器 迭代器模式 迭代器协议 自定义迭代器 提前终止迭代器 生成器 生成器对象作为可迭代对象 使用 yield 实现输入输出 产生可迭代对象 使用 yield*实现递归算法 生成器作为默认迭代器 提前终止生成器",content:"# 迭代器\n\n\n# 迭代器模式\n\n笔记\n\n迭代器模式（特别是在ECMAScript 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的Iterable 接口，而且可以通过迭代器Iterator 消费。可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序。\n\n不过，可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构。\n\n临时性可迭代对象可以实现为生成器，本章后面会讨论。\n\n如果对象原型链上的父类实现了Iterable 接口，那这个对象也就实现了这个接口：\n\n\n# 迭代器协议\n\n笔记\n\n迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器API 使用next()方法在可迭代对象中遍历数据。每次成功调用next()，都会返回一个IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用next()，则无法知道迭代器的当前位置。\n\nnext()方法返回的迭代器对象IteratorResult 包含两个属性：done 和value。done 是一个布尔值，表示是否还可以再次调用next()取得下一个值；value 包含可迭代对象的下一个值（done 为false），或者undefined（done 为true）。done: true 状态称为“耗尽”。\n\n每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独 立地遍历可迭代对象：\n\nlet arr = ['foo', 'bar'];\nlet iter1 = arr[Symbol.iterator]();\nlet iter2 = arr[Symbol.iterator]();\nconsole.log(iter1.next()); // { done: false, value: 'foo' }\nconsole.log(iter2.next()); // { done: false, value: 'foo' }\nconsole.log(iter2.next()); // { done: false, value: 'bar' }\nconsole.log(iter1.next()); // { done: false, value: 'bar' }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：\n\nlet arr = ['foo', 'baz'];\nlet iter = arr[Symbol.iterator]();\nconsole.log(iter.next()); // { done: false, value: 'foo' }\n// 在数组中间插入值\narr.splice(1, 0, 'bar');\nconsole.log(iter.next()); // { done: false, value: 'bar' }\nconsole.log(iter.next()); // { done: false, value: 'baz' }\nconsole.log(iter.next()); // { done: true, value: undefined }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示\n\n迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。\n\n\n# 自定义迭代器\n\n与Iterable 接口类似，任何实现Iterator 接口的对象都可以作为迭代器使用。下面这个例子中的Counter 类只能被迭代一定的次数：\n\nclass Counter {\n  // Counter 的实例应该被迭代 limit 次\n  constructor(limit) {\n    this.count = 1\n    this.limit = limit\n  }\n\n  next() {\n    if (this.count <= this.limit) {\n      return { done: false, value: this.count++ }\n    } else {\n      return { done: true, value: undefined }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this\n  }\n}\nlet counter = new Counter(3)\nfor (let i of counter) {\n  console.log(i)\n}\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这个类实现了Iterator 接口，但不理想。这是因为它的每个实例只能被迭代一次。\n\n为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器：\n\nclass Counter {\n  constructor(limit) {\n    this.limit = limit\n  }\n\n  [Symbol.iterator]() {\n    let count = 1\n    let limit = this.limit\n    return {\n      next() {\n        if (count <= limit) {\n          return { done: false, value: count++ }\n        } else {\n          return { done: true, value: undefined }\n        }\n      }\n    }\n  }\n}\nlet counter = new Counter(3);\nfor (let i of counter) { console.log(i); }\n// 1\n// 2\n// 3\nfor (let i of counter) { console.log(i); }\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n每个以这种方式创建的迭代器也实现了Iterable 接口。Symbol.iterator 属性引用的工厂函数会返回相同的迭代器。因为每个迭代器也实现了Iterable 接口，所以它们可以用在任何期待可迭代对象的地方。\n\n\n# 提前终止迭代器\n\n内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用 return()方法。\n\nclass Counter {\n  constructor(limit) {\n    this.limit = limit;\n  }\n  [Symbol.iterator]() {\n    let count = 1,\n    limit = this.limit;\n    return {\n      next() {\n        if (count <= limit) {\n          return { done: false, value: count++ };\n        } else {\n          return { done: true };\n        }\n      },\n      return() {\n        console.log('Exiting early');\n        return { done: true };\n      }\n    };\n  }\n}\nlet counter1 = new Counter(5);\nfor (let i of counter1) {\n  if (i > 2) {\n    break;\n  }\n  console.log(i);\n}\n// 1\n// 2\n// Exiting early\nlet counter2 = new Counter(5);\ntry {\n  for (let i of counter2) {\nif (i > 2) {\n  throw 'err';\n}\n  console.log(i);\n}\n} catch(e) {}\n// 1\n// 2\n// Exiting early\nlet counter3 = new Counter(5);\nlet [a, b] = counter3;\n// Exiting early\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的：\n\nlet a = [1, 2, 3, 4, 5];\nlet iter = a[Symbol.iterator]();\nfor (let i of iter) {\n  console.log(i);\n  if (i > 2) {\n    break\n  }\n}\n// 1\n// 2\n// 3\nfor (let i of iter) {\n  console.log(i);\n}\n// 4\n// 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n因为return()方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用return()不会强制迭代器进入关闭状态。即便如此，return()方法还是会被调用。\n\nlet a = [1, 2, 3, 4, 5];\nlet iter = a[Symbol.iterator]();\niter.return = function() {\n  console.log('Exiting early');\n  return { done: true };\n};\nfor (let i of iter) {\n  console.log(i);\n  if (i > 2) {\n    break\n  }\n}\n// 1\n// 2\n// 3\n// 提前退出\nfor (let i of iter) {\n  console.log(i);\n}\n// 4\n// 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 生成器\n\n笔记\n\n生成器是ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程。\n\n生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。\n\n// 生成器函数声明\nfunction* generatorFn() {}\n// 生成器函数表达式\nlet generatorFn = function* () {}\n// 作为对象字面量方法的生成器函数\nlet foo = {\n  * generatorFn() {}\n}\n// 作为类实例方法的生成器函数\nclass Foo {\n  * generatorFn() {}\n}\n// 作为类静态方法的生成器函数\nclass Bar {\n  static * generatorFn() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n提示\n\n箭头函数不能用来定义生成器函数。\n\n标识生成器函数的星号不受两侧空格的影响。\n\nyield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的return 关键字，yield 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误\n\n\n# 生成器对象作为可迭代对象\n\n在生成器对象上显式调用next()方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便。\n\nfunction* generatorFn() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\nfor (const x of generatorFn()) {\n  console.log(x);\n}\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 使用 yield 实现输入输出\n\n除了可以作为函数的中间返回语句使用，yield 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的yield 关键字会接收到传给next()方法的第一个值。这里有个地方不太好理解——第一次调用next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：\n\nfunction* generatorFn(initial) {\n  console.log(initial);\n  console.log(yield);\n  console.log(yield);\n}\nlet generatorObject = generatorFn('foo');\ngeneratorObject.next('bar'); // foo\ngeneratorObject.next('baz'); // baz\ngeneratorObject.next('qux'); // qux\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 产生可迭代对象\n\n可以使用星号增强yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：\n\n// 等价的generatorFn：\n// function* generatorFn() {\n// for (const x of [1, 2, 3]) {\n// yield x;\n// }\n// }\nfunction* generatorFn() {\n  yield* [1, 2, 3];\n}\nlet generatorObject = generatorFn();\nfor (const x of generatorFn()) {\n  console.log(x);\n}\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 使用 yield*实现递归算法\n\nyield*最有用的地方是实现递归操作，此时生成器可以产生自身。\n\nfunction* nTimes(n) {\n  if (n > 0) {\n    yield* nTimes(n - 1);\n    yield n - 1;\n  }\n}\nfor (const x of nTimes(3)) {\n  console.log(x);\n}\n// 0\n// 1\n// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。\n\n使用递归生成器结构和yield*可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：\n\nclass Node {\n  constructor(id) {\n    this.id = id\n    this.neighbors = new Set()\n  }\n  connect(node) {\n    if (node !== this) {\n      this.neighbors.add(node)\n      node.neighbors.add(this)\n    }\n  }\n}\nclass RandomGraph {\n  constructor(size) {\n    this.nodes = new Set()\n    // 创建节点\n    for (let i = 0; i < size; ++i) {\n      this.nodes.add(new Node(i))\n    }\n    // 随机连接节点\n    const threshold = 1 / size\n    for (const x of this.nodes) {\n      for (const y of this.nodes) {\n        if (Math.random() < threshold) {\n          x.connect(y)\n        }\n      }\n    }\n  }\n  // 这个方法仅用于调试\n  print() {\n    for (const node of this.nodes) {\n      const ids = [...node.neighbors].map((n) => n.id).join(\",\")\n      console.log(`${node.id}: ${ids}`)\n    }\n  }\n}\nconst g = new RandomGraph(6)\ng.print()\n// 示例输出：\n// 0: 2,3,5\n// 1: 2,3,4,5\n// 2: 1,3\n// 3: 0,1,2,4\n// 4: 2,3\n// 5: 0,4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，\n\n即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：\n\nclass Node {\n  constructor(id) {\n    ...\n  }\n  connect(node) {\n    ...\n  }\n}\n\nclass RandomGraph {\n  constructor(size) {\n    ...\n  }\n  print() {\n    ...\n  }\n  isConnected() {\n    const visitedNodes = new Set();\n    function* traverse(nodes) {\n      for (const node of nodes) {\n        if (!visitedNodes.has(node)) {\n          yield node;\n          yield* traverse(node.neighbors);\n        }\n      }\n    }\n    // 取得集合中的第一个节点\n    const firstNode = this.nodes[Symbol.iterator]().next().value;\n    // 使用递归生成器迭代每个节点\n    for (const node of traverse([firstNode])) {\n      visitedNodes.add(node);\n    }\n    return visitedNodes.size === this.nodes.size;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 生成器作为默认迭代器\n\n因为生成器对象实现了Iterable 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：\n\nclass Foo {\n  constructor() {\n    this.values = [1, 2, 3];\n  }\n  *[Symbol.iterator]() {\n    yield* this.values;\n  }\n}\n\nconst f = new Foo()\nfor (const x of f) {\n  console.log(x);\n}\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 提前终止生成器\n\n生成器函数返回的生成器对象可以手动停止，有三种方法可以做到这一点：\n\n * return()：调用return()方法可以提前终止生成器函数。传递给return()方法的值，就是生成器函数的返回值。在生成器函数中，return()方法之后的任何代码都不会执行了。\n\n * throw()：调用throw()方法会抛出错误，并终止生成器。在生成器函数中，throw()方法之后的任何代码都不会执行了。",normalizedContent:"# 迭代器\n\n\n# 迭代器模式\n\n笔记\n\n迭代器模式（特别是在ecmascript 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的iterable 接口，而且可以通过迭代器iterator 消费。可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序。\n\n不过，可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构。\n\n临时性可迭代对象可以实现为生成器，本章后面会讨论。\n\n如果对象原型链上的父类实现了iterable 接口，那这个对象也就实现了这个接口：\n\n\n# 迭代器协议\n\n笔记\n\n迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器api 使用next()方法在可迭代对象中遍历数据。每次成功调用next()，都会返回一个iteratorresult 对象，其中包含迭代器返回的下一个值。若不调用next()，则无法知道迭代器的当前位置。\n\nnext()方法返回的迭代器对象iteratorresult 包含两个属性：done 和value。done 是一个布尔值，表示是否还可以再次调用next()取得下一个值；value 包含可迭代对象的下一个值（done 为false），或者undefined（done 为true）。done: true 状态称为“耗尽”。\n\n每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独 立地遍历可迭代对象：\n\nlet arr = ['foo', 'bar'];\nlet iter1 = arr[symbol.iterator]();\nlet iter2 = arr[symbol.iterator]();\nconsole.log(iter1.next()); // { done: false, value: 'foo' }\nconsole.log(iter2.next()); // { done: false, value: 'foo' }\nconsole.log(iter2.next()); // { done: false, value: 'bar' }\nconsole.log(iter1.next()); // { done: false, value: 'bar' }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：\n\nlet arr = ['foo', 'baz'];\nlet iter = arr[symbol.iterator]();\nconsole.log(iter.next()); // { done: false, value: 'foo' }\n// 在数组中间插入值\narr.splice(1, 0, 'bar');\nconsole.log(iter.next()); // { done: false, value: 'bar' }\nconsole.log(iter.next()); // { done: false, value: 'baz' }\nconsole.log(iter.next()); // { done: true, value: undefined }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n提示\n\n迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。\n\n\n# 自定义迭代器\n\n与iterable 接口类似，任何实现iterator 接口的对象都可以作为迭代器使用。下面这个例子中的counter 类只能被迭代一定的次数：\n\nclass counter {\n  // counter 的实例应该被迭代 limit 次\n  constructor(limit) {\n    this.count = 1\n    this.limit = limit\n  }\n\n  next() {\n    if (this.count <= this.limit) {\n      return { done: false, value: this.count++ }\n    } else {\n      return { done: true, value: undefined }\n    }\n  }\n\n  [symbol.iterator]() {\n    return this\n  }\n}\nlet counter = new counter(3)\nfor (let i of counter) {\n  console.log(i)\n}\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这个类实现了iterator 接口，但不理想。这是因为它的每个实例只能被迭代一次。\n\n为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器：\n\nclass counter {\n  constructor(limit) {\n    this.limit = limit\n  }\n\n  [symbol.iterator]() {\n    let count = 1\n    let limit = this.limit\n    return {\n      next() {\n        if (count <= limit) {\n          return { done: false, value: count++ }\n        } else {\n          return { done: true, value: undefined }\n        }\n      }\n    }\n  }\n}\nlet counter = new counter(3);\nfor (let i of counter) { console.log(i); }\n// 1\n// 2\n// 3\nfor (let i of counter) { console.log(i); }\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n每个以这种方式创建的迭代器也实现了iterable 接口。symbol.iterator 属性引用的工厂函数会返回相同的迭代器。因为每个迭代器也实现了iterable 接口，所以它们可以用在任何期待可迭代对象的地方。\n\n\n# 提前终止迭代器\n\n内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用 return()方法。\n\nclass counter {\n  constructor(limit) {\n    this.limit = limit;\n  }\n  [symbol.iterator]() {\n    let count = 1,\n    limit = this.limit;\n    return {\n      next() {\n        if (count <= limit) {\n          return { done: false, value: count++ };\n        } else {\n          return { done: true };\n        }\n      },\n      return() {\n        console.log('exiting early');\n        return { done: true };\n      }\n    };\n  }\n}\nlet counter1 = new counter(5);\nfor (let i of counter1) {\n  if (i > 2) {\n    break;\n  }\n  console.log(i);\n}\n// 1\n// 2\n// exiting early\nlet counter2 = new counter(5);\ntry {\n  for (let i of counter2) {\nif (i > 2) {\n  throw 'err';\n}\n  console.log(i);\n}\n} catch(e) {}\n// 1\n// 2\n// exiting early\nlet counter3 = new counter(5);\nlet [a, b] = counter3;\n// exiting early\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的：\n\nlet a = [1, 2, 3, 4, 5];\nlet iter = a[symbol.iterator]();\nfor (let i of iter) {\n  console.log(i);\n  if (i > 2) {\n    break\n  }\n}\n// 1\n// 2\n// 3\nfor (let i of iter) {\n  console.log(i);\n}\n// 4\n// 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n因为return()方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用return()不会强制迭代器进入关闭状态。即便如此，return()方法还是会被调用。\n\nlet a = [1, 2, 3, 4, 5];\nlet iter = a[symbol.iterator]();\niter.return = function() {\n  console.log('exiting early');\n  return { done: true };\n};\nfor (let i of iter) {\n  console.log(i);\n  if (i > 2) {\n    break\n  }\n}\n// 1\n// 2\n// 3\n// 提前退出\nfor (let i of iter) {\n  console.log(i);\n}\n// 4\n// 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 生成器\n\n笔记\n\n生成器是ecmascript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程。\n\n生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。\n\n// 生成器函数声明\nfunction* generatorfn() {}\n// 生成器函数表达式\nlet generatorfn = function* () {}\n// 作为对象字面量方法的生成器函数\nlet foo = {\n  * generatorfn() {}\n}\n// 作为类实例方法的生成器函数\nclass foo {\n  * generatorfn() {}\n}\n// 作为类静态方法的生成器函数\nclass bar {\n  static * generatorfn() {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n提示\n\n箭头函数不能用来定义生成器函数。\n\n标识生成器函数的星号不受两侧空格的影响。\n\nyield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的return 关键字，yield 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误\n\n\n# 生成器对象作为可迭代对象\n\n在生成器对象上显式调用next()方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便。\n\nfunction* generatorfn() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\nfor (const x of generatorfn()) {\n  console.log(x);\n}\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 使用 yield 实现输入输出\n\n除了可以作为函数的中间返回语句使用，yield 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的yield 关键字会接收到传给next()方法的第一个值。这里有个地方不太好理解——第一次调用next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：\n\nfunction* generatorfn(initial) {\n  console.log(initial);\n  console.log(yield);\n  console.log(yield);\n}\nlet generatorobject = generatorfn('foo');\ngeneratorobject.next('bar'); // foo\ngeneratorobject.next('baz'); // baz\ngeneratorobject.next('qux'); // qux\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 产生可迭代对象\n\n可以使用星号增强yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：\n\n// 等价的generatorfn：\n// function* generatorfn() {\n// for (const x of [1, 2, 3]) {\n// yield x;\n// }\n// }\nfunction* generatorfn() {\n  yield* [1, 2, 3];\n}\nlet generatorobject = generatorfn();\nfor (const x of generatorfn()) {\n  console.log(x);\n}\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 使用 yield*实现递归算法\n\nyield*最有用的地方是实现递归操作，此时生成器可以产生自身。\n\nfunction* ntimes(n) {\n  if (n > 0) {\n    yield* ntimes(n - 1);\n    yield n - 1;\n  }\n}\nfor (const x of ntimes(3)) {\n  console.log(x);\n}\n// 0\n// 1\n// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。\n\n使用递归生成器结构和yield*可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：\n\nclass node {\n  constructor(id) {\n    this.id = id\n    this.neighbors = new set()\n  }\n  connect(node) {\n    if (node !== this) {\n      this.neighbors.add(node)\n      node.neighbors.add(this)\n    }\n  }\n}\nclass randomgraph {\n  constructor(size) {\n    this.nodes = new set()\n    // 创建节点\n    for (let i = 0; i < size; ++i) {\n      this.nodes.add(new node(i))\n    }\n    // 随机连接节点\n    const threshold = 1 / size\n    for (const x of this.nodes) {\n      for (const y of this.nodes) {\n        if (math.random() < threshold) {\n          x.connect(y)\n        }\n      }\n    }\n  }\n  // 这个方法仅用于调试\n  print() {\n    for (const node of this.nodes) {\n      const ids = [...node.neighbors].map((n) => n.id).join(\",\")\n      console.log(`${node.id}: ${ids}`)\n    }\n  }\n}\nconst g = new randomgraph(6)\ng.print()\n// 示例输出：\n// 0: 2,3,5\n// 1: 2,3,4,5\n// 2: 1,3\n// 3: 0,1,2,4\n// 4: 2,3\n// 5: 0,4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，\n\n即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：\n\nclass node {\n  constructor(id) {\n    ...\n  }\n  connect(node) {\n    ...\n  }\n}\n\nclass randomgraph {\n  constructor(size) {\n    ...\n  }\n  print() {\n    ...\n  }\n  isconnected() {\n    const visitednodes = new set();\n    function* traverse(nodes) {\n      for (const node of nodes) {\n        if (!visitednodes.has(node)) {\n          yield node;\n          yield* traverse(node.neighbors);\n        }\n      }\n    }\n    // 取得集合中的第一个节点\n    const firstnode = this.nodes[symbol.iterator]().next().value;\n    // 使用递归生成器迭代每个节点\n    for (const node of traverse([firstnode])) {\n      visitednodes.add(node);\n    }\n    return visitednodes.size === this.nodes.size;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 生成器作为默认迭代器\n\n因为生成器对象实现了iterable 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：\n\nclass foo {\n  constructor() {\n    this.values = [1, 2, 3];\n  }\n  *[symbol.iterator]() {\n    yield* this.values;\n  }\n}\n\nconst f = new foo()\nfor (const x of f) {\n  console.log(x);\n}\n// 1\n// 2\n// 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 提前终止生成器\n\n生成器函数返回的生成器对象可以手动停止，有三种方法可以做到这一点：\n\n * return()：调用return()方法可以提前终止生成器函数。传递给return()方法的值，就是生成器函数的返回值。在生成器函数中，return()方法之后的任何代码都不会执行了。\n\n * throw()：调用throw()方法会抛出错误，并终止生成器。在生成器函数中，throw()方法之后的任何代码都不会执行了。",charsets:{cjk:!0},lastUpdated:"2024/08/28, 12:02:09",lastUpdatedTimestamp:1724817729e3},{title:"函数",frontmatter:{title:"函数",date:"2024-08-31T12:07:40.000Z",permalink:"/pages/2aaf04/",categories:["前端","JavaScript高级程序设计"],tags:["核心技术","函数"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/12.%E5%87%BD%E6%95%B0.html",relativePath:"01.前端/03.JavaScript高级程序设计/12.函数.md",key:"v-be378bd6",path:"/pages/2aaf04/",headers:[{level:2,title:"函数名",slug:"函数名",normalizedTitle:"函数名",charIndex:102},{level:2,title:"函数内部",slug:"函数内部",normalizedTitle:"函数内部",charIndex:1e3},{level:3,title:"caller",slug:"caller",normalizedTitle:"caller",charIndex:1009},{level:3,title:"new.target",slug:"new-target",normalizedTitle:"new.target",charIndex:1714},{level:3,title:"尾调用优化",slug:"尾调用优化",normalizedTitle:"尾调用优化",charIndex:2166},{level:4,title:"尾调用优化的条件",slug:"尾调用优化的条件",normalizedTitle:"尾调用优化的条件",charIndex:2913},{level:2,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:3045},{level:3,title:"this 对象",slug:"this-对象",normalizedTitle:"this 对象",charIndex:4360},{level:3,title:"内存泄露",slug:"内存泄露",normalizedTitle:"内存泄露",charIndex:5353},{level:3,title:"立即调用的函数表达式",slug:"立即调用的函数表达式",normalizedTitle:"立即调用的函数表达式",charIndex:6211},{level:3,title:"私有变量",slug:"私有变量",normalizedTitle:"私有变量",charIndex:6420},{level:4,title:"静态私有变量",slug:"静态私有变量",normalizedTitle:"静态私有变量",charIndex:7505},{level:4,title:"模块模式",slug:"模块模式",normalizedTitle:"模块模式",charIndex:7866},{level:4,title:"模块增强模式",slug:"模块增强模式",normalizedTitle:"模块增强模式",charIndex:9073}],headersStr:"函数名 函数内部 caller new.target 尾调用优化 尾调用优化的条件 闭包 this 对象 内存泄露 立即调用的函数表达式 私有变量 静态私有变量 模块模式 模块增强模式",content:"提示\n\n函数是ECMAScript 中最有意思的部分之一，这主要是因为函数实际上是对象。每个函数都是Function类型的实例，而Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。\n\n\n# 函数名\n\nECMAScript 6 的所有函数对象都会暴露一个只读的name 属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用Function 构造函数创建的，则会标识成\"anonymous\"：\n\nfunction foo() {}\nlet bar = function() {};\nlet baz = () => {};\nconsole.log(foo.name); // foo\nconsole.log(bar.name); // bar\nconsole.log(baz.name); // baz\nconsole.log((() => {}).name); //（空字符串）\nconsole.log((new Function()).name); // anonymous\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果函数是一个获取函数、设置函数，或者使用bind()实例化，那么标识符前面会加上一个前缀：\n\nfunction foo() {}\nconsole.log(foo.bind(null).name); // bound foo\nlet dog = {\n  years: 1,\n  get age() {\n    return this.years;\n  },\n  set age(newAge) {\n    this.years = newAge;\n  }\n}\nlet propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age');\nconsole.log(propertyDescriptor.get.name); // get age\nconsole.log(propertyDescriptor.set.name); // set age\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 函数内部\n\n\n# caller\n\nECMAScript 5 也会给函数对象上添加一个属性：caller。虽然ECMAScript 3 中并没有定义，但所有浏览器除了早期版本的Opera 都支持这个属性。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为null。\n\nfunction outer() {\n  inner();\n}\nfunction inner() {\n  console.log(inner.caller);\n}\nouter();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n以上代码会显示outer()函数的源代码。这是因为ourter()调用了inner()，inner.caller指向outer()。如果要降低耦合度，则可以通过arguments.callee.caller 来引用同样的值：\n\nfunction outer() {\n  inner();\n}\nfunction inner() {\n  console.log(arguments.callee.caller);\n}\nouter();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在严格模式下访问arguments.callee 会报错。ECMAScript 5 也定义了arguments.caller，但在严格模式下访问它会报错，在非严格模式下则始终是undefined。这是为了分清arguments.caller和函数的caller 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文中运行的其他代码。\n\n严格模式下还有一个限制，就是不能给函数的caller 属性赋值，否则会导致错误。\n\n\n# new.target\n\nECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6 新增了检测函数是否使用new 关键字调用的new.target 属性。如果函数是正常调用的，则new.target 的值是undefined；如果是使用new 关键字调用的，则new.target 将引用被调用的构造函数。\n\nfunction King() {\n  if (!new.target) {\n    throw 'King must be instantiated using \"new\"'\n  }\n  console.log('King instantiated using \"new\"');\n}\nnew King(); // King instantiated using \"new\"\nKing(); // Error: King must be instantiated using \"new\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 尾调用优化\n\nECMAScript 6 规范新增了一项内存管理优化机制，让JavaScript 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。\n\nfunction outerFunction() {\n  return innerFunction(); // 尾调用\n}\n\n\n1\n2\n3\n\n\n在ES6 优化之前，执行这个例子会在内存中发生如下操作。 (1) 执行到outerFunction 函数体，第一个栈帧被推到栈上。 (2) 执行outerFunction 函数体，到return 语句。计算返回值必须先计算innerFunction。 (3) 执行到innerFunction 函数体，第二个栈帧被推到栈上。 (4) 执行innerFunction 函数体，计算其返回值。 (5) 将返回值传回outerFunction，然后outerFunction 再返回值。 (6) 将栈帧弹出栈外。 在ES6 优化之后，执行这个例子会在内存中发生如下操作。 (1) 执行到outerFunction 函数体，第一个栈帧被推到栈上。 (2) 执行outerFunction 函数体，到达return 语句。为求值返回语句，必须先求值innerFunction。 (3) 引擎发现把第一个栈帧弹出栈外也没问题，因为innerFunction 的返回值也是outerFunction的返回值。 (4) 弹出outerFunction 的栈帧。 (5) 执行到innerFunction 函数体，栈帧被推到栈上。 (6) 执行innerFunction 函数体，计算其返回值。 (7) 将innerFunction 的栈帧弹出栈外。\n\n# 尾调用优化的条件\n\n尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下：\n\n * 代码在严格模式下执行；\n * 外部函数的返回值是对尾调用函数的调用；\n * 尾调用函数返回后不需要执行额外的逻辑；\n * 尾调用函数不是引用外部函数作用域中自由变量的闭包。\n\n下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求：\n\n\"use strict\";\n// 无优化：尾调用没有返回\nfunction outerFunction() {\n  innerFunction();\n}\n// 无优化：尾调用没有直接返回\nfunction outerFunction() {\n  let innerFunctionResult = innerFunction();\n  return innerFunctionResult;\n}\n// 无优化：尾调用返回后必须转型为字符串\nfunction outerFunction() {\n  return innerFunction().toString();\n}\n// 无优化：尾调用是一个闭包\nfunction outerFunction() {\n  let foo = 'bar';\n  function innerFunction() {\n    return foo;\n  }\n  return innerFunction();\n}\n// 下面是几个符合尾调用优化条件的例子：\n\"use strict\";\n// 有优化：栈帧销毁前执行参数计算\nfunction outerFunction(a, b) {\n  return innerFunction(a + b);\n}\n// 有优化：初始返回值不涉及栈帧\nfunction outerFunction(a, b) {\n  if (a < b) {\n    return a;\n  }\n  return innerFunction(a + b);\n}\n// 有优化：两个内部函数都在尾部\nfunction outerFunction(condition) {\n  return condition ? innerFunctionA() : innerFunctionB();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。\n\n\n# 闭包\n\n闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。\n\n函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。\n\n\n# this 对象\n\n在闭包中使用this 会让代码变复杂。如果内部函数没有使用箭头函数定义，则this 对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则this 在非严格模式下等于window，在严格模式下等于undefined。如果作为某个对象的方法调用，则this 等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着this 会指向window，除非在严格模式下this 是undefined。不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。\n\n在一些特殊情况下，this 值可能并不是我们所期待的值。比如下面这个修改后的例子：\n\nwindow.identity = 'The Window';\nlet object = {\n  identity: 'My Object',\n  getIdentity () {\n    return this.identity;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ngetIdentity()方法就是返回this.identity 的值。以下是几种调用object.getIdentity()的方式及返回值：\n\nobject.getIdentity(); // 'My Object'\n(object.getIdentity)(); // 'My Object'\n(object.getIdentity = object.getIdentity)(); // 'The Window'\n\n\n1\n2\n3\n\n\n第一行调用object.getIdentity()是正常调用，会返回\"My Object\"，因为this.identity就是object.identity。第二行在调用时把object.getIdentity 放在了括号里。虽然加了括号之后看起来是对一个函数的引用，但this 值并没有变。这是因为按照规范，object.getIdentity 和(object.getIdentity)是相等的。第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，this 值不再与任何对象绑定，所以返回的是\"The Window\"。一般情况下，不大可能像第二行和第三行这样调用对象上的方法。但通过这个例子，我们可以知道，即使语法稍有不同，也可能影响this 的值。\n\n\n# 内存泄露\n\n由于IE 在IE9 之前对JScript 对象和COM对象使用了不同的垃圾回收机制（第4 章讨论过），所以闭包在这些旧版本IE 中可能会导致问题。在这些版本的IE 中，把HTML 元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。来看下面的例子：\n\nfunction assignHandler() {\nlet element = document.getElementById('someElement');\nelement.onclick = () => console.log(element.id);\n}\n\n\n1\n2\n3\n4\n\n\n以上代码创建了一个闭包，即element 元素的事件处理程序（事件处理程序将在第13 章讨论）。而这个处理程序又创建了一个循环引用。匿名函数引用着assignHandler()的活动对象，阻止了对element 的引用计数归零。只要这个匿名函数存在，element 的引用计数就至少等于1。也就是说，内存不会被回收。其实只要这个例子稍加修改，就可以避免这种情况，比如：\n\nfunction assignHandler() {\nlet element = document.getElementById('someElement');\nlet id = element.id;\nelement.onclick = () => console.log(id);\nelement = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在这个修改后的版本中，闭包改为引用一个保存着element.id 的变量id，从而消除了循环引用。不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含element。即使闭包没有直接引用element，包含函数的活动对象上还是保存着对它的引用。因此，必须再把element 设置为null。这样就解除了对这个COM 对象的引用，其引用计数也会减少，从而确保其内存可以在适当的时候被回收。\n\n\n# 立即调用的函数表达式\n\n立即调用的匿名函数又被称作立即调用的函数表达式（IIFE，Immediately Invoked Function Expression）\n\n使用IIFE 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用IIFE模拟块级作用域是相当普遍的。比如下面的例子：\n\n\n# 私有变量\n\n严格来讲，JavaScript 没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。\n\n特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有两种方式创建特权方法。第一种是在构造函数中实现。\n\nfunction MyObject() {\n  // 私有变量和私有函数\n  let privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  // 特权方法\n  this.publicMethod = function() {\n    privateVariable++;\n    return privateFunction();\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。在这个例子中，变量privateVariable 和函数privateFunction()只能通过publicMethod()方法来访问。在创建MyObject 的实例后，没有办法直接访问privateVariable 和privateFunction()，唯一的办法是使用publicMethod()。\n\n如下面的例子所示，可以定义私有变量和特权方法，以隐藏不能被直接修改的数据：\n\nfunction Person(name) {\n  this.getName = function() {\n    return name;\n  };\n  this.setName = function (value) {\n    name = value;\n  };\n}\nlet person = new Person('Nicholas');\nconsole.log(person.getName()); // 'Nicholas'\nperson.setName('Greg');\nconsole.log(person.getName()); // 'Greg'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 静态私有变量\n\n特权方法也可以通过使用私有作用域定义私有变量和函数来实现。这个模式如下所示：\n\n(function() {\n  // 私有变量和私有函数\n  let privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  // 构造函数\n  MyObject = function() {};\n  // 公有和特权方法\n  MyObject.prototype.publicMethod = function() {\n    privateVariable++;\n    return privateFunction();\n  };\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 模块模式\n\n前面的模式通过自定义类型创建了私有变量和特权方法。而下面要讨论的Douglas Crockford 所说的模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（singleton）就是只有一个实例的对象。按照惯例，JavaScript 是通过对象字面量来创建单例对象的，如下面的例子所示：\n\nlet singleton = {\n  name: value,\n  method: function() {\n    // ...\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式的样板代码如下：\n\nlet singleton = function() {\n  // 私有变量和私有函数\n  let privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  // 特权/公有方法和属性\n  return {\n    publicProperty: true,\n    publicMethod() {\n      privateVariable++;\n      return privateFunction();\n    }\n  };\n}();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函数。本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式：\n\nlet application = function() {\n  // 私有变量和私有函数\n  let components = new Array();\n  // 初始化\n  components.push(new BaseComponent());\n  // 公共接口\n  return {\n    getComponentCount() {\n      return components.length;\n    },\n    registerComponent(component) {\n      if (typeof component == 'object') {\n        components.push(component);\n      }\n    }\n  };\n}();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 模块增强模式\n\n另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。来看下面的例子：\n\nlet singleton = function() {\n  // 私有变量和私有函数\n  let privateVariable = 10;\n  function privateFunction() {\n    return false;\n  }\n  // 创建对象\n  let object = new CustomType();\n  // 添加特权/公有属性和方法\n  object.publicProperty = true;\n  object.publicMethod = function() {\n    privateVariable++;\n    return privateFunction();\n  };\n  // 返回对象\n  return object;\n}();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果前一节的application 对象必须是BaseComponent 的实例，那么就可以使用下面的代码来创建它：\n\nlet application = function() {\n  // 私有变量和私有函数\n  let components = new Array();\n  // 初始化\n  components.push(new BaseComponent());\n  // 创建局部变量保存实例\n  let app = new BaseComponent();\n  // 公共接口\n  app.getComponentCount = function() {\n    return components.length;\n  };\n  app.registerComponent = function(component) {\n    if (typeof component == \"object\") {\n      components.push(component);\n    }\n  };\n  // 返回实例\n  return app;\n}();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"提示\n\n函数是ecmascript 中最有意思的部分之一，这主要是因为函数实际上是对象。每个函数都是function类型的实例，而function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。\n\n\n# 函数名\n\necmascript 6 的所有函数对象都会暴露一个只读的name 属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用function 构造函数创建的，则会标识成\"anonymous\"：\n\nfunction foo() {}\nlet bar = function() {};\nlet baz = () => {};\nconsole.log(foo.name); // foo\nconsole.log(bar.name); // bar\nconsole.log(baz.name); // baz\nconsole.log((() => {}).name); //（空字符串）\nconsole.log((new function()).name); // anonymous\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果函数是一个获取函数、设置函数，或者使用bind()实例化，那么标识符前面会加上一个前缀：\n\nfunction foo() {}\nconsole.log(foo.bind(null).name); // bound foo\nlet dog = {\n  years: 1,\n  get age() {\n    return this.years;\n  },\n  set age(newage) {\n    this.years = newage;\n  }\n}\nlet propertydescriptor = object.getownpropertydescriptor(dog, 'age');\nconsole.log(propertydescriptor.get.name); // get age\nconsole.log(propertydescriptor.set.name); // set age\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 函数内部\n\n\n# caller\n\necmascript 5 也会给函数对象上添加一个属性：caller。虽然ecmascript 3 中并没有定义，但所有浏览器除了早期版本的opera 都支持这个属性。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为null。\n\nfunction outer() {\n  inner();\n}\nfunction inner() {\n  console.log(inner.caller);\n}\nouter();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n以上代码会显示outer()函数的源代码。这是因为ourter()调用了inner()，inner.caller指向outer()。如果要降低耦合度，则可以通过arguments.callee.caller 来引用同样的值：\n\nfunction outer() {\n  inner();\n}\nfunction inner() {\n  console.log(arguments.callee.caller);\n}\nouter();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在严格模式下访问arguments.callee 会报错。ecmascript 5 也定义了arguments.caller，但在严格模式下访问它会报错，在非严格模式下则始终是undefined。这是为了分清arguments.caller和函数的caller 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文中运行的其他代码。\n\n严格模式下还有一个限制，就是不能给函数的caller 属性赋值，否则会导致错误。\n\n\n# new.target\n\necmascript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ecmascript 6 新增了检测函数是否使用new 关键字调用的new.target 属性。如果函数是正常调用的，则new.target 的值是undefined；如果是使用new 关键字调用的，则new.target 将引用被调用的构造函数。\n\nfunction king() {\n  if (!new.target) {\n    throw 'king must be instantiated using \"new\"'\n  }\n  console.log('king instantiated using \"new\"');\n}\nnew king(); // king instantiated using \"new\"\nking(); // error: king must be instantiated using \"new\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 尾调用优化\n\necmascript 6 规范新增了一项内存管理优化机制，让javascript 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。\n\nfunction outerfunction() {\n  return innerfunction(); // 尾调用\n}\n\n\n1\n2\n3\n\n\n在es6 优化之前，执行这个例子会在内存中发生如下操作。 (1) 执行到outerfunction 函数体，第一个栈帧被推到栈上。 (2) 执行outerfunction 函数体，到return 语句。计算返回值必须先计算innerfunction。 (3) 执行到innerfunction 函数体，第二个栈帧被推到栈上。 (4) 执行innerfunction 函数体，计算其返回值。 (5) 将返回值传回outerfunction，然后outerfunction 再返回值。 (6) 将栈帧弹出栈外。 在es6 优化之后，执行这个例子会在内存中发生如下操作。 (1) 执行到outerfunction 函数体，第一个栈帧被推到栈上。 (2) 执行outerfunction 函数体，到达return 语句。为求值返回语句，必须先求值innerfunction。 (3) 引擎发现把第一个栈帧弹出栈外也没问题，因为innerfunction 的返回值也是outerfunction的返回值。 (4) 弹出outerfunction 的栈帧。 (5) 执行到innerfunction 函数体，栈帧被推到栈上。 (6) 执行innerfunction 函数体，计算其返回值。 (7) 将innerfunction 的栈帧弹出栈外。\n\n# 尾调用优化的条件\n\n尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下：\n\n * 代码在严格模式下执行；\n * 外部函数的返回值是对尾调用函数的调用；\n * 尾调用函数返回后不需要执行额外的逻辑；\n * 尾调用函数不是引用外部函数作用域中自由变量的闭包。\n\n下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求：\n\n\"use strict\";\n// 无优化：尾调用没有返回\nfunction outerfunction() {\n  innerfunction();\n}\n// 无优化：尾调用没有直接返回\nfunction outerfunction() {\n  let innerfunctionresult = innerfunction();\n  return innerfunctionresult;\n}\n// 无优化：尾调用返回后必须转型为字符串\nfunction outerfunction() {\n  return innerfunction().tostring();\n}\n// 无优化：尾调用是一个闭包\nfunction outerfunction() {\n  let foo = 'bar';\n  function innerfunction() {\n    return foo;\n  }\n  return innerfunction();\n}\n// 下面是几个符合尾调用优化条件的例子：\n\"use strict\";\n// 有优化：栈帧销毁前执行参数计算\nfunction outerfunction(a, b) {\n  return innerfunction(a + b);\n}\n// 有优化：初始返回值不涉及栈帧\nfunction outerfunction(a, b) {\n  if (a < b) {\n    return a;\n  }\n  return innerfunction(a + b);\n}\n// 有优化：两个内部函数都在尾部\nfunction outerfunction(condition) {\n  return condition ? innerfunctiona() : innerfunctionb();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。\n\n\n# 闭包\n\n闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。\n\n函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[scope]]中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[scope]]来创建其作用域链。接着会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。\n\n\n# this 对象\n\n在闭包中使用this 会让代码变复杂。如果内部函数没有使用箭头函数定义，则this 对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则this 在非严格模式下等于window，在严格模式下等于undefined。如果作为某个对象的方法调用，则this 等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着this 会指向window，除非在严格模式下this 是undefined。不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。\n\n在一些特殊情况下，this 值可能并不是我们所期待的值。比如下面这个修改后的例子：\n\nwindow.identity = 'the window';\nlet object = {\n  identity: 'my object',\n  getidentity () {\n    return this.identity;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ngetidentity()方法就是返回this.identity 的值。以下是几种调用object.getidentity()的方式及返回值：\n\nobject.getidentity(); // 'my object'\n(object.getidentity)(); // 'my object'\n(object.getidentity = object.getidentity)(); // 'the window'\n\n\n1\n2\n3\n\n\n第一行调用object.getidentity()是正常调用，会返回\"my object\"，因为this.identity就是object.identity。第二行在调用时把object.getidentity 放在了括号里。虽然加了括号之后看起来是对一个函数的引用，但this 值并没有变。这是因为按照规范，object.getidentity 和(object.getidentity)是相等的。第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，this 值不再与任何对象绑定，所以返回的是\"the window\"。一般情况下，不大可能像第二行和第三行这样调用对象上的方法。但通过这个例子，我们可以知道，即使语法稍有不同，也可能影响this 的值。\n\n\n# 内存泄露\n\n由于ie 在ie9 之前对jscript 对象和com对象使用了不同的垃圾回收机制（第4 章讨论过），所以闭包在这些旧版本ie 中可能会导致问题。在这些版本的ie 中，把html 元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。来看下面的例子：\n\nfunction assignhandler() {\nlet element = document.getelementbyid('someelement');\nelement.onclick = () => console.log(element.id);\n}\n\n\n1\n2\n3\n4\n\n\n以上代码创建了一个闭包，即element 元素的事件处理程序（事件处理程序将在第13 章讨论）。而这个处理程序又创建了一个循环引用。匿名函数引用着assignhandler()的活动对象，阻止了对element 的引用计数归零。只要这个匿名函数存在，element 的引用计数就至少等于1。也就是说，内存不会被回收。其实只要这个例子稍加修改，就可以避免这种情况，比如：\n\nfunction assignhandler() {\nlet element = document.getelementbyid('someelement');\nlet id = element.id;\nelement.onclick = () => console.log(id);\nelement = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在这个修改后的版本中，闭包改为引用一个保存着element.id 的变量id，从而消除了循环引用。不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含element。即使闭包没有直接引用element，包含函数的活动对象上还是保存着对它的引用。因此，必须再把element 设置为null。这样就解除了对这个com 对象的引用，其引用计数也会减少，从而确保其内存可以在适当的时候被回收。\n\n\n# 立即调用的函数表达式\n\n立即调用的匿名函数又被称作立即调用的函数表达式（iife，immediately invoked function expression）\n\n使用iife 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这样位于函数体作用域的变量就像是在块级作用域中一样。ecmascript 5 尚未支持块级作用域，使用iife模拟块级作用域是相当普遍的。比如下面的例子：\n\n\n# 私有变量\n\n严格来讲，javascript 没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。\n\n特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有两种方式创建特权方法。第一种是在构造函数中实现。\n\nfunction myobject() {\n  // 私有变量和私有函数\n  let privatevariable = 10;\n  function privatefunction() {\n    return false;\n  }\n  // 特权方法\n  this.publicmethod = function() {\n    privatevariable++;\n    return privatefunction();\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。在这个例子中，变量privatevariable 和函数privatefunction()只能通过publicmethod()方法来访问。在创建myobject 的实例后，没有办法直接访问privatevariable 和privatefunction()，唯一的办法是使用publicmethod()。\n\n如下面的例子所示，可以定义私有变量和特权方法，以隐藏不能被直接修改的数据：\n\nfunction person(name) {\n  this.getname = function() {\n    return name;\n  };\n  this.setname = function (value) {\n    name = value;\n  };\n}\nlet person = new person('nicholas');\nconsole.log(person.getname()); // 'nicholas'\nperson.setname('greg');\nconsole.log(person.getname()); // 'greg'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 静态私有变量\n\n特权方法也可以通过使用私有作用域定义私有变量和函数来实现。这个模式如下所示：\n\n(function() {\n  // 私有变量和私有函数\n  let privatevariable = 10;\n  function privatefunction() {\n    return false;\n  }\n  // 构造函数\n  myobject = function() {};\n  // 公有和特权方法\n  myobject.prototype.publicmethod = function() {\n    privatevariable++;\n    return privatefunction();\n  };\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 模块模式\n\n前面的模式通过自定义类型创建了私有变量和特权方法。而下面要讨论的douglas crockford 所说的模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（singleton）就是只有一个实例的对象。按照惯例，javascript 是通过对象字面量来创建单例对象的，如下面的例子所示：\n\nlet singleton = {\n  name: value,\n  method: function() {\n    // ...\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式的样板代码如下：\n\nlet singleton = function() {\n  // 私有变量和私有函数\n  let privatevariable = 10;\n  function privatefunction() {\n    return false;\n  }\n  // 特权/公有方法和属性\n  return {\n    publicproperty: true,\n    publicmethod() {\n      privatevariable++;\n      return privatefunction();\n    }\n  };\n}();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后，创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函数。本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式：\n\nlet application = function() {\n  // 私有变量和私有函数\n  let components = new array();\n  // 初始化\n  components.push(new basecomponent());\n  // 公共接口\n  return {\n    getcomponentcount() {\n      return components.length;\n    },\n    registercomponent(component) {\n      if (typeof component == 'object') {\n        components.push(component);\n      }\n    }\n  };\n}();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 模块增强模式\n\n另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。来看下面的例子：\n\nlet singleton = function() {\n  // 私有变量和私有函数\n  let privatevariable = 10;\n  function privatefunction() {\n    return false;\n  }\n  // 创建对象\n  let object = new customtype();\n  // 添加特权/公有属性和方法\n  object.publicproperty = true;\n  object.publicmethod = function() {\n    privatevariable++;\n    return privatefunction();\n  };\n  // 返回对象\n  return object;\n}();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果前一节的application 对象必须是basecomponent 的实例，那么就可以使用下面的代码来创建它：\n\nlet application = function() {\n  // 私有变量和私有函数\n  let components = new array();\n  // 初始化\n  components.push(new basecomponent());\n  // 创建局部变量保存实例\n  let app = new basecomponent();\n  // 公共接口\n  app.getcomponentcount = function() {\n    return components.length;\n  };\n  app.registercomponent = function(component) {\n    if (typeof component == \"object\") {\n      components.push(component);\n    }\n  };\n  // 返回实例\n  return app;\n}();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2024/08/31, 18:19:06",lastUpdatedTimestamp:1725099546e3},{title:"期约与异步函数",frontmatter:{title:"期约与异步函数",date:"2024-08-31T18:19:41.000Z",permalink:"/pages/789703/",categories:["前端","JavaScript高级程序设计"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/13.%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0.html",relativePath:"01.前端/03.JavaScript高级程序设计/13.期约与异步函数.md",key:"v-5aaf9039",path:"/pages/789703/",headersStr:null,content:"提示\n\nPromise + async/await",normalizedContent:"提示\n\npromise + async/await",charsets:{cjk:!0},lastUpdated:"2024/08/31, 18:22:07",lastUpdatedTimestamp:1725099727e3},{title:"代理与反射",frontmatter:{title:"代理与反射",date:"2024-08-30T17:21:20.000Z",permalink:"/pages/911d11/",categories:["前端","JavaScript高级程序设计"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/03.JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/11.%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84.html",relativePath:"01.前端/03.JavaScript高级程序设计/11.代理与反射.md",key:"v-01cb89d6",path:"/pages/911d11/",headers:[{level:2,title:"代理基础",slug:"代理基础",normalizedTitle:"代理基础",charIndex:267},{level:3,title:"定义捕获器",slug:"定义捕获器",normalizedTitle:"定义捕获器",charIndex:1282},{level:3,title:"捕获器参数和反射API",slug:"捕获器参数和反射api",normalizedTitle:"捕获器参数和反射api",charIndex:1938},{level:3,title:"捕获器不变式",slug:"捕获器不变式",normalizedTitle:"捕获器不变式",charIndex:3262},{level:3,title:"可撤销代理",slug:"可撤销代理",normalizedTitle:"可撤销代理",charIndex:3361},{level:3,title:"实用反射 API",slug:"实用反射-api",normalizedTitle:"实用反射 api",charIndex:3497},{level:4,title:"Reflect API 和 Object API",slug:"reflect-api-和-object-api",normalizedTitle:"reflect api 和 object api",charIndex:3509},{level:4,title:"用一等函数替代操作符",slug:"用一等函数替代操作符",normalizedTitle:"用一等函数替代操作符",charIndex:3860},{level:4,title:"安全地应用函数",slug:"安全地应用函数",normalizedTitle:"安全地应用函数",charIndex:4077},{level:3,title:"代理另一个代理",slug:"代理另一个代理",normalizedTitle:"代理另一个代理",charIndex:4331},{level:3,title:"代理的问题与不足",slug:"代理的问题与不足",normalizedTitle:"代理的问题与不足",charIndex:4411},{level:4,title:"代理中的this",slug:"代理中的this",normalizedTitle:"代理中的this",charIndex:4423},{level:4,title:"代理与内部槽位",slug:"代理与内部槽位",normalizedTitle:"代理与内部槽位",charIndex:5532},{level:3,title:"代理捕获器与反射方法",slug:"代理捕获器与反射方法",normalizedTitle:"代理捕获器与反射方法",charIndex:5965},{level:2,title:"代理模式",slug:"代理模式",normalizedTitle:"代理模式",charIndex:8070},{level:3,title:"跟踪属性访问",slug:"跟踪属性访问",normalizedTitle:"跟踪属性访问",charIndex:8079},{level:3,title:"隐藏属性",slug:"隐藏属性",normalizedTitle:"隐藏属性",charIndex:8172},{level:3,title:"属性验证",slug:"属性验证",normalizedTitle:"属性验证",charIndex:8220},{level:3,title:"函数与构造函数参数验证",slug:"函数与构造函数参数验证",normalizedTitle:"函数与构造函数参数验证",charIndex:8274},{level:3,title:"数据绑定与可观察对象",slug:"数据绑定与可观察对象",normalizedTitle:"数据绑定与可观察对象",charIndex:8339}],headersStr:"代理基础 定义捕获器 捕获器参数和反射API 捕获器不变式 可撤销代理 实用反射 API Reflect API 和 Object API 用一等函数替代操作符 安全地应用函数 代理另一个代理 代理的问题与不足 代理中的this 代理与内部槽位 代理捕获器与反射方法 代理模式 跟踪属性访问 隐藏属性 属性验证 函数与构造函数参数验证 数据绑定与可观察对象",content:"ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。\n\n注意\n\n在ES6 之前，ECMAScript 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的ECMAScript 代码，因为代理的行为实际上是无可替代的。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。\n\n\n# 代理基础\n\n在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。\n\nconst target = {\n  id: 'target'\n}\n\nconst handler = {}\n\nconst proxy = new Proxy(target, handler)\n\n// id 属性是直接访问目标对象的\nconsole.log(target.id) // target\nconsole.log(proxy.id) // target\n\n// 给目标属性赋值会反映在两个对象上\ntarget.id = 'foo'\nconsole.log(target.id) // foo\nconsole.log(proxy.id) // foo\n\n// 在目标对象上定义一个新属性\ntarget.bar = 'bar'\nconsole.log(target.bar) // bar\nconsole.log(proxy.bar) // bar\n\n// hasOwnProperty()方法在两个地方\n// 都会应用到目标对象\nconsole.log(target.hasOwnProperty('id')); // true\nconsole.log(proxy.hasOwnProperty('id')); // true\n// Proxy.prototype 是undefined\n// 因此不能使用instanceof 操作符\nconsole.log(target instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof check\nconsole.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof check\n// 严格相等可以用来区分代理和目标\nconsole.log(target === proxy); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 定义捕获器\n\n使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。\n\nconst target = {\n  foo: 'bar'\n}\n\nconst handler = {\n  // 捕获器在处理程序对象中以方法名为键\n  get() {\n    return 'handler override';\n  }\n}\n\nconst proxy = new Proxy(target, handler);\nconsole.log(target.foo); // bar\nconsole.log(proxy.foo); // handler override\nconsole.log(target['foo']); // bar\nconsole.log(proxy['foo']); // handler override\nconsole.log(Object.create(target)['foo']); // bar\nconsole.log(Object.create(proxy)['foo']); // handler override\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 捕获器参数和反射API\n\n捕获器将会获得三个参数\n\n * 捕获对象 trapTarget\n * 被捕获的属性 property\n * 接受捕获的代理 receiver\n\n所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局Reflect 对象上（封装了原始行为）的同名方法来轻松重建。\n\n处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射API 也可以像下面这样定义出空代理对象：\n\nconst target = {\n  foo: 'bar'\n};\nconst handler = {\n  get() {\n    return Reflect.get(...arguments);\n  }\n};\nconst proxy = new Proxy(target, handler);\nconsole.log(proxy.foo); // bar\nconsole.log(target.foo); // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n更加简化的版本：\n\nconst target = {\nfoo: 'bar'\n};\n\nconst handler = {\nget: Reflect.get\n};\nconst proxy = new Proxy(target, handler);\nconsole.log(proxy.foo); // bar\nconsole.log(target.foo); // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n反射API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：\n\nconst target = {\n  foo: 'bar',\n  baz: 'qux'\n};\nconst handler = {\n  get(trapTarget, property, receiver) {\n    let decoration = '';\n    if (property === 'foo') {\n      decoration = '!!!';\n    }\n    return Reflect.get(...arguments) + decoration;\n  }\n};\nconst proxy = new Proxy(target, handler);\nconsole.log(proxy.foo); // bar!!!\nconsole.log(target.foo); // bar\nconsole.log(proxy.baz); // qux\nconsole.log(target.baz); // qux\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 捕获器不变式\n\n使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出TypeError。\n\n\n# 可撤销代理\n\nconst { proxy, revoke } = Proxy.revocable(target, handler);\nrevoke();\nconsole.log(proxy.foo); // TypeError: Revoked\n\n\n1\n2\n3\n\n\n\n# 实用反射 API\n\n# Reflect API 和 Object API\n\n * 反射API 并不限于捕获处理程序\n * 大多数反射API方法在Object类型上有对应的方法\n * Object方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。\n\n很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射API 方法更有用。\n\n以下反射方法都会提供状态标记：\n\n * Reflect.defineProperty()\n * Reflect.preventExtensions()\n * Reflect.setPrototypeOf()\n * Reflect.set()\n * Reflect.deleteProperty()\n\n# 用一等函数替代操作符\n\n以下反射方法提供只有通过操作符才能完成的操作。\n\n * Reflect.get()：可以替代对象属性访问操作符。\n * Reflect.set()：可以替代=赋值操作符。\n * Reflect.has()：可以替代in 操作符或with()。\n * Reflect.deleteProperty()：可以替代delete 操作符。\n * Reflect.construct()：可以替代new 操作符。\n\n# 安全地应用函数\n\n在通过apply 方法调用函数时，被调用的函数可能也定义了自己的apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在Function 原型上的apply 方法，比如：\n\nFunction.prototype.apply.call(myFunc, thisVal, argumentList);\n\n\n1\n\n\n使用Reflect.apply() 可以避免这个问题：\n\nReflect.apply(myFunc, thisVal, argumentsList);\n\n\n1\n\n\n\n# 代理另一个代理\n\n代理可以拦截反射API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网。\n\n\n# 代理的问题与不足\n\n# 代理中的this\n\n代理潜在的一个问题来源是this 值。我们知道，方法中的this 通常指向调用这个方法的对象：\n\nconst target = {\n  thisValEqualsProxy() {\n    return this === proxy;\n  }\n}\nconst proxy = new Proxy(target, {});\nconsole.log(target.thisValEqualsProxy()); // false\nconsole.log(proxy.thisValEqualsProxy()); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如proxy.outerMethod()，而这个方法进而又会调用另一个方法，如this.innerMethod()，实际上都会调用proxy.innerMethod()。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。\n\nconst wm = new WeakMap();\nclass User {\n  constructor(userId) {\n    wm.set(this, userId);\n  }\n  set id(userId) {\n    wm.set(this, userId);\n  }\n  get id() {\n    return wm.get(this);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n由于这个实现依赖User 实例的对象标识，在这个实例被代理的情况下就会出问题：\n\nconst user = new User(123);\nconst proxy = new Proxy(user, {});\nconsole.log(proxy === user); // false\nconsole.log(proxy.id); // undefined\n\n\n1\n2\n3\n4\n\n\n这是因为User 实例一开始使用目标对象作为WeakMap 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理User 实例改为代理User 类本身。之后再创建代理的实例就会以代理实例作为WeakMap 的键了：\n\nconst UserClassProxy = new Proxy(User, {});\nconst proxyUser = new UserClassProxy(456);\nconsole.log(proxyUser.id);\n\n\n1\n2\n3\n\n\n# 代理与内部槽位\n\n代理与内置引用类型（比如Array）的实例通常可以很好地协同，但有些ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。\n\n一个典型的例子就是Date 类型。根据ECMAScript 规范，Date 类型方法的执行依赖this 值上的内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的get()和set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出TypeError：\n\nconst target = new Date();\nconst proxy = new Proxy(target, {});\nconsole.log(proxy instanceof Date); // true\nproxy.getDate(); // TypeError: 'this' is not a Date object\n\n\n1\n2\n3\n4\n\n\n\n# 代理捕获器与反射方法\n\n捕获器                                            方法定义                                                          目标方法\nget(target, property, receiver)                (target: T, propertyKey: PropertyKey, receiver: any) => any   Object.getPrototypeOf()\nset(target, property, value, receiver)         (target: T, propertyKey: PropertyKey, value: any, receiver:   Object.setPrototypeOf()\n                                               any) => boolean\nhas(target, property)                          (target: T, propertyKey: PropertyKey) => boolean              in 操作符\ndeleteProperty(target, property)               (target: T, propertyKey: PropertyKey) => boolean              delete 操作符\nownKeys(target)                                (target: T) => PropertyKey[]                                  Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.keys()\ngetOwnPropertyDescriptor(target, property)     (target: T, propertyKey: PropertyKey) => PropertyDescriptor   Object.getOwnPropertyDescriptors()、Object.getOwnPropertyDescriptor()\ndefineProperty(target, property, descriptor)   (target: T, propertyKey: PropertyKey, descriptor:             Object.defineProperty()、Object.defineProperties()\n                                               PropertyDescriptor) => boolean\nisExtensible(target)                           (target: T) => boolean                                        Object.isExtensible()\npreventExtensions(target)                      (target: T) => boolean                                        Object.preventExtensions()\ngetPrototypeOf(target)                         (target: T) => object                                         Object.getPrototypeOf()\nsetPrototypeOf(target, prototype)              (target: T, prototype: object) => boolean                     Object.setPrototypeOf()\napply(target, thisArg, argumentsList)          (target: T, thisArg: any, argumentsList: any[]) => any        Function.prototype.apply()、Function.prototype.call()\nconstruct(target, argumentsList, newTarget)    (target: T, argumentsList: any[], newTarget: any) => object   new 操作符\n\n\n# 代理模式\n\n\n# 跟踪属性访问\n\n通过捕获get、set 和has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过。\n\n\n# 隐藏属性\n\n代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。\n\n\n# 属性验证\n\n因为所有赋值操作都会触发set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值。\n\n\n# 函数与构造函数参数验证\n\n跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值\n\n\n# 数据绑定与可观察对象\n\n通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。\n\n比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：\n\nconst userList = [];\nclass User {\n  constructor(name) {\n    this.name_ = name;\n  }\n}\nconst proxy = new Proxy(User, {\n  construct() {\n    const newUser = Reflect.construct(...arguments);\n    userList.push(newUser);\n    return newUser;\n  }\n});\nnew proxy('John');\nnew proxy('Jacob');\nnew proxy('Jingleheimerschmidt');\nconsole.log(userList); // [User {}, User {}, User{}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：\n\nconst userList = [];\nfunction emit(newValue) {\n  console.log(newValue);\n}\nconst proxy = new Proxy(userList, {\n  set(target, property, value, receiver) {\n    const result = Reflect.set(...arguments);\n    if (result) {\n      emit(Reflect.get(target, property, receiver));\n    }\n    return result;\n  }\n});\nproxy.push('John');\n// John\nproxy.push('Jacob');\n// Jacob\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"ecmascript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。\n\n注意\n\n在es6 之前，ecmascript 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的ecmascript 代码，因为代理的行为实际上是无可替代的。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。\n\n\n# 代理基础\n\n在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。\n\nconst target = {\n  id: 'target'\n}\n\nconst handler = {}\n\nconst proxy = new proxy(target, handler)\n\n// id 属性是直接访问目标对象的\nconsole.log(target.id) // target\nconsole.log(proxy.id) // target\n\n// 给目标属性赋值会反映在两个对象上\ntarget.id = 'foo'\nconsole.log(target.id) // foo\nconsole.log(proxy.id) // foo\n\n// 在目标对象上定义一个新属性\ntarget.bar = 'bar'\nconsole.log(target.bar) // bar\nconsole.log(proxy.bar) // bar\n\n// hasownproperty()方法在两个地方\n// 都会应用到目标对象\nconsole.log(target.hasownproperty('id')); // true\nconsole.log(proxy.hasownproperty('id')); // true\n// proxy.prototype 是undefined\n// 因此不能使用instanceof 操作符\nconsole.log(target instanceof proxy); // typeerror: function has non-object prototype 'undefined' in instanceof check\nconsole.log(proxy instanceof proxy); // typeerror: function has non-object prototype 'undefined' in instanceof check\n// 严格相等可以用来区分代理和目标\nconsole.log(target === proxy); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 定义捕获器\n\n使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。\n\nconst target = {\n  foo: 'bar'\n}\n\nconst handler = {\n  // 捕获器在处理程序对象中以方法名为键\n  get() {\n    return 'handler override';\n  }\n}\n\nconst proxy = new proxy(target, handler);\nconsole.log(target.foo); // bar\nconsole.log(proxy.foo); // handler override\nconsole.log(target['foo']); // bar\nconsole.log(proxy['foo']); // handler override\nconsole.log(object.create(target)['foo']); // bar\nconsole.log(object.create(proxy)['foo']); // handler override\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 捕获器参数和反射api\n\n捕获器将会获得三个参数\n\n * 捕获对象 traptarget\n * 被捕获的属性 property\n * 接受捕获的代理 receiver\n\n所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局reflect 对象上（封装了原始行为）的同名方法来轻松重建。\n\n处理程序对象中所有可以捕获的方法都有对应的反射（reflect）api 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射api 也可以像下面这样定义出空代理对象：\n\nconst target = {\n  foo: 'bar'\n};\nconst handler = {\n  get() {\n    return reflect.get(...arguments);\n  }\n};\nconst proxy = new proxy(target, handler);\nconsole.log(proxy.foo); // bar\nconsole.log(target.foo); // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n更加简化的版本：\n\nconst target = {\nfoo: 'bar'\n};\n\nconst handler = {\nget: reflect.get\n};\nconst proxy = new proxy(target, handler);\nconsole.log(proxy.foo); // bar\nconsole.log(target.foo); // bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n反射api 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：\n\nconst target = {\n  foo: 'bar',\n  baz: 'qux'\n};\nconst handler = {\n  get(traptarget, property, receiver) {\n    let decoration = '';\n    if (property === 'foo') {\n      decoration = '!!!';\n    }\n    return reflect.get(...arguments) + decoration;\n  }\n};\nconst proxy = new proxy(target, handler);\nconsole.log(proxy.foo); // bar!!!\nconsole.log(target.foo); // bar\nconsole.log(proxy.baz); // qux\nconsole.log(target.baz); // qux\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 捕获器不变式\n\n使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出typeerror。\n\n\n# 可撤销代理\n\nconst { proxy, revoke } = proxy.revocable(target, handler);\nrevoke();\nconsole.log(proxy.foo); // typeerror: revoked\n\n\n1\n2\n3\n\n\n\n# 实用反射 api\n\n# reflect api 和 object api\n\n * 反射api 并不限于捕获处理程序\n * 大多数反射api方法在object类型上有对应的方法\n * object方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。\n\n很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射api 方法更有用。\n\n以下反射方法都会提供状态标记：\n\n * reflect.defineproperty()\n * reflect.preventextensions()\n * reflect.setprototypeof()\n * reflect.set()\n * reflect.deleteproperty()\n\n# 用一等函数替代操作符\n\n以下反射方法提供只有通过操作符才能完成的操作。\n\n * reflect.get()：可以替代对象属性访问操作符。\n * reflect.set()：可以替代=赋值操作符。\n * reflect.has()：可以替代in 操作符或with()。\n * reflect.deleteproperty()：可以替代delete 操作符。\n * reflect.construct()：可以替代new 操作符。\n\n# 安全地应用函数\n\n在通过apply 方法调用函数时，被调用的函数可能也定义了自己的apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在function 原型上的apply 方法，比如：\n\nfunction.prototype.apply.call(myfunc, thisval, argumentlist);\n\n\n1\n\n\n使用reflect.apply() 可以避免这个问题：\n\nreflect.apply(myfunc, thisval, argumentslist);\n\n\n1\n\n\n\n# 代理另一个代理\n\n代理可以拦截反射api 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网。\n\n\n# 代理的问题与不足\n\n# 代理中的this\n\n代理潜在的一个问题来源是this 值。我们知道，方法中的this 通常指向调用这个方法的对象：\n\nconst target = {\n  thisvalequalsproxy() {\n    return this === proxy;\n  }\n}\nconst proxy = new proxy(target, {});\nconsole.log(target.thisvalequalsproxy()); // false\nconsole.log(proxy.thisvalequalsproxy()); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如proxy.outermethod()，而这个方法进而又会调用另一个方法，如this.innermethod()，实际上都会调用proxy.innermethod()。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。\n\nconst wm = new weakmap();\nclass user {\n  constructor(userid) {\n    wm.set(this, userid);\n  }\n  set id(userid) {\n    wm.set(this, userid);\n  }\n  get id() {\n    return wm.get(this);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n由于这个实现依赖user 实例的对象标识，在这个实例被代理的情况下就会出问题：\n\nconst user = new user(123);\nconst proxy = new proxy(user, {});\nconsole.log(proxy === user); // false\nconsole.log(proxy.id); // undefined\n\n\n1\n2\n3\n4\n\n\n这是因为user 实例一开始使用目标对象作为weakmap 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理user 实例改为代理user 类本身。之后再创建代理的实例就会以代理实例作为weakmap 的键了：\n\nconst userclassproxy = new proxy(user, {});\nconst proxyuser = new userclassproxy(456);\nconsole.log(proxyuser.id);\n\n\n1\n2\n3\n\n\n# 代理与内部槽位\n\n代理与内置引用类型（比如array）的实例通常可以很好地协同，但有些ecmascript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。\n\n一个典型的例子就是date 类型。根据ecmascript 规范，date 类型方法的执行依赖this 值上的内部槽位[[numberdate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的get()和set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出typeerror：\n\nconst target = new date();\nconst proxy = new proxy(target, {});\nconsole.log(proxy instanceof date); // true\nproxy.getdate(); // typeerror: 'this' is not a date object\n\n\n1\n2\n3\n4\n\n\n\n# 代理捕获器与反射方法\n\n捕获器                                            方法定义                                                          目标方法\nget(target, property, receiver)                (target: t, propertykey: propertykey, receiver: any) => any   object.getprototypeof()\nset(target, property, value, receiver)         (target: t, propertykey: propertykey, value: any, receiver:   object.setprototypeof()\n                                               any) => boolean\nhas(target, property)                          (target: t, propertykey: propertykey) => boolean              in 操作符\ndeleteproperty(target, property)               (target: t, propertykey: propertykey) => boolean              delete 操作符\nownkeys(target)                                (target: t) => propertykey[]                                  object.getownpropertynames()、object.getownpropertysymbols()、object.keys()\ngetownpropertydescriptor(target, property)     (target: t, propertykey: propertykey) => propertydescriptor   object.getownpropertydescriptors()、object.getownpropertydescriptor()\ndefineproperty(target, property, descriptor)   (target: t, propertykey: propertykey, descriptor:             object.defineproperty()、object.defineproperties()\n                                               propertydescriptor) => boolean\nisextensible(target)                           (target: t) => boolean                                        object.isextensible()\npreventextensions(target)                      (target: t) => boolean                                        object.preventextensions()\ngetprototypeof(target)                         (target: t) => object                                         object.getprototypeof()\nsetprototypeof(target, prototype)              (target: t, prototype: object) => boolean                     object.setprototypeof()\napply(target, thisarg, argumentslist)          (target: t, thisarg: any, argumentslist: any[]) => any        function.prototype.apply()、function.prototype.call()\nconstruct(target, argumentslist, newtarget)    (target: t, argumentslist: any[], newtarget: any) => object   new 操作符\n\n\n# 代理模式\n\n\n# 跟踪属性访问\n\n通过捕获get、set 和has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过。\n\n\n# 隐藏属性\n\n代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。\n\n\n# 属性验证\n\n因为所有赋值操作都会触发set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值。\n\n\n# 函数与构造函数参数验证\n\n跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值\n\n\n# 数据绑定与可观察对象\n\n通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。\n\n比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：\n\nconst userlist = [];\nclass user {\n  constructor(name) {\n    this.name_ = name;\n  }\n}\nconst proxy = new proxy(user, {\n  construct() {\n    const newuser = reflect.construct(...arguments);\n    userlist.push(newuser);\n    return newuser;\n  }\n});\nnew proxy('john');\nnew proxy('jacob');\nnew proxy('jingleheimerschmidt');\nconsole.log(userlist); // [user {}, user {}, user{}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：\n\nconst userlist = [];\nfunction emit(newvalue) {\n  console.log(newvalue);\n}\nconst proxy = new proxy(userlist, {\n  set(target, property, value, receiver) {\n    const result = reflect.set(...arguments);\n    if (result) {\n      emit(reflect.get(target, property, receiver));\n    }\n    return result;\n  }\n});\nproxy.push('john');\n// john\nproxy.push('jacob');\n// jacob\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2024/08/31, 12:07:27",lastUpdatedTimestamp:1725077247e3},{title:"深度指南摘录",frontmatter:{title:"深度指南摘录",date:"2024-06-11T17:19:32.000Z",permalink:"/pages/ce368e/",categories:["前端","vue熟悉"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/05.vue%E7%86%9F%E6%82%89/01.%E6%B7%B1%E5%BA%A6%E6%8C%87%E5%8D%97%E6%91%98%E5%BD%95.html",relativePath:"01.前端/05.vue熟悉/01.深度指南摘录.md",key:"v-c53007e2",path:"/pages/ce368e/",headers:[{level:4,title:"新名词",slug:"新名词",normalizedTitle:"新名词",charIndex:70},{level:4,title:"知识点",slug:"知识点",normalizedTitle:"知识点",charIndex:160},{level:5,title:"HTML class 绑定的几种方式",slug:"html-class-绑定的几种方式",normalizedTitle:"html class 绑定的几种方式",charIndex:1336},{level:5,title:"在内联事件处理器中访问事件参数",slug:"在内联事件处理器中访问事件参数",normalizedTitle:"在内联事件处理器中访问事件参数",charIndex:2115},{level:5,title:"事件修饰符",slug:"事件修饰符",normalizedTitle:"事件修饰符",charIndex:2507}],headersStr:"新名词 知识点 HTML class 绑定的几种方式 在内联事件处理器中访问事件参数 事件修饰符",content:"提示\n\n在写这篇博客的时候，我已有半年时间左右没有接触过vue，此前对vue的了解还不够深入，希望通过阅读能够加深我对于vue的理解\n\n# 新名词\n\n * SFC（单文件组件）顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。\n\n# 知识点\n\n * createApp 可以创建应用实例，应用实例，如 app 的 mount 方法将会把应用挂在在某个容器内（如 '#app'），值得注意的是，挂载返回的是根组件实例，而不是应用实例，使用链式调用时要注意。\n * 应用实例会暴露出 config 属性，通过设置 config 属性的 errorHandler，可以捕获所有子组件上的错误。\n\napp.config.errorHanlder = err => {\n  // 对应的逻辑\n}\n\n\n1\n2\n3\n\n * 可以通过 app.component 注册全局组件\n\napp.component('MyComponent', MyComponent)\n\n\n1\n\n * createApp允许不止一个应用实例\n\n> 如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。\n\n * v-html 可以使用双大括号语法将对应的 html 插入到sfc中，但是可能存在 xss 风险\n\n> 在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞。请仅在内容安全可信时再使用 v-html，并且永远不要使用用户提供的 HTML 内容。\n\n * 当希望能够将多个属性绑定在一个组件中时，可以使用 v-bind = obj 语法将对象中的所有属性绑定到组件上。\n\n * vue模版中的表达式是受限的\n   \n   * 模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 Math 和 Date。\n   * 没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。然而，你也可以自行在 app.config.globalProperties 上显式地添加它们，供所有的 Vue 表达式使用。\n\n * 当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写。\n\n * shallowRef 可以放弃深层响应性，可以用来优化性能。\n\n * 与shallowRef对应的，还有 shallowReactive，可以放弃对对象的深层响应性。\n\n * 一个 ref 会在作为响应式对象的属性被访问或修改时自动解包。换句话说，它的行为就像一个普通的属性，如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref，只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为浅层响应式对象的属性被访问时不会解包。\n\n# HTML class 绑定的几种方式\n\n * :class=\"{ active: isActive, 'text-danger': hasError }\" 内联对象\n * 绑定对象\n\nconst classObject = reactive({\n  active: true,\n  'text-danger': false\n})\n\n<div :class=\"classObject\"></div>\n\n\n1\n2\n3\n4\n5\n6\n\n * 绑定一个计算属性（常用）\n\nconst isActive = ref(true)\nconst error = ref(null)\n\nconst classObject = computed(() => ({\n  active: isActive.value && !error.value,\n  'text-danger': error.value && error.value.type === 'fatal'\n}))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 绑定数组\n\nconst activeClass = ref('active')\nconst errorClass = ref('text-danger')\n\n<div :class=\"[activeClass, errorClass]\"></div>\n\n\n1\n2\n3\n4\n\n * 希望有条件地渲染某个表达式，可以使用三元表达式\n\n<div :class=\"[isActive ? activeClass : '', errorClass]\"></div>\n\n\n1\n\n\n * v-if 和 v-for 不建议同时使用，如果 v-if 占据了根元素，应该使用 template 来绑定 v-for\n\n * v-for 中的分隔符可以为 in 也可以为 for\n\n# 在内联事件处理器中访问事件参数\n\n\x3c!-- 使用特殊的 $event 变量 --\x3e\n<button @click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n\n\x3c!-- 使用内联箭头函数 --\x3e\n<button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\n  Submit\n</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nfunction warn(message, event) {\n  // 这里可以访问原生事件\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 事件修饰符\n\n * @event.stop stopPropagation 停止事件中捕获和冒泡事件的进一步传播\n * @event.prevent preventDefault 阻止默认事件的发生，如点击链接跳转",normalizedContent:"提示\n\n在写这篇博客的时候，我已有半年时间左右没有接触过vue，此前对vue的了解还不够深入，希望通过阅读能够加深我对于vue的理解\n\n# 新名词\n\n * sfc（单文件组件）顾名思义，vue 的单文件组件会将一个组件的逻辑 (javascript)，模板 (html) 和样式 (css) 封装在同一个文件里。\n\n# 知识点\n\n * createapp 可以创建应用实例，应用实例，如 app 的 mount 方法将会把应用挂在在某个容器内（如 '#app'），值得注意的是，挂载返回的是根组件实例，而不是应用实例，使用链式调用时要注意。\n * 应用实例会暴露出 config 属性，通过设置 config 属性的 errorhandler，可以捕获所有子组件上的错误。\n\napp.config.errorhanlder = err => {\n  // 对应的逻辑\n}\n\n\n1\n2\n3\n\n * 可以通过 app.component 注册全局组件\n\napp.component('mycomponent', mycomponent)\n\n\n1\n\n * createapp允许不止一个应用实例\n\n> 如果你正在使用 vue 来增强服务端渲染 html，并且只想要 vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。\n\n * v-html 可以使用双大括号语法将对应的 html 插入到sfc中，但是可能存在 xss 风险\n\n> 在网站上动态渲染任意 html 是非常危险的，因为这非常容易造成 xss 漏洞。请仅在内容安全可信时再使用 v-html，并且永远不要使用用户提供的 html 内容。\n\n * 当希望能够将多个属性绑定在一个组件中时，可以使用 v-bind = obj 语法将对象中的所有属性绑定到组件上。\n\n * vue模版中的表达式是受限的\n   \n   * 模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 math 和 date。\n   * 没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。然而，你也可以自行在 app.config.globalproperties 上显式地添加它们，供所有的 vue 表达式使用。\n\n * 当使用 dom 内嵌模板 (直接写在 html 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写。\n\n * shallowref 可以放弃深层响应性，可以用来优化性能。\n\n * 与shallowref对应的，还有 shallowreactive，可以放弃对对象的深层响应性。\n\n * 一个 ref 会在作为响应式对象的属性被访问或修改时自动解包。换句话说，它的行为就像一个普通的属性，如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref，只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为浅层响应式对象的属性被访问时不会解包。\n\n# html class 绑定的几种方式\n\n * :class=\"{ active: isactive, 'text-danger': haserror }\" 内联对象\n * 绑定对象\n\nconst classobject = reactive({\n  active: true,\n  'text-danger': false\n})\n\n<div :class=\"classobject\"></div>\n\n\n1\n2\n3\n4\n5\n6\n\n * 绑定一个计算属性（常用）\n\nconst isactive = ref(true)\nconst error = ref(null)\n\nconst classobject = computed(() => ({\n  active: isactive.value && !error.value,\n  'text-danger': error.value && error.value.type === 'fatal'\n}))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 绑定数组\n\nconst activeclass = ref('active')\nconst errorclass = ref('text-danger')\n\n<div :class=\"[activeclass, errorclass]\"></div>\n\n\n1\n2\n3\n4\n\n * 希望有条件地渲染某个表达式，可以使用三元表达式\n\n<div :class=\"[isactive ? activeclass : '', errorclass]\"></div>\n\n\n1\n\n\n * v-if 和 v-for 不建议同时使用，如果 v-if 占据了根元素，应该使用 template 来绑定 v-for\n\n * v-for 中的分隔符可以为 in 也可以为 for\n\n# 在内联事件处理器中访问事件参数\n\n\x3c!-- 使用特殊的 $event 变量 --\x3e\n<button @click=\"warn('form cannot be submitted yet.', $event)\">\n  submit\n</button>\n\n\x3c!-- 使用内联箭头函数 --\x3e\n<button @click=\"(event) => warn('form cannot be submitted yet.', event)\">\n  submit\n</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nfunction warn(message, event) {\n  // 这里可以访问原生事件\n  if (event) {\n    event.preventdefault()\n  }\n  alert(message)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 事件修饰符\n\n * @event.stop stoppropagation 停止事件中捕获和冒泡事件的进一步传播\n * @event.prevent preventdefault 阻止默认事件的发生，如点击链接跳转",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"sass基础",frontmatter:{title:"sass基础",date:"2024-06-08T15:37:44.000Z",permalink:"/pages/29c00e/",categories:["前端","sass"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/04.sass/02.sass%E5%9F%BA%E7%A1%80.html",relativePath:"01.前端/04.sass/02.sass基础.md",key:"v-b22aca30",path:"/pages/29c00e/",headers:[{level:3,title:"CSS 拓展",slug:"css-拓展",normalizedTitle:"css 拓展",charIndex:2},{level:4,title:"属性嵌套",slug:"属性嵌套",normalizedTitle:"属性嵌套",charIndex:30},{level:4,title:"占位符选择器",slug:"占位符选择器",normalizedTitle:"占位符选择器",charIndex:266},{level:4,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:545},{level:3,title:"混合指令",slug:"混合指令",normalizedTitle:"混合指令",charIndex:742},{level:3,title:"控制指令",slug:"控制指令",normalizedTitle:"控制指令",charIndex:878},{level:3,title:"sass 函数",slug:"sass-函数",normalizedTitle:"sass 函数",charIndex:1616}],headersStr:"CSS 拓展 属性嵌套 占位符选择器 注释 混合指令 控制指令 sass 函数",content:"# CSS 拓展\n\nsass拓展了css的选择器功能\n\n# 属性嵌套\n\n.funky {\n  font: 20px/24px { // font 本身也可以带属性\n    family: fantasy; // 将会编译 font-family\n    weight: bold;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n编译为 -> css\n\n.funky {\n  font: 20px/24px;\n  font-family: fantasy;\n  font-weight: bold;\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 占位符选择器\n\n// This ruleset won't be rendered on its own.\n#context a%extreme {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em;\n}\n.notice {\n  @extend %extreme;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n->\n\n#context a.notice {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em; }\n\n\n1\n2\n3\n4\n\n\n# 注释\n\n * 段注释不会被编译删除，行注释会被编译删除\n\n * 段注释的第一个字符加入 ! 表示在压缩情况下保留这个注释，通常用于保留版权信息\n\n * 插值语句在段注释中也可以输出变量值\n\n$version: '1.2.3';\n/* This CSS is generated by My Snazzy Framework version #{$version}. */\n\n\n1\n2\n\n\n\n# 混合指令\n\n * @import 用于导入样式\n * @media 的 queries 允许互相嵌套使用，在编译时，sass将会自动添加 and\n * @extend 可以实现样式的继承，在占位符选择器中有体现\n * @at-root 可以实现将选择器向外部提取\n\n\n# 控制指令\n\n$type: monster;\np {\n  @if $type == ocean {\n    color: blue;\n  } @else if $type == matador {\n    color: red;\n  } @else if $type == monster {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 使用 @if @else if @else可以实现控制流，在不同逻辑下输出不同的值\n * @for 实现 for 循环\n * @each 实现 each 循环\n * each循环支持多个变量的同时循环\n\n@each $animal, $color, $cursor in (puma, black, default),\n                                  (sea-slug, blue, pointer),\n                                  (egret, white, move) {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n    border: 2px solid $color;\n    cursor: $cursor;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * while 实现 do-while循环\n * @mixin 结合 @include 可以实现类的混入，同时 @mixin 可以传入参数\n\n\n# sass 函数\n\n * 在 sass 中可以定义函数，在封装大型库的过程中经常会用到\n\n$grid-width: 40px;\n$gutter-width: 10px;\n\n@function grid-width($n) {\n  @return $n * $grid-width + ($n - 1) * $gutter-width;\n}\n\n#sidebar { width: grid-width(5); }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# css 拓展\n\nsass拓展了css的选择器功能\n\n# 属性嵌套\n\n.funky {\n  font: 20px/24px { // font 本身也可以带属性\n    family: fantasy; // 将会编译 font-family\n    weight: bold;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n编译为 -> css\n\n.funky {\n  font: 20px/24px;\n  font-family: fantasy;\n  font-weight: bold;\n}\n\n\n1\n2\n3\n4\n5\n\n\n# 占位符选择器\n\n// this ruleset won't be rendered on its own.\n#context a%extreme {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em;\n}\n.notice {\n  @extend %extreme;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n->\n\n#context a.notice {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em; }\n\n\n1\n2\n3\n4\n\n\n# 注释\n\n * 段注释不会被编译删除，行注释会被编译删除\n\n * 段注释的第一个字符加入 ! 表示在压缩情况下保留这个注释，通常用于保留版权信息\n\n * 插值语句在段注释中也可以输出变量值\n\n$version: '1.2.3';\n/* this css is generated by my snazzy framework version #{$version}. */\n\n\n1\n2\n\n\n\n# 混合指令\n\n * @import 用于导入样式\n * @media 的 queries 允许互相嵌套使用，在编译时，sass将会自动添加 and\n * @extend 可以实现样式的继承，在占位符选择器中有体现\n * @at-root 可以实现将选择器向外部提取\n\n\n# 控制指令\n\n$type: monster;\np {\n  @if $type == ocean {\n    color: blue;\n  } @else if $type == matador {\n    color: red;\n  } @else if $type == monster {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 使用 @if @else if @else可以实现控制流，在不同逻辑下输出不同的值\n * @for 实现 for 循环\n * @each 实现 each 循环\n * each循环支持多个变量的同时循环\n\n@each $animal, $color, $cursor in (puma, black, default),\n                                  (sea-slug, blue, pointer),\n                                  (egret, white, move) {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n    border: 2px solid $color;\n    cursor: $cursor;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * while 实现 do-while循环\n * @mixin 结合 @include 可以实现类的混入，同时 @mixin 可以传入参数\n\n\n# sass 函数\n\n * 在 sass 中可以定义函数，在封装大型库的过程中经常会用到\n\n$grid-width: 40px;\n$gutter-width: 10px;\n\n@function grid-width($n) {\n  @return $n * $grid-width + ($n - 1) * $gutter-width;\n}\n\n#sidebar { width: grid-width(5); }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"写在前面",frontmatter:{title:"写在前面",date:"2024-06-08T15:11:55.000Z",permalink:"/pages/d0e9c2/",categories:["前端","sass"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/04.sass/01.%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2.html",relativePath:"01.前端/04.sass/01.写在前面.md",key:"v-f25adb98",path:"/pages/d0e9c2/",headersStr:null,content:"提示\n\n写这篇博客是因为自己在看element-plus前期发现了sass的强大之处，于是打算补足自己在sass方面的知识",normalizedContent:"提示\n\n写这篇博客是因为自己在看element-plus前期发现了sass的强大之处，于是打算补足自己在sass方面的知识",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"opensumi介绍与使用",frontmatter:{title:"opensumi介绍与使用",date:"2024-07-30T14:16:15.000Z",permalink:"/pages/8232ec/",categories:["前端","opensumi"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/07.opensumi/01.opensumi%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8.html",relativePath:"01.前端/07.opensumi/01.opensumi介绍与使用.md",key:"v-2d76ceaa",path:"/pages/8232ec/",headersStr:null,content:"# opensumi 介绍\n\nOpenSumi 框架旨在解决阿里经济体内部 IDE 产品研发的重复建设问题，满足 IDE 在更多垂直场景的定制能力，同时实现 Web 与本地客户端共用底层，让 IDE 研发从早期的“刀耕火种”时代向“机器化大生产”时代迈进。\n\n\n# 使用场景\n\n * 定制化 IDE\n * code Server\n * 纯前端 IDE\n\n\n# 参考链接\n\nopensumi",normalizedContent:"# opensumi 介绍\n\nopensumi 框架旨在解决阿里经济体内部 ide 产品研发的重复建设问题，满足 ide 在更多垂直场景的定制能力，同时实现 web 与本地客户端共用底层，让 ide 研发从早期的“刀耕火种”时代向“机器化大生产”时代迈进。\n\n\n# 使用场景\n\n * 定制化 ide\n * code server\n * 纯前端 ide\n\n\n# 参考链接\n\nopensumi",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"介绍与使用",frontmatter:{title:"介绍与使用",date:"2024-07-30T14:18:25.000Z",permalink:"/pages/5f1228/",categories:["前端","WebContainer"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/08.WebContainer/01.%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8.html",relativePath:"01.前端/08.WebContainer/01.介绍与使用.md",key:"v-54609122",path:"/pages/5f1228/",headersStr:null,content:"# WebContainer介绍\n\n> WebContainers are a browser-based runtime for executing Node.js applications and operating system commands, entirely inside your browser tab. Apps that previously required cloud VMs to execute user code, in WebContainers can run entirely client-side with a number of benefits over the legacy cloud VM.\n\nWebContainers 可以在浏览器端构建一个内置 NodeJS 环境的容器，在容器内部可以自由使用 NodeJS API\n\n\n# WebContainer使用场景\n\n * 在线PR编辑\n\n * 能力演示（如Vite）vite online\n\n\n# 参考链接\n\nWebContainers",normalizedContent:"# webcontainer介绍\n\n> webcontainers are a browser-based runtime for executing node.js applications and operating system commands, entirely inside your browser tab. apps that previously required cloud vms to execute user code, in webcontainers can run entirely client-side with a number of benefits over the legacy cloud vm.\n\nwebcontainers 可以在浏览器端构建一个内置 nodejs 环境的容器，在容器内部可以自由使用 nodejs api\n\n\n# webcontainer使用场景\n\n * 在线pr编辑\n\n * 能力演示（如vite）vite online\n\n\n# 参考链接\n\nwebcontainers",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"indexedDB的应用",frontmatter:{title:"indexedDB的应用",date:"2024-07-30T14:08:07.000Z",permalink:"/pages/78c7e2/",categories:["前端","前端存储"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/06.%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/01.indexedDB%E7%9A%84%E5%BA%94%E7%94%A8.html",relativePath:"01.前端/06.前端存储/01.indexedDB的应用.md",key:"v-7a0ca7fb",path:"/pages/78c7e2/",headersStr:null,content:"提示\n\n当想要在浏览器端缓存大量数据时，可以考虑使用 indexedDB，作为浏览器维护的数据库，indexedDB可以保存大量的数据，同时本身具有较高的安全性。\n\n\n# indexedDB 的特点\n\n 1. 存储容量取决于磁盘空间\n 2. 本身具有较好的 TypeScript 支持\n 3. 受同源策略保护，同一个域名共享 indexedDB\n\n\n# 参考\n\nmdn indexedDB",normalizedContent:"提示\n\n当想要在浏览器端缓存大量数据时，可以考虑使用 indexeddb，作为浏览器维护的数据库，indexeddb可以保存大量的数据，同时本身具有较高的安全性。\n\n\n# indexeddb 的特点\n\n 1. 存储容量取决于磁盘空间\n 2. 本身具有较好的 typescript 支持\n 3. 受同源策略保护，同一个域名共享 indexeddb\n\n\n# 参考\n\nmdn indexeddb",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"前端性能优化",frontmatter:{title:"前端性能优化",date:"2024-07-30T14:48:25.000Z",permalink:"/pages/f51e80/",categories:["前端","性能优化"],tags:["核心技术","性能优化"],author:{name:"leon yu",link:"https://github.com/lampeggiante"},sticky:3},regularPath:"/01.%E5%89%8D%E7%AB%AF/10.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/01.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",relativePath:"01.前端/10.性能优化/01.前端性能优化.md",key:"v-15eb2aee",path:"/pages/f51e80/",headers:[{level:2,title:"前端性能优化的定义",slug:"前端性能优化的定义",normalizedTitle:"前端性能优化的定义",charIndex:51},{level:3,title:"前端的定义",slug:"前端的定义",normalizedTitle:"前端的定义",charIndex:65},{level:3,title:"web performance",slug:"web-performance",normalizedTitle:"web performance",charIndex:139},{level:3,title:"web 生命周期的三个阶段",slug:"web-生命周期的三个阶段",normalizedTitle:"web 生命周期的三个阶段",charIndex:1239},{level:3,title:"性能优化的定义",slug:"性能优化的定义",normalizedTitle:"性能优化的定义",charIndex:53},{level:2,title:"为什么要做性能优化",slug:"为什么要做性能优化",normalizedTitle:"为什么要做性能优化",charIndex:1387},{level:3,title:"性能是系统设计的标尺",slug:"性能是系统设计的标尺",normalizedTitle:"性能是系统设计的标尺",charIndex:1435},{level:3,title:"性能优化有助于提高业务转化率",slug:"性能优化有助于提高业务转化率",normalizedTitle:"性能优化有助于提高业务转化率",charIndex:1524},{level:3,title:"性能优化的原则",slug:"性能优化的原则",normalizedTitle:"性能优化的原则",charIndex:1584},{level:2,title:"W3C performance",slug:"w3c-performance",normalizedTitle:"w3c performance",charIndex:1688},{level:2,title:"lighthouse 指标",slug:"lighthouse-指标",normalizedTitle:"lighthouse 指标",charIndex:2268},{level:2,title:"常用性能检测工具",slug:"常用性能检测工具",normalizedTitle:"常用性能检测工具",charIndex:2514},{level:2,title:"性能的影响因素",slug:"性能的影响因素",normalizedTitle:"性能的影响因素",charIndex:2589},{level:2,title:"网络优化",slug:"网络优化",normalizedTitle:"网络优化",charIndex:2648},{level:2,title:"渲染优化",slug:"渲染优化",normalizedTitle:"渲染优化",charIndex:2865},{level:3,title:"布局抖动",slug:"布局抖动",normalizedTitle:"布局抖动",charIndex:2951}],headersStr:"前端性能优化的定义 前端的定义 web performance web 生命周期的三个阶段 性能优化的定义 为什么要做性能优化 性能是系统设计的标尺 性能优化有助于提高业务转化率 性能优化的原则 W3C performance lighthouse 指标 常用性能检测工具 性能的影响因素 网络优化 渲染优化 布局抖动",content:"注意\n\n内容非原创，仅做整理。仅供学习交流，不作商用，请勿转载！\n\n\n# 介绍：前端性能优化\n\n\n# 前端性能优化的定义\n\n\n# 前端的定义\n\n前端是直接面向用户的接口，负责与用户行为发生交互\n\n常见的前端场景：PC、移动端、终端、Web、H5、Android、iOS\n\n\n# web performance\n\n> Web performance is the objective measurements and the perceived user experience of load time and runtime. Web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions - is the scrolling smooth? are buttons clickable? Are pop-ups quick to load and display, and do they animate smoothly as they do so? Web performance includes both objective measurements like time to load, frames per second, and time to become interactive, and subjective experiences of how long it felt like it took the content to load.\n\n网页性能是评判网页在加载与运行时，用户可感知的使用体验的客观指标。前端性能包含一些常见的指标：加载时间，帧率，网页可交互的时间，主观感受内容的加载时间。\n\n> The longer it takes for a site to respond, the more users will abandon the site. It is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.\n\n网页响应用户操作的时间越长，会导致更多的用户放弃使用这个网站。因此，最大化减少加载和响应时间，让功能变得尽快可用与具有交互性。\n\n\n# web 生命周期的三个阶段\n\n 1. 加载阶段： 发出请求到渲染出完整页面的过程\n 2. 交互阶段：从页面加载完成到用户交互的整个过程\n 3. 关闭阶段：用户发出关闭指令后页面所做的一些清理工作\n\n\n# 性能优化的定义\n\n在Web页面的整个生命周期中，占用更小的资源，以更快的速度运行。\n\n\n# 为什么要做性能优化\n\n性能优化有助于让产品具有更好的使用体验，从而做到更高的业务转化率\n\n\n# 性能是系统设计的标尺\n\n 1. 《高并发系统设计40问》中指出，高并发系统的设计目标为高可用、高性能、高扩展\n 2. 前端产品的设计要考虑性能、稳定性、易用性、可扩展性\n\n\n# 性能优化有助于提高业务转化率\n\n根据 Google 的统计数据，性能越好的网页，用户离开的比率会越小（跳失率）\n\n\n# 性能优化的原则\n\n 1. 性能优化是问题导向的，不是无中生有\n 2. 要遵从二八定律，把握性能优化的关键指标\n 3. 要找到数据支撑\n 4. 持续、分阶段的优化\n\n\n# 衡量：常用的前端性能优化指标\n\n\n# W3C performance\n\n\n\n 1.  DNS解析耗时: domainLookupEnd - domainLookupStart\n 2.  TCP连接耗时: connectEnd - connectStart\n 3.  SSL安全连接耗时: connectEnd - secureConnectionStart\n 4.  网络请求耗时(TTFB): responseStart - requestStart\n 5.  数据传输耗时: responseEnd - responseStart\n 6.  DOM解析耗时: domInteractive - responseEnd\n 7.  资源加载耗时: loadEventStart - domContentLoadedEventEnd\n 8.  首包时间: responseStart - domainLookupStart\n 9.  首次渲染时间 / 白屏时间: responseEnd - fetchStart\n 10. 首次可交互时间: domInteractive - fetchStart\n 11. DOM Ready时间: domContentLoadEventEnd - fetchStart\n 12. ⻚面完全加载时间: loadEventStart - fetchStart\n\n\n# lighthouse 指标\n\n 1. FCP - First Contentful Paint(首次内容渲染)\n 2. SI - Speed Index(速度指数)\n 3. LCP - Largest Contentful Paint(最大内容绘制)\n 4. TTI - Time to Interactive(可交互时间)\n 5. TBT - Total Blocking Time(总阻塞时间)\n 6. CLS - Cumulative Layout Shift(累积布局偏移)\n\n\n# 常用性能检测工具\n\n * chorome performance\n * chorome lighthouse\n\n\n# 方法：如何进行性能优化\n\n\n# 性能的影响因素\n\n * 用户的使用环境\n * 站点自身的性能表现\n   * 网络性能\n   * 渲染性能\n\n\n\n\n# 网络优化\n\n * 减少关键资源数\n * 减少关键资源的RTT（round-trip time）\n   * 升级HTTP协议\n   * 使用HTTP缓存\n   * 优化接口请求\n   * 使用数据缓存\n   * DNS预解析\n   * 使用CDN\n   * 减少关键资源的个数和减少关键资源的大小搭配\n * 减少关键资源的大小\n   * 代码分割\n   * 压缩\n   * 静态资源服务器开启Gzip\n   * 非首屏延迟加载\n\n\n# 渲染优化\n\n\n\n * 提高单帧的渲染速度\n   * 合成线程 > 重绘 > 重排（影响从小到大）\n     * 合理利用 css 合成动画\n     * 避免强制同步布局和布局抖动\n       * DOM 批处理\n       * transform\n   * 避免频繁的垃圾回收\n   * 减少JS文件的执行时间\n     * 长任务拆分\n     * 优化代码执行逻辑\n       * 合理的错误处理\n       * 串行接口优化\n       * 空间换时间\n       * 按需加载\n       * 图表渲染优化\n     * 耗时的计算任务移除主线程\n\n\n# 布局抖动\n\n在一段JS代码中，反复执行布局操作，就是布局抖动",normalizedContent:"注意\n\n内容非原创，仅做整理。仅供学习交流，不作商用，请勿转载！\n\n\n# 介绍：前端性能优化\n\n\n# 前端性能优化的定义\n\n\n# 前端的定义\n\n前端是直接面向用户的接口，负责与用户行为发生交互\n\n常见的前端场景：pc、移动端、终端、web、h5、android、ios\n\n\n# web performance\n\n> web performance is the objective measurements and the perceived user experience of load time and runtime. web performance is how long a site takes to load, become interactive and responsive, and how smooth the content is during user interactions - is the scrolling smooth? are buttons clickable? are pop-ups quick to load and display, and do they animate smoothly as they do so? web performance includes both objective measurements like time to load, frames per second, and time to become interactive, and subjective experiences of how long it felt like it took the content to load.\n\n网页性能是评判网页在加载与运行时，用户可感知的使用体验的客观指标。前端性能包含一些常见的指标：加载时间，帧率，网页可交互的时间，主观感受内容的加载时间。\n\n> the longer it takes for a site to respond, the more users will abandon the site. it is important to minimize the loading and response times and add additional features to conceal latency by making the experience as available and interactive as possible, as soon as possible, while asynchronously loading in the longer tail parts of the experience.\n\n网页响应用户操作的时间越长，会导致更多的用户放弃使用这个网站。因此，最大化减少加载和响应时间，让功能变得尽快可用与具有交互性。\n\n\n# web 生命周期的三个阶段\n\n 1. 加载阶段： 发出请求到渲染出完整页面的过程\n 2. 交互阶段：从页面加载完成到用户交互的整个过程\n 3. 关闭阶段：用户发出关闭指令后页面所做的一些清理工作\n\n\n# 性能优化的定义\n\n在web页面的整个生命周期中，占用更小的资源，以更快的速度运行。\n\n\n# 为什么要做性能优化\n\n性能优化有助于让产品具有更好的使用体验，从而做到更高的业务转化率\n\n\n# 性能是系统设计的标尺\n\n 1. 《高并发系统设计40问》中指出，高并发系统的设计目标为高可用、高性能、高扩展\n 2. 前端产品的设计要考虑性能、稳定性、易用性、可扩展性\n\n\n# 性能优化有助于提高业务转化率\n\n根据 google 的统计数据，性能越好的网页，用户离开的比率会越小（跳失率）\n\n\n# 性能优化的原则\n\n 1. 性能优化是问题导向的，不是无中生有\n 2. 要遵从二八定律，把握性能优化的关键指标\n 3. 要找到数据支撑\n 4. 持续、分阶段的优化\n\n\n# 衡量：常用的前端性能优化指标\n\n\n# w3c performance\n\n\n\n 1.  dns解析耗时: domainlookupend - domainlookupstart\n 2.  tcp连接耗时: connectend - connectstart\n 3.  ssl安全连接耗时: connectend - secureconnectionstart\n 4.  网络请求耗时(ttfb): responsestart - requeststart\n 5.  数据传输耗时: responseend - responsestart\n 6.  dom解析耗时: dominteractive - responseend\n 7.  资源加载耗时: loadeventstart - domcontentloadedeventend\n 8.  首包时间: responsestart - domainlookupstart\n 9.  首次渲染时间 / 白屏时间: responseend - fetchstart\n 10. 首次可交互时间: dominteractive - fetchstart\n 11. dom ready时间: domcontentloadeventend - fetchstart\n 12. ⻚面完全加载时间: loadeventstart - fetchstart\n\n\n# lighthouse 指标\n\n 1. fcp - first contentful paint(首次内容渲染)\n 2. si - speed index(速度指数)\n 3. lcp - largest contentful paint(最大内容绘制)\n 4. tti - time to interactive(可交互时间)\n 5. tbt - total blocking time(总阻塞时间)\n 6. cls - cumulative layout shift(累积布局偏移)\n\n\n# 常用性能检测工具\n\n * chorome performance\n * chorome lighthouse\n\n\n# 方法：如何进行性能优化\n\n\n# 性能的影响因素\n\n * 用户的使用环境\n * 站点自身的性能表现\n   * 网络性能\n   * 渲染性能\n\n\n\n\n# 网络优化\n\n * 减少关键资源数\n * 减少关键资源的rtt（round-trip time）\n   * 升级http协议\n   * 使用http缓存\n   * 优化接口请求\n   * 使用数据缓存\n   * dns预解析\n   * 使用cdn\n   * 减少关键资源的个数和减少关键资源的大小搭配\n * 减少关键资源的大小\n   * 代码分割\n   * 压缩\n   * 静态资源服务器开启gzip\n   * 非首屏延迟加载\n\n\n# 渲染优化\n\n\n\n * 提高单帧的渲染速度\n   * 合成线程 > 重绘 > 重排（影响从小到大）\n     * 合理利用 css 合成动画\n     * 避免强制同步布局和布局抖动\n       * dom 批处理\n       * transform\n   * 避免频繁的垃圾回收\n   * 减少js文件的执行时间\n     * 长任务拆分\n     * 优化代码执行逻辑\n       * 合理的错误处理\n       * 串行接口优化\n       * 空间换时间\n       * 按需加载\n       * 图表渲染优化\n     * 耗时的计算任务移除主线程\n\n\n# 布局抖动\n\n在一段js代码中，反复执行布局操作，就是布局抖动",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"前言",frontmatter:{title:"前言",date:"2024-07-07T16:10:04.000Z",permalink:"/pages/ce5e4c/",categories:["前端","卡颂React"],tags:[null],sticky:[4],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/11.%E5%8D%A1%E9%A2%82React/01.%E5%89%8D%E8%A8%80.html",relativePath:"01.前端/11.卡颂React/01.前言.md",key:"v-7ac371b2",path:"/pages/ce5e4c/",headersStr:null,content:"提示\n\n学习 react 框架，让我了解一下前端框架的鼻祖到底是咋实现的。根据卡颂的教程一步一步来，减少学习的压力~",normalizedContent:"提示\n\n学习 react 框架，让我了解一下前端框架的鼻祖到底是咋实现的。根据卡颂的教程一步一步来，减少学习的压力~",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"小试牛刀",frontmatter:{title:"小试牛刀",date:"2024-07-07T20:22:13.000Z",permalink:"/pages/98715f/",categories:["前端","卡颂React"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/11.%E5%8D%A1%E9%A2%82React/03.%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80.html",relativePath:"01.前端/11.卡颂React/03.小试牛刀.md",key:"v-58a1fe2f",path:"/pages/98715f/",headers:[{level:4,title:"完成jsx功能后进行调试",slug:"完成jsx功能后进行调试",normalizedTitle:"完成jsx功能后进行调试",charIndex:2}],headersStr:"完成jsx功能后进行调试",content:"# 完成jsx功能后进行调试\n\n进入 react 包后使用 pnpm link --global 将全局的react项目指向打包后的产物\n\n新建一个新项目，将新项目的包指向全局react包，即可进行调试\n\n注意\n\n跟着写项目较为低效，将策略改为看视频入门，看源码学习",normalizedContent:"# 完成jsx功能后进行调试\n\n进入 react 包后使用 pnpm link --global 将全局的react项目指向打包后的产物\n\n新建一个新项目，将新项目的包指向全局react包，即可进行调试\n\n注意\n\n跟着写项目较为低效，将策略改为看视频入门，看源码学习",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"介绍与使用",frontmatter:{title:"介绍与使用",date:"2024-07-30T14:23:42.000Z",permalink:"/pages/8c2210/",categories:["前端","storybook"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/09.storybook/01.%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8.html",relativePath:"01.前端/09.storybook/01.介绍与使用.md",key:"v-8ee5acb4",path:"/pages/8c2210/",headersStr:null,content:"# storyboook 介绍\n\n> Storybook is a frontend workshop for building UI components and pages in isolation. Thousands of teams use it for UI development, testing, and documentation. It's open source and free.\n\n用于 UI 构建与演示，主要特点是开箱即用\n\n\n# 使用场景\n\n * 对不同样式的 UI 进行展示\n * 如果自己创建了一个组件库，可以考虑使用 storybook 进行部署\n\n\n# 参考链接\n\nstorybook",normalizedContent:"# storyboook 介绍\n\n> storybook is a frontend workshop for building ui components and pages in isolation. thousands of teams use it for ui development, testing, and documentation. it's open source and free.\n\n用于 ui 构建与演示，主要特点是开箱即用\n\n\n# 使用场景\n\n * 对不同样式的 ui 进行展示\n * 如果自己创建了一个组件库，可以考虑使用 storybook 进行部署\n\n\n# 参考链接\n\nstorybook",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"环境搭建",frontmatter:{title:"环境搭建",date:"2024-07-07T16:14:57.000Z",permalink:"/pages/d36b61/",categories:["前端","卡颂React"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/11.%E5%8D%A1%E9%A2%82React/02.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"01.前端/11.卡颂React/02.环境搭建.md",key:"v-5a9cb89d",path:"/pages/d36b61/",headers:[{level:4,title:"前期准备",slug:"前期准备",normalizedTitle:"前期准备",charIndex:2}],headersStr:"前期准备",content:"# 前期准备\n\n * 安装好 pnpm，使用 monorepo 进行项目管理\n * 使用 eslint 做代码规范管理，-D表示设置为依赖，-w表示为根目录下的依赖\n * 配置了 husky prettier lint-staged\n * 选择 rollup 作为打包工具，打包工具比较",normalizedContent:"# 前期准备\n\n * 安装好 pnpm，使用 monorepo 进行项目管理\n * 使用 eslint 做代码规范管理，-d表示设置为依赖，-w表示为根目录下的依赖\n * 配置了 husky prettier lint-staged\n * 选择 rollup 作为打包工具，打包工具比较",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"面向对象",frontmatter:{title:"面向对象",date:"2024-09-11T16:53:33.000Z",permalink:"/pages/59645f/",categories:["前端","JS基础"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/12.JS%E5%9F%BA%E7%A1%80/01.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"01.前端/12.JS基础/01.面向对象.md",key:"v-5ab4e514",path:"/pages/59645f/",headers:[{level:2,title:"创建对象的模式",slug:"创建对象的模式",normalizedTitle:"创建对象的模式",charIndex:2},{level:3,title:"工厂模式创建对象",slug:"工厂模式创建对象",normalizedTitle:"工厂模式创建对象",charIndex:14},{level:2,title:"构造函数模式",slug:"构造函数模式",normalizedTitle:"构造函数模式",charIndex:267},{level:4,title:"构造函数创建对象的过程",slug:"构造函数创建对象的过程",normalizedTitle:"构造函数创建对象的过程",charIndex:481},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:1787},{level:3,title:"什么是原型链",slug:"什么是原型链",normalizedTitle:"什么是原型链",charIndex:1794},{level:3,title:"原型链继承",slug:"原型链继承",normalizedTitle:"原型链继承",charIndex:1935},{level:3,title:"构造函数继承（经典继承）",slug:"构造函数继承-经典继承",normalizedTitle:"构造函数继承（经典继承）",charIndex:2312},{level:3,title:"组合式继承",slug:"组合式继承",normalizedTitle:"组合式继承",charIndex:2892},{level:3,title:"原型式继承",slug:"原型式继承",normalizedTitle:"原型式继承",charIndex:3334},{level:3,title:"寄生式继承",slug:"寄生式继承",normalizedTitle:"寄生式继承",charIndex:3839},{level:3,title:"寄生组合式继承",slug:"寄生组合式继承",normalizedTitle:"寄生组合式继承",charIndex:4264},{level:3,title:"使用 function 实现 class",slug:"使用-function-实现-class",normalizedTitle:"使用 function 实现 class",charIndex:4694},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:5631}],headersStr:"创建对象的模式 工厂模式创建对象 构造函数模式 构造函数创建对象的过程 继承 什么是原型链 原型链继承 构造函数继承（经典继承） 组合式继承 原型式继承 寄生式继承 寄生组合式继承 使用 function 实现 class 参考文章",content:"# 创建对象的模式\n\n\n# 工厂模式创建对象\n\n顾名思义，传入约定好的对象属性，产生如流水线一般的对象。\n\nfunction createPerson(name, age, job) {\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  o.job = job;\n  o.sayName = function() {\n    console.log(this.name);\n  };\n  return o;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 构造函数模式\n\n与工厂模式十分相似，不同的地方在于需要使用 new 关键字调用\n\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function () {\n    console.log(this.name)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 构造函数创建对象的过程\n\n通过构造函数创建实例会执行如下操作：\n\n * 在内存中创建一个新对象\n * 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数的 prototype 属性\n * 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）\n * 执行构造函数内部的代码（给新对象添加属性）\n * 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象\n\n因而可以引出手写 new\n\nfunction myNew (fn, ...args) {\n  const obj = Object.create(fn.prototype)\n  const res = fn.call(obj, ...args)\n  return typeof res === 'object' ? obj : res\n}\n\n\n1\n2\n3\n4\n5\n\n\n在手写 new 中，用到了 Object.create\n\n手写Object.create\n\nfunction createObject (obj) {\n  function F () {}\n  F.prototype = obj\n  return new F()\n}\n\n\n1\n2\n3\n4\n5\n\n\n另外涉及到原型链的还有 instanceOf\n\n手写 instanceOf\n\n/** 递归法 */\nfunction myInstanceof(obj, fn) {\n  if (!fn.prototype) {\n    throw Error(\"Right-hand side of 'instanceof' is not callable\")\n  }\n  const proto = Object.getPrototypeOf(obj)\n  if (proto) {\n    if (proto === fn.prototype) {\n      return true\n    }\n    return myInstanceof(proto, fn)\n  }\n  return false\n}\n\n/** 迭代法 */\nfunction myInstanceof2(obj, fn) {\n  if (!fn.prototype) {\n    throw Error(\"Right-hand side of 'instanceof' is not callable\")\n  }\n  let proto = Object.getPrototypeOf(obj)\n  const target = fn.prototype\n  while (true) {\n    if (!proto) return false\n    if (proto === target) return true\n    proto = Object.getPrototypeOf(proto)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 继承\n\n\n# 什么是原型链\n\n每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例，意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数，这就是原型链。原型链的终点是 null。\n\n\n\n\n# 原型链继承\n\nfunction Parent(name) {\n  this.name = name;\n  this.friends = ['John']; // 引用类型属性\n}\n\nfunction Child() {}\n\nChild.prototype = new Parent();\nlet child1 = new Child();\nlet child2 = new Child();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 新实例的原型等于父类的实例\n * 特点：实例可继承的属性有：\n   * 实例的构造函数\n   * 父类构造函数属性\n   * 父类原型的属性\n   * 新实例不会继承父类实例的属性\n * 缺点\n   * 新实例无法向父类构造函数传参\n   * 继承单一\n   * 所有新实例都会共享父类实例的属性。\n\n\n# 构造函数继承（经典继承）\n\n * 用call方法和apply将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制）\n * 特点\n   * 只继承了父类构造函数的属性，没有继承父类原型的属性\n   * 解决了原型链继承缺点1、2、3。\n   * 可以继承多个构造函数属性（call多个）。\n   * 在子实例中可向父实例传参。\n * 缺点\n   * 只能继承父类构造函数的属性，但是由于没有涉及到原型，所以父类的原型方法将不会被使用。\n   * 无法实现构造函数的复用。（每次用每次都要重新调用）\n   * 每个新实例都有父类构造函数的副本，臃肿。\n\nfunction SuperType(name) {\n  this.name = name\n}\n\nfunction SubType() {\n  // 继承 SuperType 并传参\n  SuperType.call(this, \"Nicholas\")\n  // 实例属性\n  this.age = 29\n}\n\nlet instance = new SubType()\nconsole.log(instance.name) // \"Nicholas\"\nconsole.log(instance.age) // 29\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 组合式继承\n\nfunction Parent (name) {\n  this.name = name\n  this.age = 30\n}\n\nfunction Child (name) {\n  Parent.call(this, name) // 借用构造函数模式\n}\nChild.prototype = new Parent() // 原型链继承\nconst child = new Child('Alice')\nconsole.log(child.name) // Alice\nconsole.log(child.age) // 30 继承了父类原型的属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 结合了两种模式的优点，传参和复用\n * 特点\n   * 可以继承父类原型上的属性，可以传参，可复用。\n   * 每个新实例引入的构造函数属性是私有的。\n   * 缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。\n\n\n# 原型式继承\n\nfunction createAnother(original) {\n  function Clone() {}\n  Clone.prototype = original;\n  return new Clone();\n}\n\nlet originalObject = {\n  name: 'Alice',\n  friends: ['John', 'Bob']\n};\n\nlet copy = createAnother(originalObject);\nconsole.log(copy.name); // 'Alice'\nconsole.log(copy.friends); // ['John', 'Bob']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。\n * 特点：类似于复制一个对象，用函数来包装。\n * 缺点\n   * 所有实例都会继承原型上的属性。\n   * 无法实现复用。（新实例属性都是后面添加的）\n\n\n# 寄生式继承\n\nfunction Parent(name) {\n  this.name = name\n  this.age = 30\n}\n\nfunction subObject (obj) {\n  const sub = Object.create(obj)\n  sub.name = 'Alice'\n  return sub\n}\n\nconst sub2 = subObject(new Parent('John'))\n\nconsole.log(typeof subObject)\nconsole.log(typeof sub2)\nconsole.log(sub2.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 就是给原型式继承外面套了个壳子。\n * 优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。\n * 缺点：没用到原型，无法复用。\n\n\n# 寄生组合式继承\n\nfunction inheritObject(o) {\n  // 声明一个过渡对象\n  function F() { }\n  // 过渡对象的原型继承父对象\n  F.prototype = o;\n  // 返回过渡对象的实例，该对象的原型继承了父对象\n  return new F();\n}\n\nfunction inheritPrototype(subClass,superClass) {\n  // 复制一份父类的原型副本到变量中\n  const p = inheritObject(superClass.prototype);\n  // 修正因为重写子类的原型导致子类的constructor属性被修改\n  p.constructor = subClass;\n  // 设置子类原型\n  subClass.prototype = p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 使用 function 实现 class\n\n// 在创建对象前判断是否使用 new 关键字，否则报错\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function')\n  }\n}\n\nfunction _createClass(Constructor, protoProps = [], staticProps = []) {\n  // 在构造函数的原型上定义实例属性方法\n  _defineProperties(Constructor.prototype, protoProps)\n  // 在构造函数本身定义静态属性方法\n  _defineProperties(Constructor, staticProps)\n}\n\n// 实现公用的批量给对象添加属性方法的方法\nfunction _defineProperties(target, props) {\n  props.forEach(prop => {\n    Object.defineProperty(target, prop.key, prop)\n  })\n}\n\n// 继承\nfunction _inherits(subClass, superClass) {\n  // 子类实例继承父类的实例属性方法\n  subClass.prototype = Object.create(superClass.prototype)\n  // 修正constructor属性\n  subClass.prototype.constructor = subClass\n\n  // 子类继承父类的静态属性方法\n  Object.setPrototypeOf(subClass, superClass)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 参考文章\n\n最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）\n\n最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）\n\n最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）\n\n【THE LAST TIME】一文吃透所有JS原型相关知识点",normalizedContent:"# 创建对象的模式\n\n\n# 工厂模式创建对象\n\n顾名思义，传入约定好的对象属性，产生如流水线一般的对象。\n\nfunction createperson(name, age, job) {\n  var o = new object();\n  o.name = name;\n  o.age = age;\n  o.job = job;\n  o.sayname = function() {\n    console.log(this.name);\n  };\n  return o;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 构造函数模式\n\n与工厂模式十分相似，不同的地方在于需要使用 new 关键字调用\n\nfunction person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayname = function () {\n    console.log(this.name)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 构造函数创建对象的过程\n\n通过构造函数创建实例会执行如下操作：\n\n * 在内存中创建一个新对象\n * 这个新对象内部的 [[prototype]] 特性被赋值为构造函数的 prototype 属性\n * 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）\n * 执行构造函数内部的代码（给新对象添加属性）\n * 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象\n\n因而可以引出手写 new\n\nfunction mynew (fn, ...args) {\n  const obj = object.create(fn.prototype)\n  const res = fn.call(obj, ...args)\n  return typeof res === 'object' ? obj : res\n}\n\n\n1\n2\n3\n4\n5\n\n\n在手写 new 中，用到了 object.create\n\n手写object.create\n\nfunction createobject (obj) {\n  function f () {}\n  f.prototype = obj\n  return new f()\n}\n\n\n1\n2\n3\n4\n5\n\n\n另外涉及到原型链的还有 instanceof\n\n手写 instanceof\n\n/** 递归法 */\nfunction myinstanceof(obj, fn) {\n  if (!fn.prototype) {\n    throw error(\"right-hand side of 'instanceof' is not callable\")\n  }\n  const proto = object.getprototypeof(obj)\n  if (proto) {\n    if (proto === fn.prototype) {\n      return true\n    }\n    return myinstanceof(proto, fn)\n  }\n  return false\n}\n\n/** 迭代法 */\nfunction myinstanceof2(obj, fn) {\n  if (!fn.prototype) {\n    throw error(\"right-hand side of 'instanceof' is not callable\")\n  }\n  let proto = object.getprototypeof(obj)\n  const target = fn.prototype\n  while (true) {\n    if (!proto) return false\n    if (proto === target) return true\n    proto = object.getprototypeof(proto)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 继承\n\n\n# 什么是原型链\n\n每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例，意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数，这就是原型链。原型链的终点是 null。\n\n\n\n\n# 原型链继承\n\nfunction parent(name) {\n  this.name = name;\n  this.friends = ['john']; // 引用类型属性\n}\n\nfunction child() {}\n\nchild.prototype = new parent();\nlet child1 = new child();\nlet child2 = new child();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 新实例的原型等于父类的实例\n * 特点：实例可继承的属性有：\n   * 实例的构造函数\n   * 父类构造函数属性\n   * 父类原型的属性\n   * 新实例不会继承父类实例的属性\n * 缺点\n   * 新实例无法向父类构造函数传参\n   * 继承单一\n   * 所有新实例都会共享父类实例的属性。\n\n\n# 构造函数继承（经典继承）\n\n * 用call方法和apply将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制）\n * 特点\n   * 只继承了父类构造函数的属性，没有继承父类原型的属性\n   * 解决了原型链继承缺点1、2、3。\n   * 可以继承多个构造函数属性（call多个）。\n   * 在子实例中可向父实例传参。\n * 缺点\n   * 只能继承父类构造函数的属性，但是由于没有涉及到原型，所以父类的原型方法将不会被使用。\n   * 无法实现构造函数的复用。（每次用每次都要重新调用）\n   * 每个新实例都有父类构造函数的副本，臃肿。\n\nfunction supertype(name) {\n  this.name = name\n}\n\nfunction subtype() {\n  // 继承 supertype 并传参\n  supertype.call(this, \"nicholas\")\n  // 实例属性\n  this.age = 29\n}\n\nlet instance = new subtype()\nconsole.log(instance.name) // \"nicholas\"\nconsole.log(instance.age) // 29\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 组合式继承\n\nfunction parent (name) {\n  this.name = name\n  this.age = 30\n}\n\nfunction child (name) {\n  parent.call(this, name) // 借用构造函数模式\n}\nchild.prototype = new parent() // 原型链继承\nconst child = new child('alice')\nconsole.log(child.name) // alice\nconsole.log(child.age) // 30 继承了父类原型的属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 结合了两种模式的优点，传参和复用\n * 特点\n   * 可以继承父类原型上的属性，可以传参，可复用。\n   * 每个新实例引入的构造函数属性是私有的。\n   * 缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。\n\n\n# 原型式继承\n\nfunction createanother(original) {\n  function clone() {}\n  clone.prototype = original;\n  return new clone();\n}\n\nlet originalobject = {\n  name: 'alice',\n  friends: ['john', 'bob']\n};\n\nlet copy = createanother(originalobject);\nconsole.log(copy.name); // 'alice'\nconsole.log(copy.friends); // ['john', 'bob']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。\n * 特点：类似于复制一个对象，用函数来包装。\n * 缺点\n   * 所有实例都会继承原型上的属性。\n   * 无法实现复用。（新实例属性都是后面添加的）\n\n\n# 寄生式继承\n\nfunction parent(name) {\n  this.name = name\n  this.age = 30\n}\n\nfunction subobject (obj) {\n  const sub = object.create(obj)\n  sub.name = 'alice'\n  return sub\n}\n\nconst sub2 = subobject(new parent('john'))\n\nconsole.log(typeof subobject)\nconsole.log(typeof sub2)\nconsole.log(sub2.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 就是给原型式继承外面套了个壳子。\n * 优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。\n * 缺点：没用到原型，无法复用。\n\n\n# 寄生组合式继承\n\nfunction inheritobject(o) {\n  // 声明一个过渡对象\n  function f() { }\n  // 过渡对象的原型继承父对象\n  f.prototype = o;\n  // 返回过渡对象的实例，该对象的原型继承了父对象\n  return new f();\n}\n\nfunction inheritprototype(subclass,superclass) {\n  // 复制一份父类的原型副本到变量中\n  const p = inheritobject(superclass.prototype);\n  // 修正因为重写子类的原型导致子类的constructor属性被修改\n  p.constructor = subclass;\n  // 设置子类原型\n  subclass.prototype = p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 使用 function 实现 class\n\n// 在创建对象前判断是否使用 new 关键字，否则报错\nfunction _classcallcheck(instance, constructor) {\n  if (!(instance instanceof constructor)) {\n    throw new typeerror('cannot call a class as a function')\n  }\n}\n\nfunction _createclass(constructor, protoprops = [], staticprops = []) {\n  // 在构造函数的原型上定义实例属性方法\n  _defineproperties(constructor.prototype, protoprops)\n  // 在构造函数本身定义静态属性方法\n  _defineproperties(constructor, staticprops)\n}\n\n// 实现公用的批量给对象添加属性方法的方法\nfunction _defineproperties(target, props) {\n  props.foreach(prop => {\n    object.defineproperty(target, prop.key, prop)\n  })\n}\n\n// 继承\nfunction _inherits(subclass, superclass) {\n  // 子类实例继承父类的实例属性方法\n  subclass.prototype = object.create(superclass.prototype)\n  // 修正constructor属性\n  subclass.prototype.constructor = subclass\n\n  // 子类继承父类的静态属性方法\n  object.setprototypeof(subclass, superclass)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 参考文章\n\n最详尽的 js 原型与原型链终极详解，没有「可能是」。（一）\n\n最详尽的 js 原型与原型链终极详解，没有「可能是」。（二）\n\n最详尽的 js 原型与原型链终极详解，没有「可能是」。（三）\n\n【the last time】一文吃透所有js原型相关知识点",charsets:{cjk:!0},lastUpdated:"2024/09/11, 17:01:03",lastUpdatedTimestamp:1726045263e3},{title:"ResizeObserver防抖优化性能",frontmatter:{title:"ResizeObserver防抖优化性能",date:"2024-06-15T01:25:46.000Z",permalink:"/pages/7deb64/",categories:["场景"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/02.%E5%9C%BA%E6%99%AF/02.ResizeObserver%E9%98%B2%E6%8A%96%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD.html",relativePath:"02.场景/02.ResizeObserver防抖优化性能.md",key:"v-390955c8",path:"/pages/7deb64/",headers:[{level:4,title:"明确定义",slug:"明确定义",normalizedTitle:"明确定义",charIndex:31},{level:4,title:"工作场景再现",slug:"工作场景再现",normalizedTitle:"工作场景再现",charIndex:248},{level:4,title:"检测回流次数的方法",slug:"检测回流次数的方法",normalizedTitle:"检测回流次数的方法",charIndex:472},{level:4,title:"代码封装",slug:"代码封装",normalizedTitle:"代码封装",charIndex:657}],headersStr:"明确定义 工作场景再现 检测回流次数的方法 代码封装",content:"提示\n\n在工作中，有遇到过与页面回流相关的性能优化问题\n\n# 明确定义\n\n * 回流（Reflow）：又称为布局，是浏览器为了重新计算页面中元素的位置和大小而进行的过程。当DOM的变化影响到元素的几何信息（如宽度、高度、边距等）时，浏览器需要重新计算元素的位置和大小，然后再进行渲染。这个过程是计算密集型的，可能会导致页面的性能问题。\n\n * 重绘（Repaint）：当元素的外观（颜色、背景等）发生变化，但几何属性未变时，浏览器将进行重绘。重绘不涉及元素位置的改变，因此成本较回流为低。\n\n# 工作场景再现\n\n项目的背景是一个数据可视化平台，左侧有一个折叠面板，可以伸缩，从展开到折叠的过程中会有动画，右侧为页面的主体，有大量的 echarts 图表。\n\n正如之前所言，折叠面板的折叠与展开过程涉及到动画，动画过程中折叠面板的宽度不断变化，导致页面会发生不断的回流，而在这个过程中，echarts 图表也会进行同步的收缩。\n\n这当然是一个好特性，但是这个计算密集型的过程也造成了浏览器的较大压力，会导致页面卡顿，影响了首页的使用体验。\n\n# 检测回流次数的方法\n\n在每一个组件内部，加入一个副作用，当检测到父容器尺寸变化时，echarts 就会进行伸缩，在这个时候，在控制台打印一次尺寸变化提醒消息。\n\n经过检测，折叠面板折叠和展开的过程中，共发生了800+次的 echarts 图表尺寸调整，对性能造成了巨大的压力。\n\n加入防抖后，重新检测，发现这个数字变成了100，页面的整体流畅度得到了极大的提高。\n\n# 代码封装\n\n注意\n\n代码仅为示例，实际代码要与业务相结合，以下代码为ai生成，不一定可以运行。\n\n// debounce.js\nexport default function debounce(func, wait) {\n  let timeout;\n  return function(...args) {\n    const context = this;\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(context, args), wait);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport * as echarts from 'echarts/core';\nimport { BarChart } from 'echarts/charts';\nimport { CanvasRenderer } from 'echarts/renderers';\nimport { GridComponent, TooltipComponent } from 'echarts/components';\nimport debounce from './debounce.js'\n\necharts.use([BarChart, CanvasRenderer, GridComponent, TooltipComponent]);\n\nconst option = {\n  tooltip: {},\n  xAxis: {\n    data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']\n  },\n  yAxis: {},\n  series: [\n    {\n      name: '销量',\n      type: 'bar',\n      data: [5, 20, 36, 10, 10, 20]\n    }\n  ]\n};\n\nconst EChartsComponent = () => {\n  const chartRef = useRef(null);\n  const [chart, setChart] = useState(null);\n\n  // 初始化图表\n  useEffect(() => {\n    if (chartRef.current && !chart) {\n      const myChart = echarts.init(chartRef.current);\n      setChart(myChart);\n    }\n  }, [chart]);\n\n  // 防抖调整图表尺寸\n  const resizeChart = debounce(() => {\n    chart && chart.resize();\n  }, 300);\n\n  // 使用ResizeObserver监听容器尺寸变化\n  useEffect(() => {\n    if (chartRef.current) {\n      const resizeObserver = new ResizeObserver(resizeChart);\n      resizeObserver.observe(chartRef.current);\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, [chart]);\n\n  // 设置图表配置项\n  useEffect(() => {\n    if (chart) {\n      chart.setOption(option);\n    }\n  }, [chart]);\n\n  return <div ref={chartRef} style={{ width: '600px', height: '400px' }}></div>;\n};\n\nexport default EChartsComponent;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n",normalizedContent:"提示\n\n在工作中，有遇到过与页面回流相关的性能优化问题\n\n# 明确定义\n\n * 回流（reflow）：又称为布局，是浏览器为了重新计算页面中元素的位置和大小而进行的过程。当dom的变化影响到元素的几何信息（如宽度、高度、边距等）时，浏览器需要重新计算元素的位置和大小，然后再进行渲染。这个过程是计算密集型的，可能会导致页面的性能问题。\n\n * 重绘（repaint）：当元素的外观（颜色、背景等）发生变化，但几何属性未变时，浏览器将进行重绘。重绘不涉及元素位置的改变，因此成本较回流为低。\n\n# 工作场景再现\n\n项目的背景是一个数据可视化平台，左侧有一个折叠面板，可以伸缩，从展开到折叠的过程中会有动画，右侧为页面的主体，有大量的 echarts 图表。\n\n正如之前所言，折叠面板的折叠与展开过程涉及到动画，动画过程中折叠面板的宽度不断变化，导致页面会发生不断的回流，而在这个过程中，echarts 图表也会进行同步的收缩。\n\n这当然是一个好特性，但是这个计算密集型的过程也造成了浏览器的较大压力，会导致页面卡顿，影响了首页的使用体验。\n\n# 检测回流次数的方法\n\n在每一个组件内部，加入一个副作用，当检测到父容器尺寸变化时，echarts 就会进行伸缩，在这个时候，在控制台打印一次尺寸变化提醒消息。\n\n经过检测，折叠面板折叠和展开的过程中，共发生了800+次的 echarts 图表尺寸调整，对性能造成了巨大的压力。\n\n加入防抖后，重新检测，发现这个数字变成了100，页面的整体流畅度得到了极大的提高。\n\n# 代码封装\n\n注意\n\n代码仅为示例，实际代码要与业务相结合，以下代码为ai生成，不一定可以运行。\n\n// debounce.js\nexport default function debounce(func, wait) {\n  let timeout;\n  return function(...args) {\n    const context = this;\n    cleartimeout(timeout);\n    timeout = settimeout(() => func.apply(context, args), wait);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nimport react, { usestate, useeffect, useref } from 'react';\nimport * as echarts from 'echarts/core';\nimport { barchart } from 'echarts/charts';\nimport { canvasrenderer } from 'echarts/renderers';\nimport { gridcomponent, tooltipcomponent } from 'echarts/components';\nimport debounce from './debounce.js'\n\necharts.use([barchart, canvasrenderer, gridcomponent, tooltipcomponent]);\n\nconst option = {\n  tooltip: {},\n  xaxis: {\n    data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']\n  },\n  yaxis: {},\n  series: [\n    {\n      name: '销量',\n      type: 'bar',\n      data: [5, 20, 36, 10, 10, 20]\n    }\n  ]\n};\n\nconst echartscomponent = () => {\n  const chartref = useref(null);\n  const [chart, setchart] = usestate(null);\n\n  // 初始化图表\n  useeffect(() => {\n    if (chartref.current && !chart) {\n      const mychart = echarts.init(chartref.current);\n      setchart(mychart);\n    }\n  }, [chart]);\n\n  // 防抖调整图表尺寸\n  const resizechart = debounce(() => {\n    chart && chart.resize();\n  }, 300);\n\n  // 使用resizeobserver监听容器尺寸变化\n  useeffect(() => {\n    if (chartref.current) {\n      const resizeobserver = new resizeobserver(resizechart);\n      resizeobserver.observe(chartref.current);\n\n      return () => {\n        resizeobserver.disconnect();\n      };\n    }\n  }, [chart]);\n\n  // 设置图表配置项\n  useeffect(() => {\n    if (chart) {\n      chart.setoption(option);\n    }\n  }, [chart]);\n\n  return <div ref={chartref} style={{ width: '600px', height: '400px' }}></div>;\n};\n\nexport default echartscomponent;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"useAbortableRequest",frontmatter:{title:"useAbortableRequest",date:"2024-06-15T01:54:40.000Z",permalink:"/pages/72b6d7/",categories:["场景"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/02.%E5%9C%BA%E6%99%AF/03.useAbortableRequest.html",relativePath:"02.场景/03.useAbortableRequest.md",key:"v-79b8ec0a",path:"/pages/72b6d7/",headers:[{level:4,title:"web API 之 AbortController",slug:"web-api-之-abortcontroller",normalizedTitle:"web api 之 abortcontroller",charIndex:2},{level:4,title:"工作需求",slug:"工作需求",normalizedTitle:"工作需求",charIndex:786},{level:4,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:903}],headersStr:"web API 之 AbortController 工作需求 代码实现",content:"# web API 之 AbortController\n\nAbortController: abort()方法\n\nAbortController 接口的 abort() 方法会在一个异步操作完成之前中止它。它能够中止 fetch 请求、各种响应主体或者流的消耗。\n\nconst controller = new AbortController();\nconst signal = controller.signal;\n\nconst url = \"video.mp4\";\nconst downloadBtn = document.querySelector(\".download\");\nconst abortBtn = document.querySelector(\".abort\");\n\ndownloadBtn.addEventListener(\"click\", fetchVideo);\n\nabortBtn.addEventListener(\"click\", () => {\n  controller.abort();\n  console.log(\"Download aborted\");\n});\n\nfunction fetchVideo() {\n  fetch(url, { signal })\n    .then((response) => {\n      console.log(\"Download complete\", response);\n    })\n    .catch((err) => {\n      console.error(`Download error: ${err.message}`);\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 工作需求\n\n在工作中，ant design 表格会在查询后发起请求，有时候用户请求较快，会造成过多的重复请求，会对服务器造成较大的压力，于是就有了希望能在上一次请求没有完成，但是已经发起下一次请求的同时，能够取消上一次的请求。\n\n# 代码实现\n\nimport { useState, useCallback } from 'react';\n\n/**\n * 使用umi.js和AbortController实现的防止重复请求的React Hook\n * @param {Function} requestFunction - 请求函数，该函数需要返回一个Promise\n * @returns {Array} - 返回一个数组，包含请求函数和当前请求状态\n */\nfunction useAbortableRequest(requestFunction) {\n  // 保存当前的AbortController实例\n  const [controller, setController] = useState(null);\n  // 请求状态\n  const [loading, setLoading] = useState(false);\n\n  const sendRequest = useCallback(async (...args) => {\n    // 如果存在上一个请求，先取消上一个请求\n    if (controller) {\n      controller.abort();\n    }\n    // 创建新的AbortController实例\n    const newController = new AbortController();\n    setController(newController);\n    setLoading(true);\n\n    try {\n      // 调用请求函数，传入signal\n      const response = await requestFunction(...args, { signal: newController.signal });\n      setLoading(false);\n      return response;\n    } catch (error) {\n      // 如果请求被取消，不更新loading状态\n      if (error.name !== 'AbortError') {\n        setLoading(false);\n      }\n      throw error;\n    }\n  }, [controller, requestFunction]);\n\n  return [sendRequest, loading];\n}\n\nexport default useAbortableRequest;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n使用示例：\n\nimport React, { useEffect } from 'react';\nimport { useAbortableRequest } from './useAbortableRequest';\nimport { request } from 'umi';\n\n// 模拟请求函数\nconst fetchData = (params, { signal }) => {\n  return request('/api/data', { method: 'GET', params, signal });\n};\n\nconst MyComponent = () => {\n  const [fetchDataWithAbort, loading] = useAbortableRequest(fetchData);\n\n  useEffect(() => {\n    fetchDataWithAbort({ query: 'example' })\n      .then(response => {\n        console.log(response);\n      })\n      .catch(error => {\n        if (error.name !== 'AbortError') {\n          console.error(error);\n        }\n      });\n\n    // 组件卸载时取消请求\n    return () => {\n      fetchDataWithAbort();\n    };\n  }, [fetchDataWithAbort]);\n\n  return <div>{loading ? '加载中...' : '加载完成'}</div>;\n};\n\nexport default MyComponent;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这个Hook useAbortableRequest 接收一个请求函数作为参数，返回一个可以被调用的请求函数和当前请求的加载状态。请求函数内部使用AbortController来取消上一个未完成的请求，以防止重复请求。",normalizedContent:"# web api 之 abortcontroller\n\nabortcontroller: abort()方法\n\nabortcontroller 接口的 abort() 方法会在一个异步操作完成之前中止它。它能够中止 fetch 请求、各种响应主体或者流的消耗。\n\nconst controller = new abortcontroller();\nconst signal = controller.signal;\n\nconst url = \"video.mp4\";\nconst downloadbtn = document.queryselector(\".download\");\nconst abortbtn = document.queryselector(\".abort\");\n\ndownloadbtn.addeventlistener(\"click\", fetchvideo);\n\nabortbtn.addeventlistener(\"click\", () => {\n  controller.abort();\n  console.log(\"download aborted\");\n});\n\nfunction fetchvideo() {\n  fetch(url, { signal })\n    .then((response) => {\n      console.log(\"download complete\", response);\n    })\n    .catch((err) => {\n      console.error(`download error: ${err.message}`);\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 工作需求\n\n在工作中，ant design 表格会在查询后发起请求，有时候用户请求较快，会造成过多的重复请求，会对服务器造成较大的压力，于是就有了希望能在上一次请求没有完成，但是已经发起下一次请求的同时，能够取消上一次的请求。\n\n# 代码实现\n\nimport { usestate, usecallback } from 'react';\n\n/**\n * 使用umi.js和abortcontroller实现的防止重复请求的react hook\n * @param {function} requestfunction - 请求函数，该函数需要返回一个promise\n * @returns {array} - 返回一个数组，包含请求函数和当前请求状态\n */\nfunction useabortablerequest(requestfunction) {\n  // 保存当前的abortcontroller实例\n  const [controller, setcontroller] = usestate(null);\n  // 请求状态\n  const [loading, setloading] = usestate(false);\n\n  const sendrequest = usecallback(async (...args) => {\n    // 如果存在上一个请求，先取消上一个请求\n    if (controller) {\n      controller.abort();\n    }\n    // 创建新的abortcontroller实例\n    const newcontroller = new abortcontroller();\n    setcontroller(newcontroller);\n    setloading(true);\n\n    try {\n      // 调用请求函数，传入signal\n      const response = await requestfunction(...args, { signal: newcontroller.signal });\n      setloading(false);\n      return response;\n    } catch (error) {\n      // 如果请求被取消，不更新loading状态\n      if (error.name !== 'aborterror') {\n        setloading(false);\n      }\n      throw error;\n    }\n  }, [controller, requestfunction]);\n\n  return [sendrequest, loading];\n}\n\nexport default useabortablerequest;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n使用示例：\n\nimport react, { useeffect } from 'react';\nimport { useabortablerequest } from './useabortablerequest';\nimport { request } from 'umi';\n\n// 模拟请求函数\nconst fetchdata = (params, { signal }) => {\n  return request('/api/data', { method: 'get', params, signal });\n};\n\nconst mycomponent = () => {\n  const [fetchdatawithabort, loading] = useabortablerequest(fetchdata);\n\n  useeffect(() => {\n    fetchdatawithabort({ query: 'example' })\n      .then(response => {\n        console.log(response);\n      })\n      .catch(error => {\n        if (error.name !== 'aborterror') {\n          console.error(error);\n        }\n      });\n\n    // 组件卸载时取消请求\n    return () => {\n      fetchdatawithabort();\n    };\n  }, [fetchdatawithabort]);\n\n  return <div>{loading ? '加载中...' : '加载完成'}</div>;\n};\n\nexport default mycomponent;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这个hook useabortablerequest 接收一个请求函数作为参数，返回一个可以被调用的请求函数和当前请求的加载状态。请求函数内部使用abortcontroller来取消上一个未完成的请求，以防止重复请求。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"场景",frontmatter:{title:"场景",date:"2024-05-19T19:22:46.000Z",permalink:"/ui/",categories:["场景"],tags:[null],article:!1,author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/02.%E5%9C%BA%E6%99%AF/01.%E5%9C%BA%E6%99%AF.html",relativePath:"02.场景/01.场景.md",key:"v-229d25c8",path:"/ui/",headersStr:null,content:"> 在这里我将会写一些自己遇到的前端场景问题\n\n * 目前打算写3个\n\n * 使用 resizeObserver 为 echarts 图标添加防抖\n\n * 使用 abortController 写一个可以返回请求函数的 react 自定义钩子函数\n\n * 使用 requestAnimationFrame 写一个精确的计时器、写一个可以自定义滚动方式的函数，类似于 element.scrollIntoView()",normalizedContent:"> 在这里我将会写一些自己遇到的前端场景问题\n\n * 目前打算写3个\n\n * 使用 resizeobserver 为 echarts 图标添加防抖\n\n * 使用 abortcontroller 写一个可以返回请求函数的 react 自定义钩子函数\n\n * 使用 requestanimationframe 写一个精确的计时器、写一个可以自定义滚动方式的函数，类似于 element.scrollintoview()",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"单点登录场景与理解",frontmatter:{title:"单点登录场景与理解",date:"2024-07-30T12:28:31.000Z",permalink:"/pages/016f34/",categories:["场景"],tags:["核心场景"],author:{name:"leon yu",link:"https://github.com/lampeggiante"},sticky:6},regularPath:"/02.%E5%9C%BA%E6%99%AF/06.%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%9C%BA%E6%99%AF%E4%B8%8E%E7%90%86%E8%A7%A3.html",relativePath:"02.场景/06.单点登录场景与理解.md",key:"v-9e2db8ca",path:"/pages/016f34/",headers:[{level:2,title:"cookie 与 session 的区别",slug:"cookie-与-session-的区别",normalizedTitle:"cookie 与 session 的区别",charIndex:186},{level:2,title:"cookie 与 token 的区别",slug:"cookie-与-token-的区别",normalizedTitle:"cookie 与 token 的区别",charIndex:400},{level:2,title:"cookie + session 的方式为什么不能防止 CSRF，而 token 可以",slug:"cookie-session-的方式为什么不能防止-csrf-而-token-可以",normalizedTitle:"cookie + session 的方式为什么不能防止 csrf，而 token 可以",charIndex:519}],headersStr:"cookie 与 session 的区别 cookie 与 token 的区别 cookie + session 的方式为什么不能防止 CSRF，而 token 可以",content:"提示\n\n刚好遇到SSO单点登录的问题，借此文章整理对应的技术实现与注意事项。\n\n\n# 单点登录存在的意义\n\n 1. 解决 HTTP 无状态的问题\n 2. 解决多系统登录统一认证的问题\n\n * 多系统登录存在跨域问题，需要解决\n * 使用单点登录，只需要携带统一凭证即可\n\n\n# 单点登录的具体流程\n\n\n\n\n# cookie、session、token 之间的区别\n\n\n# cookie 与 session 的区别\n\n 1. cookie 数据保存在 client，而 session 数据保存在 server\n 2. cookie 的安全性有一定问题，可能回存在 cookie 欺诈的问题\n 3. session 会占用较多的服务器资源，同时，如果做了负载均衡，不同服务器之间的 session 信息不会同步\n 4. 单个 cookie 最多 4K，一个站点最多保留 20 个 cookie\n\n\n# cookie 与 token 的区别\n\n 1. cookie + session 是一种常用的解决http无状态的方式，可以创建临时会话\n 2. 而token本身是服务端提供给客户端的临时凭证，可以在多系统之间提供临时的身份认证\n\n\n# cookie + session 的方式为什么不能防止 CSRF，而 token 可以\n\n因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。\n\n\n# 参考文章\n\n单点登录（SSO）\n\nSession Cookie Token三者的关系和区别\n\n面试必问:session，cookie和token的区别",normalizedContent:"提示\n\n刚好遇到sso单点登录的问题，借此文章整理对应的技术实现与注意事项。\n\n\n# 单点登录存在的意义\n\n 1. 解决 http 无状态的问题\n 2. 解决多系统登录统一认证的问题\n\n * 多系统登录存在跨域问题，需要解决\n * 使用单点登录，只需要携带统一凭证即可\n\n\n# 单点登录的具体流程\n\n\n\n\n# cookie、session、token 之间的区别\n\n\n# cookie 与 session 的区别\n\n 1. cookie 数据保存在 client，而 session 数据保存在 server\n 2. cookie 的安全性有一定问题，可能回存在 cookie 欺诈的问题\n 3. session 会占用较多的服务器资源，同时，如果做了负载均衡，不同服务器之间的 session 信息不会同步\n 4. 单个 cookie 最多 4k，一个站点最多保留 20 个 cookie\n\n\n# cookie 与 token 的区别\n\n 1. cookie + session 是一种常用的解决http无状态的方式，可以创建临时会话\n 2. 而token本身是服务端提供给客户端的临时凭证，可以在多系统之间提供临时的身份认证\n\n\n# cookie + session 的方式为什么不能防止 csrf，而 token 可以\n\n因为form 发起的 post 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 cookie 向其他域发送 post 请求，形成 csrf 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。\n\n\n# 参考文章\n\n单点登录（sso）\n\nsession cookie token三者的关系和区别\n\n面试必问:session，cookie和token的区别",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"支持promise的并发",frontmatter:{title:"支持promise的并发",date:"2024-06-28T21:09:49.000Z",permalink:"/pages/d969d2/",categories:["场景"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/02.%E5%9C%BA%E6%99%AF/05.%E6%94%AF%E6%8C%81promise%E7%9A%84%E5%B9%B6%E5%8F%91.html",relativePath:"02.场景/05.支持promise的并发.md",key:"v-4306ecce",path:"/pages/d969d2/",headers:[{level:4,title:"工作场景",slug:"工作场景",normalizedTitle:"工作场景",charIndex:2},{level:4,title:"（本人采取的方案）一次性导入，类 Promise.all 的处理方式",slug:"本人采取的方案-一次性导入-类-promise-all-的处理方式",normalizedTitle:"（本人采取的方案）一次性导入，类 promise.all 的处理方式",charIndex:151},{level:4,title:"p-queue",slug:"p-queue",normalizedTitle:"p-queue",charIndex:1199},{level:4,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1697}],headersStr:"工作场景 （本人采取的方案）一次性导入，类 Promise.all 的处理方式 p-queue 参考",content:"# 工作场景\n\n当处理多个请求的时候，如果同步地去处理，返回较慢，但是如果直接使用 Promise.all 又有可能导致阻塞，例如从 web worker 中传输数据到主线程，如果传输的数据过大，主线程会阻塞，导致页面卡死，于是可以将大数据拆分成多个小数据，并封装 Promise 实现并发处理\n\n# （本人采取的方案）一次性导入，类 Promise.all 的处理方式\n\nfunction schedulePromise(tasks, limit) {\n  const results = [];\n  let count = 0;\n  return new Promise((resolve, reject) => {\n    const run = () => {\n      if (count >= tasks.length) {\n        resolve(results);\n        return;\n      }\n      const task = tasks[count];\n      count++;\n      task()\n        .then((result) => {\n          results.push(result);\n          run();\n        })\n        .catch((error) => {\n          reject(error);\n        });\n    };\n    for (let i = 0; i < limit; i++) {\n      run();\n    }\n  });\n}\n\n// 使用示例\nconst tasks = [\n  () => new Promise((resolve) => setTimeout(() => resolve('Task 1'), 1000)),\n  () => new Promise((resolve) => setTimeout(() => resolve('Task 2'), 2000)),\n  () => new Promise((resolve) => setTimeout(() => resolve('Task 3'), 3000)),\n];\n\nschedulePromise(tasks, 2)\n  .then((results) => {\n    console.log(results);\n    // 输出: ['Task 1', 'Task 2', 'Task 3']\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n# p-queue\n\n使用成熟的第三方库 p-queue 实现并发处理\n\nconst pQueue = new PQueue({ concurrency: 2 });\n\nconst tasks = [\n  () => new Promise((resolve) => setTimeout(() => resolve('Task 1'), 1000)),\n  () => new Promise((resolve) => setTimeout(() => resolve('Task 2'), 2000)),\n  () => new Promise((resolve) => setTimeout(() => resolve('Task 3'), 3000)),\n];\n\nconst results = await Promise.all(tasks.map((task) => pQueue.add(task)));\nconsole.log(results);\n// 输出: ['Task 1', 'Task 2', 'Task 3']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 参考\n\n * p-queue\n * p-limit\n * p-try",normalizedContent:"# 工作场景\n\n当处理多个请求的时候，如果同步地去处理，返回较慢，但是如果直接使用 promise.all 又有可能导致阻塞，例如从 web worker 中传输数据到主线程，如果传输的数据过大，主线程会阻塞，导致页面卡死，于是可以将大数据拆分成多个小数据，并封装 promise 实现并发处理\n\n# （本人采取的方案）一次性导入，类 promise.all 的处理方式\n\nfunction schedulepromise(tasks, limit) {\n  const results = [];\n  let count = 0;\n  return new promise((resolve, reject) => {\n    const run = () => {\n      if (count >= tasks.length) {\n        resolve(results);\n        return;\n      }\n      const task = tasks[count];\n      count++;\n      task()\n        .then((result) => {\n          results.push(result);\n          run();\n        })\n        .catch((error) => {\n          reject(error);\n        });\n    };\n    for (let i = 0; i < limit; i++) {\n      run();\n    }\n  });\n}\n\n// 使用示例\nconst tasks = [\n  () => new promise((resolve) => settimeout(() => resolve('task 1'), 1000)),\n  () => new promise((resolve) => settimeout(() => resolve('task 2'), 2000)),\n  () => new promise((resolve) => settimeout(() => resolve('task 3'), 3000)),\n];\n\nschedulepromise(tasks, 2)\n  .then((results) => {\n    console.log(results);\n    // 输出: ['task 1', 'task 2', 'task 3']\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n# p-queue\n\n使用成熟的第三方库 p-queue 实现并发处理\n\nconst pqueue = new pqueue({ concurrency: 2 });\n\nconst tasks = [\n  () => new promise((resolve) => settimeout(() => resolve('task 1'), 1000)),\n  () => new promise((resolve) => settimeout(() => resolve('task 2'), 2000)),\n  () => new promise((resolve) => settimeout(() => resolve('task 3'), 3000)),\n];\n\nconst results = await promise.all(tasks.map((task) => pqueue.add(task)));\nconsole.log(results);\n// 输出: ['task 1', 'task 2', 'task 3']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 参考\n\n * p-queue\n * p-limit\n * p-try",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"requestAnimation与滚动",frontmatter:{title:"requestAnimation与滚动",date:"2024-06-15T01:55:48.000Z",permalink:"/pages/8bee02/",categories:["场景"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/02.%E5%9C%BA%E6%99%AF/04.RequestAnimationFrame%E4%B8%8E%E6%BB%9A%E5%8A%A8.html",relativePath:"02.场景/04.RequestAnimationFrame与滚动.md",key:"v-1435df20",path:"/pages/8bee02/",headers:[{level:4,title:"对于 requestAnimationFrame 的理解",slug:"对于-requestanimationframe-的理解",normalizedTitle:"对于 requestanimationframe 的理解",charIndex:2},{level:4,title:"使用 requestAnimationFrame写一个精准的定时器",slug:"使用-requestanimationframe写一个精准的定时器",normalizedTitle:"使用 requestanimationframe写一个精准的定时器",charIndex:243},{level:4,title:"使用 requestAnimationFrame 实现滚动",slug:"使用-requestanimationframe-实现滚动",normalizedTitle:"使用 requestanimationframe 实现滚动",charIndex:1178}],headersStr:"对于 requestAnimationFrame 的理解 使用 requestAnimationFrame写一个精准的定时器 使用 requestAnimationFrame 实现滚动",content:"# 对于 requestAnimationFrame 的理解\n\nwindow.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\n\n这种方式比传统的setTimeout更加精准，因为requestAnimationFrame会在浏览器重绘之前执行，从而减少了时间误差。\n\nrequestAnimationFrame\n\n# 使用 requestAnimationFrame写一个精准的定时器\n\n/**\n * 使用requestAnimationFrame实现的精准定时器\n * @param {Function} callback - 需要执行的回调函数\n * @param {number} delay - 延迟时间，单位为毫秒\n */\nfunction rafTimer(callback, delay) {\n  let start = null;\n  let rafId;\n\n  // requestAnimationFrame的回调函数\n  const step = (timestamp) => {\n    // 初始化开始时间\n    if (!start) start = timestamp;\n    // 计算经过的时间\n    const progress = timestamp - start;\n    // 如果经过的时间大于等于设置的延迟时间，则执行回调函数\n    if (progress >= delay) {\n      callback();\n    } else {\n      // 否则继续下一帧\n      rafId = requestAnimationFrame(step);\n    }\n  };\n\n  // 开始执行\n  rafId = requestAnimationFrame(step);\n\n  // 返回一个函数，用于取消定时器\n  return () => {\n    cancelAnimationFrame(rafId);\n  };\n}\n\n// 使用示例\nconst cancelRafTimer = rafTimer(() => {\n  console.log('执行回调');\n}, 2000);\n\n// 如果需要取消定时器，可以调用返回的函数\n// cancelRafTimer();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n# 使用 requestAnimationFrame 实现滚动\n\n/**\n * 使用requestAnimationFrame实现平滑滚动\n * @param {Element} element - 需要滚动的元素\n * @param {number} target - 目标滚动位置\n * @param {number} duration - 滚动持续时间，单位为毫秒\n */\nfunction smoothScroll(element, target, duration) {\n  let start = element.scrollTop,\n      change = target - start,\n      currentTime = 0,\n      increment = 20;\n\n  const animateScroll = function() {\n    // 增加时间\n    currentTime += increment;\n    // 计算当前动画进度\n    const val = easeInOutQuad(currentTime, start, change, duration);\n    // 设置滚动位置\n    element.scrollTop = val;\n    // 如果当前时间小于总持续时间，继续下一帧动画\n    if (currentTime < duration) {\n      requestAnimationFrame(animateScroll);\n    }\n  };\n\n  // 缓动函数 - 二次方的缓动（t^2）\n  function easeInOutQuad(t, b, c, d) {\n    t /= d / 2;\n    if (t < 1) return c / 2 * t * t + b;\n    t--;\n    return -c / 2 * (t * (t - 2) - 1) + b;\n  }\n\n  animateScroll();\n}\n\n// 使用示例\n// 假设有一个元素需要滚动，id为\"scrollContainer\"\nconst scrollContainer = document.getElementById('scrollContainer');\n// 调用smoothScroll函数，滚动到100px的位置，持续时间为500毫秒\nsmoothScroll(scrollContainer, 100, 500);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n这段代码定义了一个smoothScroll函数，它接收三个参数：需要滚动的元素、目标滚动位置和滚动持续时间。函数内部使用了requestAnimationFrame来实现平滑滚动效果，并通过缓动函数easeInOutQuad来计算每一帧的滚动位置，使得滚动动画更加平滑自然。使用时只需传入相应的参数即可实现平滑滚动效果。",normalizedContent:"# 对于 requestanimationframe 的理解\n\nwindow.requestanimationframe() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\n\n这种方式比传统的settimeout更加精准，因为requestanimationframe会在浏览器重绘之前执行，从而减少了时间误差。\n\nrequestanimationframe\n\n# 使用 requestanimationframe写一个精准的定时器\n\n/**\n * 使用requestanimationframe实现的精准定时器\n * @param {function} callback - 需要执行的回调函数\n * @param {number} delay - 延迟时间，单位为毫秒\n */\nfunction raftimer(callback, delay) {\n  let start = null;\n  let rafid;\n\n  // requestanimationframe的回调函数\n  const step = (timestamp) => {\n    // 初始化开始时间\n    if (!start) start = timestamp;\n    // 计算经过的时间\n    const progress = timestamp - start;\n    // 如果经过的时间大于等于设置的延迟时间，则执行回调函数\n    if (progress >= delay) {\n      callback();\n    } else {\n      // 否则继续下一帧\n      rafid = requestanimationframe(step);\n    }\n  };\n\n  // 开始执行\n  rafid = requestanimationframe(step);\n\n  // 返回一个函数，用于取消定时器\n  return () => {\n    cancelanimationframe(rafid);\n  };\n}\n\n// 使用示例\nconst cancelraftimer = raftimer(() => {\n  console.log('执行回调');\n}, 2000);\n\n// 如果需要取消定时器，可以调用返回的函数\n// cancelraftimer();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n# 使用 requestanimationframe 实现滚动\n\n/**\n * 使用requestanimationframe实现平滑滚动\n * @param {element} element - 需要滚动的元素\n * @param {number} target - 目标滚动位置\n * @param {number} duration - 滚动持续时间，单位为毫秒\n */\nfunction smoothscroll(element, target, duration) {\n  let start = element.scrolltop,\n      change = target - start,\n      currenttime = 0,\n      increment = 20;\n\n  const animatescroll = function() {\n    // 增加时间\n    currenttime += increment;\n    // 计算当前动画进度\n    const val = easeinoutquad(currenttime, start, change, duration);\n    // 设置滚动位置\n    element.scrolltop = val;\n    // 如果当前时间小于总持续时间，继续下一帧动画\n    if (currenttime < duration) {\n      requestanimationframe(animatescroll);\n    }\n  };\n\n  // 缓动函数 - 二次方的缓动（t^2）\n  function easeinoutquad(t, b, c, d) {\n    t /= d / 2;\n    if (t < 1) return c / 2 * t * t + b;\n    t--;\n    return -c / 2 * (t * (t - 2) - 1) + b;\n  }\n\n  animatescroll();\n}\n\n// 使用示例\n// 假设有一个元素需要滚动，id为\"scrollcontainer\"\nconst scrollcontainer = document.getelementbyid('scrollcontainer');\n// 调用smoothscroll函数，滚动到100px的位置，持续时间为500毫秒\nsmoothscroll(scrollcontainer, 100, 500);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n这段代码定义了一个smoothscroll函数，它接收三个参数：需要滚动的元素、目标滚动位置和滚动持续时间。函数内部使用了requestanimationframe来实现平滑滚动效果，并通过缓动函数easeinoutquad来计算每一帧的滚动位置，使得滚动动画更加平滑自然。使用时只需传入相应的参数即可实现平滑滚动效果。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"前端路由",frontmatter:{title:"前端路由",date:"2024-08-18T15:34:18.000Z",permalink:"/pages/b1d0fe/",categories:["场景"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/02.%E5%9C%BA%E6%99%AF/07.%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.html",relativePath:"02.场景/07.前端路由.md",key:"v-1cdc20aa",path:"/pages/b1d0fe/",headers:[{level:2,title:"问题记录",slug:"问题记录",normalizedTitle:"问题记录",charIndex:2},{level:2,title:"后端路由",slug:"后端路由",normalizedTitle:"后端路由",charIndex:133},{level:2,title:"前端路由",slug:"前端路由",normalizedTitle:"前端路由",charIndex:219},{level:3,title:"Hash 模式路由",slug:"hash-模式路由",normalizedTitle:"hash 模式路由",charIndex:255},{level:3,title:"History模式路由",slug:"history模式路由",normalizedTitle:"history模式路由",charIndex:732},{level:2,title:"解决路由问题",slug:"解决路由问题",normalizedTitle:"解决路由问题",charIndex:1021},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:1114}],headersStr:"问题记录 后端路由 前端路由 Hash 模式路由 History模式路由 解决路由问题 参考文章",content:"# 问题记录\n\n笔记\n\n在部署网页到github-pages上时，发现我的网页只有根路由可以直接通过url访问，而其他路由不行，只能通过将history路由更改为hash路由才能正常访问\n\n因此，我发现自己在路由方面的知识还有所不足，特意写下此篇作为记录。\n\n\n# 后端路由\n\n在 web 开发早期，一直是后端路由占据主要地位，每次用户发出请求，URL就会发生变化，后端收到请求之后就会根据路由渲染对应的页面，将页面返回到本地。\n\n\n# 前端路由\n\n提示\n\n前端路由是单页面应用兴起之后才开始出现的。\n\n\n# Hash 模式路由\n\n早起的前端路由实现就是基于location.hash来实现的，location.hash就是路由#后面的内容，其原理就是通过hashchange监听#后面的内容的变化来进行页面更新。hash模式是利用浏览器不会对#后面的路径对服务端发起请求。\n\n使用hash模式有两个特点：\n\n * 改变hash值，浏览器不会重新加载页面\n * 当刷新页面时，hash不会传给服务器\n * 也就是说http://localhost/#a与http://localhost/这两个路由其实都是去请求http://localhost这个页面的内容，至于为什么它们可以渲染出不同的页面，这个是前端自己来判断的，不需要后端配置。\n\n优点：\n\n * 可以兼容低版本浏览器，支持IE8\n * 只有#之前的内容才会作为URL发送给服务器，就算服务端没有对路由进行全覆盖也不会返回404\n * hash改变都会在浏览器访问的历史记录中增加一个记录，所以可以通过浏览器进行前进后退，如果想在hash模式下不保存记录，可以使用location.replace\n\n\n# History模式路由\n\nhistory是基于HTML5新增的pushState和replaceState两个API以及浏览器的popState事件监听历史栈的改变，只要历史栈有信息发生改变，就会触发该事件。这种模式同样也是不会向后端发起请求的。\n\n优点：\n\n * 该模式的路由不带#，看起来更美观\n * pushState设置的URL可以是任意的与当前URL同源的URL，而hash只能改变#后面的内容\n\n缺点：\n\n * IE9及其以下版本浏览器不支持，IE10开始支持\n\nvue-router会检测浏览器版本，当无法启用history模式时会自动降级为hash模式\n\n\n# 解决路由问题\n\n * 将 basename 加入到路由定义中\n * 加入 404 页面进行重定向\n * index.html 配合解析路径，replaceState到对应的路由\n\n\n# 参考文章\n\n上集 下集",normalizedContent:"# 问题记录\n\n笔记\n\n在部署网页到github-pages上时，发现我的网页只有根路由可以直接通过url访问，而其他路由不行，只能通过将history路由更改为hash路由才能正常访问\n\n因此，我发现自己在路由方面的知识还有所不足，特意写下此篇作为记录。\n\n\n# 后端路由\n\n在 web 开发早期，一直是后端路由占据主要地位，每次用户发出请求，url就会发生变化，后端收到请求之后就会根据路由渲染对应的页面，将页面返回到本地。\n\n\n# 前端路由\n\n提示\n\n前端路由是单页面应用兴起之后才开始出现的。\n\n\n# hash 模式路由\n\n早起的前端路由实现就是基于location.hash来实现的，location.hash就是路由#后面的内容，其原理就是通过hashchange监听#后面的内容的变化来进行页面更新。hash模式是利用浏览器不会对#后面的路径对服务端发起请求。\n\n使用hash模式有两个特点：\n\n * 改变hash值，浏览器不会重新加载页面\n * 当刷新页面时，hash不会传给服务器\n * 也就是说http://localhost/#a与http://localhost/这两个路由其实都是去请求http://localhost这个页面的内容，至于为什么它们可以渲染出不同的页面，这个是前端自己来判断的，不需要后端配置。\n\n优点：\n\n * 可以兼容低版本浏览器，支持ie8\n * 只有#之前的内容才会作为url发送给服务器，就算服务端没有对路由进行全覆盖也不会返回404\n * hash改变都会在浏览器访问的历史记录中增加一个记录，所以可以通过浏览器进行前进后退，如果想在hash模式下不保存记录，可以使用location.replace\n\n\n# history模式路由\n\nhistory是基于html5新增的pushstate和replacestate两个api以及浏览器的popstate事件监听历史栈的改变，只要历史栈有信息发生改变，就会触发该事件。这种模式同样也是不会向后端发起请求的。\n\n优点：\n\n * 该模式的路由不带#，看起来更美观\n * pushstate设置的url可以是任意的与当前url同源的url，而hash只能改变#后面的内容\n\n缺点：\n\n * ie9及其以下版本浏览器不支持，ie10开始支持\n\nvue-router会检测浏览器版本，当无法启用history模式时会自动降级为hash模式\n\n\n# 解决路由问题\n\n * 将 basename 加入到路由定义中\n * 加入 404 页面进行重定向\n * index.html 配合解析路径，replacestate到对应的路由\n\n\n# 参考文章\n\n上集 下集",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"教程中的难点",frontmatter:{title:"教程中的难点",date:"2024-05-19T21:41:03.000Z",permalink:"/pages/0a5e76/",categories:["技术","TypeScript"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.TypeScript/02.%E6%95%99%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%9A%BE%E7%82%B9.html",relativePath:"03.技术/02.TypeScript/02.教程中的难点.md",key:"v-4dfee520",path:"/pages/0a5e76/",headers:[{level:4,title:"TypeScript 基础",slug:"typescript-基础",normalizedTitle:"typescript 基础",charIndex:51},{level:4,title:"常见的 TypeScript 类型",slug:"常见的-typescript-类型",normalizedTitle:"常见的 typescript 类型",charIndex:376},{level:4,title:"类型缩窄",slug:"类型缩窄",normalizedTitle:"类型缩窄",charIndex:1332},{level:4,title:"函数专题",slug:"函数专题",normalizedTitle:"函数专题",charIndex:2903}],headersStr:"TypeScript 基础 常见的 TypeScript 类型 类型缩窄 函数专题",content:'提示\n\n本文整理自 TypeScript 官方文档中的 handlebook，版本为 V5.4\n\n# TypeScript 基础\n\n * 静态类型检查\n   * Typescript 会检查类型是否符合\n   * Typescript 会检查参数值是否符合预期\n\nfunction greet(person, date) {\n  console.log(`Hello ${person}, today is ${date}!`)\n}\n\ngreet("Brendan") // 提示缺一个参数\n\n\n1\n2\n3\n4\n5\n\n * 类型注释永远不会改变程序运行时的行为\n * 默认情况下，可以使用 any，并且可以将 null 和 undefined 赋值给任何其他类型\n * 可以使用 use strict 来改变 Typescipt 检验类型的程度\n\n# 常见的 TypeScript 类型\n\n * 最原始的类型：string number boolean\n * 指定数组类型的方法\n   * arr: number[]\n   * arr: Array<number>\n * any 是特殊类型，如果不希望特定值导致类型检验错误可以使用 any\n * TypeScript 允许制定 Functions 的输入和输出值的类型\n * 指定返回 Promise 的函数\n\nasync function getFavoriteNumber(): Promise<number> {\n  return 26\n}\n\n\n1\n2\n3\n\n * 在函数作为回调函数而匿名时，ts 会自动对其进行转义\n * 对象类型\n   * obj: { first: string, second: number }\n   * 在对象类型的属性后加入?表示可选属性\n * 使用 | 可以连接两个符号\n * 类型别名(type alias)\n   * type Point = { x: number; y: number }\n   * type alias 只是其他类型别名，并不是创造了一种新的类型，可以理解为引用了某种类型\n * 接口声明(interfaces)\n   * 也可以用以声明对象的属性，大部分情况下，interface 和 type 是可以混用的\n * interface 和 type 的区别\n   * type alias 不可以重新打开加入新的属性，接口始终是可以扩展的\n * 类型断言\n   * 可以使用类型断言来帮助 ts 理解对应的类型，但是如果判断错了，ts 将不会生成异常或者 null\n * 可列举的类型\n   * 可以在类型中引入特定的字符串和数字\n   * boolean 实际上只是联合了 true 和 false 的类型\n   * 使用 as const 将会使一个对象被转化为一个可列举的对象类型\n * null 和 undefined\n   * 开启 strictNullChecks 后不允许 undefined 和 null 赋值给任何类型\n   * 非空断言运算符，x!.toFixed()\n * bigInt 和 symbol 不太常见\n\n# 类型缩窄\n\n * 通常，我们需要使用 if - else 来缩小类型的范围\n\nfunciton padLeft (padding: number | string, input: string): string {\n  if (typeof padding === \'number\') {\n    return \' \'.repeat(padding) + input\n  }\n  return padding + input\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 使用 typeof 来规避 null 或 undefined 存在 typeof null === \'object\' 的问题，官方更加推荐使用 !variable 来判断对应的变量是否为 null 或者 undefined\n * Typescript 还会根据等号条件(==, !=, ===, !==)来进行类型范围的缩小\n * TypeScript 会根据 in 关键字来缩小类型检查的范围\n   * in 关键字会检查某个属性是否出现在一个对象的原型链上\n * instanceof 也可以帮助 TypeScript 缩小类型范围\n * 在进行第一次赋值时，TypeScript 会对变量进行合适的类型缩小\n * 在开头的代码中，TypeScript 实际上用到了控制流分析，第一个 if 后，padding 就只能是 string 了，所以可以在控制流的情况下限制了 padding 的类型\n * 类型谓语\n   * 使用类型谓语可以进行类型守卫，常见用法如下\n\ninterface Bird {\n  fly: () => void\n}\n\ninterface Fish {\n  swim: () => void\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在使用类型谓语时，实际上已经已经默认返回值为 boolean 类型了，所以不需要指定返回值的类型。 类型谓语的作用在于提前缩小参数的范围，从而使用更简单的逻辑来判断参数是否为某个类型。\n\n * 在已经消除了所有可能性之后，ts 使用 never 表示剩余的类型可能性。\n\n * 场景题\n\n/**\n * @description 设想一个场景，要定义一个可能是圆形也可能是正方形的类型，如何书写类型以便于更好的求得面积\n */\nfunction getArea(shape) {\n  switch (shape.kind) {\n    case "circle":\n      return Math.PI * shape.radius * shape.radius\n    case "square":\n      return shape.side * shape.side\n    default:\n      throw new Error("unexpected shape")\n  }\n}\n// 测试\nvar shape = {\n  kind: "circle",\n  radius: 10,\n}\nconsole.log(getArea(shape)) // 314.1592653589793\nvar shape2 = {\n  kind: "square",\n  side: 10,\n}\nconsole.log(getArea(shape2)) //100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 函数专题\n\n * 通常使用类似于箭头函数的形式来描述一个函数的类型\n   * fn: (a: string) => string\n   * 以上的写法无法描述函数的属性，例如 description\n\n// 定义函数的属性\ntype DescribableFunction = {\n  description: string\n  (someArg: string): boolean // 此处不能使用箭头，而是使用 :\n}\n\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + " " + fn("foo"))\n}\n\nfunction isFoo(someArg: string) {\n  return someArg === "foo"\n}\n\nisFoo.description = "isFoo"\ndoSomething(isFoo)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 构造函数同样也可以使用 TypeScript 进行类型声明\n\ntype someConstructor = {\n  new (s: string) => someObject\n}\nfunction fn(ctor: someConstructor) {\n  return new ctor(\'hello\')\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 有些函数既可以使用 new 关键字调用，也可以直接调用，于是可以组合\n\ninterface CallOrConstruct {\n  (n?: number): string\n  new (s: string): Date\n}\n\n\n1\n2\n3\n4\n\n * 泛型\n\nfunction firstElement<type>(arr: type[]): type | undefined {\n  return arr[0]\n}\n\nconsole.log(firstElement(["1", "2", "3", 1]))\nconsole.log(firstElement([1, 2, 3]))\nconsole.log(firstElement([]))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 要在函数名后面加 <TypeName> 来声明这是一个泛型函数，传入的类型和返回值可以根据这个泛型函数运算\n   * 泛型的传入可以不止一个\n * 在使用泛型时，可以使用相应的声明来对传入的类型做一次类型检查\n\nfunction longest<Type extends { length: number }>(a: Type, b: Type) {\n  if (a.length > b.length) {\n    return a\n  }\n  return b\n}\n\nconst longerArray = longest([1, 2], [1, 2, 3])\nconst longerString = longest("alice", "bob")\n// const notOk = longest(1, 2) // 1没有length属性，ts报错\nconsole.log(longerArray, longerString)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n// 使用泛型约束时返回的类型必须是传入的类型之一，而不是与目标匹配的类型\nfunction minimumLength<Type extends { length: number }> {\n  obj: Type\n  minimum: number\n}: Type {\n  if (obj.length >= minimum) {\n    return obj\n  }\n  // 这里会报错，因为 { length: minimum } 虽然符合限制，但是却不是传入的类型\n  return { length: minimum }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 在调用包含泛型的函数时，可以手动声明函数的泛型\n\nfunction combine<Type>(arr1: Type[], arr2: Type[]): Type[] {\n  return arr1.concat(arr2)\n}\n// const arr = combine([1,2,3], [\'1\']) // 将会报错，因为第一个参数决定了类型为number，而第二个参数又为string\nconst arr = combine<number | string>([1, 2, 3], ["1"]) // 不会报错，手动声明了泛型的范围\n\n\n1\n2\n3\n4\n5\n\n\n * 如何写一个合适的泛型\n   \n   * 使用 type 本身，而不是约束，如使用 type 而不是 type extends any\n   * 使用尽可能少的泛型参数\n   * 泛型参数总是要出现两次，一次是传入，一次是传出，如果只有一次需要这个类型，也许我们不需要泛型\n\n * 在回调函数中加入可选参数需要进一步限制类型，尽可能不要在回调函数中传入可选参数\n\n * 重载签名\n\nfunction makeDate(timestamp: number): Date // 重载签名1\nfunction makeDate(m: number, d: number, y: number): Date // 重载签名2 需要与重载签名1兼容\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  // 实现签名，需要与前两个重载签名兼容\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d)\n  } else {\n    return new Date(mOrTimestamp)\n  }\n}\n\n// 此时 makeDate 函数可以传入一个参数或者传入3个参数\nmakeDate(12345678) // 传入一个参数\nmakeDate(1, 2, 3) // 传入3个参数\n// makeDate(1, 2) // 传入2个参数将会报错，因为没有定义传入两个参数的重载函数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n * 编写重载的规则\n   \n   * 尽可能使用联合类型的参数，而不是重载函数\n\n * 在函数中声明 this 的类型\n\ninterface User {\n  id: number\n  admin: false\n  becomeAdmin: () => void\n}\n\ninterface DB {\n  ... // 其他DB的属性\n  filterUsers(filter: (this: User) => boolean): User[];\n}\n\nconst user = {\n  id: 1,\n  admin: false,\n  becomeAdmin: function () {\n    this.admin = true\n  }\n}\n\nconst db: DB = getDB()\ndb.filterUsers(function (this: User) { // 如果涉及到 this，务必使用 function 而不是箭头函数\n  return this.admin\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n * 其他需要了解到类型\n   \n   * void 表示不返回值的函数的返回值\n   * object (并非是 Object)表示任何不是基元的值\n   * unknown 可以接受任何类型的值，但是 unknown 不能接受任何操作\n   * never 表示会报错或者终止程序的返回值，或是确定联合中已不剩任何内容\n   * Function 描述了全局函数类型\n\n * 剩余参数\n\n// 使用展开运算符传入剩余参数\nfunction multiply(n: number, ...m: number[]) {\n  return m.map((x) => n * x)\n}\n\n// 同时也可以使用展开运算符传入参数\n// TypeScript 默认数组不是不可修改的，因此会有一些需要注意的地方\nconst args = [8, 5]\nconst angle = Math.atan2(...args) // 扩张参数必须具有元组类型或传递给 rest 参数。\n\nconst args2 = [8, 5] as const // 使用 const 声明确保此数组不会发生变化\nconst angle2 = Math.atan2(...args2) // 此时不会再报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 参数结构\n\n// 写法1\nfunction sum({ a, b, c }: { a: number; b: number; c: number }) {\n  return a + b + c\n}\n\n// 写法2\ntype ABC = {\n  a: number\n  b: number\n  c: number\n}\n\nfunction sum({ a, b, c }: ABC) {\n  return a + b + c\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * void 返回值\n\n// 通常定义返回值类型为void的函数可以返回值\ntype voidFunc = () => void\n\nconst f1: voidFunc = () => {\n  return true\n}\n\nconst f2: voidFunc = () => true\n\nconst f3: voidFunc = function () {\n  return true\n}\n\n// literal function 定义了void返回值但是返回将会报错\nfunction f(): void {\n  return 1 // 不能将类型“number”分配给类型“void”。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:'提示\n\n本文整理自 typescript 官方文档中的 handlebook，版本为 v5.4\n\n# typescript 基础\n\n * 静态类型检查\n   * typescript 会检查类型是否符合\n   * typescript 会检查参数值是否符合预期\n\nfunction greet(person, date) {\n  console.log(`hello ${person}, today is ${date}!`)\n}\n\ngreet("brendan") // 提示缺一个参数\n\n\n1\n2\n3\n4\n5\n\n * 类型注释永远不会改变程序运行时的行为\n * 默认情况下，可以使用 any，并且可以将 null 和 undefined 赋值给任何其他类型\n * 可以使用 use strict 来改变 typescipt 检验类型的程度\n\n# 常见的 typescript 类型\n\n * 最原始的类型：string number boolean\n * 指定数组类型的方法\n   * arr: number[]\n   * arr: array<number>\n * any 是特殊类型，如果不希望特定值导致类型检验错误可以使用 any\n * typescript 允许制定 functions 的输入和输出值的类型\n * 指定返回 promise 的函数\n\nasync function getfavoritenumber(): promise<number> {\n  return 26\n}\n\n\n1\n2\n3\n\n * 在函数作为回调函数而匿名时，ts 会自动对其进行转义\n * 对象类型\n   * obj: { first: string, second: number }\n   * 在对象类型的属性后加入?表示可选属性\n * 使用 | 可以连接两个符号\n * 类型别名(type alias)\n   * type point = { x: number; y: number }\n   * type alias 只是其他类型别名，并不是创造了一种新的类型，可以理解为引用了某种类型\n * 接口声明(interfaces)\n   * 也可以用以声明对象的属性，大部分情况下，interface 和 type 是可以混用的\n * interface 和 type 的区别\n   * type alias 不可以重新打开加入新的属性，接口始终是可以扩展的\n * 类型断言\n   * 可以使用类型断言来帮助 ts 理解对应的类型，但是如果判断错了，ts 将不会生成异常或者 null\n * 可列举的类型\n   * 可以在类型中引入特定的字符串和数字\n   * boolean 实际上只是联合了 true 和 false 的类型\n   * 使用 as const 将会使一个对象被转化为一个可列举的对象类型\n * null 和 undefined\n   * 开启 strictnullchecks 后不允许 undefined 和 null 赋值给任何类型\n   * 非空断言运算符，x!.tofixed()\n * bigint 和 symbol 不太常见\n\n# 类型缩窄\n\n * 通常，我们需要使用 if - else 来缩小类型的范围\n\nfunciton padleft (padding: number | string, input: string): string {\n  if (typeof padding === \'number\') {\n    return \' \'.repeat(padding) + input\n  }\n  return padding + input\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 使用 typeof 来规避 null 或 undefined 存在 typeof null === \'object\' 的问题，官方更加推荐使用 !variable 来判断对应的变量是否为 null 或者 undefined\n * typescript 还会根据等号条件(==, !=, ===, !==)来进行类型范围的缩小\n * typescript 会根据 in 关键字来缩小类型检查的范围\n   * in 关键字会检查某个属性是否出现在一个对象的原型链上\n * instanceof 也可以帮助 typescript 缩小类型范围\n * 在进行第一次赋值时，typescript 会对变量进行合适的类型缩小\n * 在开头的代码中，typescript 实际上用到了控制流分析，第一个 if 后，padding 就只能是 string 了，所以可以在控制流的情况下限制了 padding 的类型\n * 类型谓语\n   * 使用类型谓语可以进行类型守卫，常见用法如下\n\ninterface bird {\n  fly: () => void\n}\n\ninterface fish {\n  swim: () => void\n}\n\nfunction isfish(pet: fish | bird): pet is fish {\n  return (pet as fish).swim !== undefined\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在使用类型谓语时，实际上已经已经默认返回值为 boolean 类型了，所以不需要指定返回值的类型。 类型谓语的作用在于提前缩小参数的范围，从而使用更简单的逻辑来判断参数是否为某个类型。\n\n * 在已经消除了所有可能性之后，ts 使用 never 表示剩余的类型可能性。\n\n * 场景题\n\n/**\n * @description 设想一个场景，要定义一个可能是圆形也可能是正方形的类型，如何书写类型以便于更好的求得面积\n */\nfunction getarea(shape) {\n  switch (shape.kind) {\n    case "circle":\n      return math.pi * shape.radius * shape.radius\n    case "square":\n      return shape.side * shape.side\n    default:\n      throw new error("unexpected shape")\n  }\n}\n// 测试\nvar shape = {\n  kind: "circle",\n  radius: 10,\n}\nconsole.log(getarea(shape)) // 314.1592653589793\nvar shape2 = {\n  kind: "square",\n  side: 10,\n}\nconsole.log(getarea(shape2)) //100\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 函数专题\n\n * 通常使用类似于箭头函数的形式来描述一个函数的类型\n   * fn: (a: string) => string\n   * 以上的写法无法描述函数的属性，例如 description\n\n// 定义函数的属性\ntype describablefunction = {\n  description: string\n  (somearg: string): boolean // 此处不能使用箭头，而是使用 :\n}\n\nfunction dosomething(fn: describablefunction) {\n  console.log(fn.description + " " + fn("foo"))\n}\n\nfunction isfoo(somearg: string) {\n  return somearg === "foo"\n}\n\nisfoo.description = "isfoo"\ndosomething(isfoo)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 构造函数同样也可以使用 typescript 进行类型声明\n\ntype someconstructor = {\n  new (s: string) => someobject\n}\nfunction fn(ctor: someconstructor) {\n  return new ctor(\'hello\')\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 有些函数既可以使用 new 关键字调用，也可以直接调用，于是可以组合\n\ninterface callorconstruct {\n  (n?: number): string\n  new (s: string): date\n}\n\n\n1\n2\n3\n4\n\n * 泛型\n\nfunction firstelement<type>(arr: type[]): type | undefined {\n  return arr[0]\n}\n\nconsole.log(firstelement(["1", "2", "3", 1]))\nconsole.log(firstelement([1, 2, 3]))\nconsole.log(firstelement([]))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 要在函数名后面加 <typename> 来声明这是一个泛型函数，传入的类型和返回值可以根据这个泛型函数运算\n   * 泛型的传入可以不止一个\n * 在使用泛型时，可以使用相应的声明来对传入的类型做一次类型检查\n\nfunction longest<type extends { length: number }>(a: type, b: type) {\n  if (a.length > b.length) {\n    return a\n  }\n  return b\n}\n\nconst longerarray = longest([1, 2], [1, 2, 3])\nconst longerstring = longest("alice", "bob")\n// const notok = longest(1, 2) // 1没有length属性，ts报错\nconsole.log(longerarray, longerstring)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n// 使用泛型约束时返回的类型必须是传入的类型之一，而不是与目标匹配的类型\nfunction minimumlength<type extends { length: number }> {\n  obj: type\n  minimum: number\n}: type {\n  if (obj.length >= minimum) {\n    return obj\n  }\n  // 这里会报错，因为 { length: minimum } 虽然符合限制，但是却不是传入的类型\n  return { length: minimum }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 在调用包含泛型的函数时，可以手动声明函数的泛型\n\nfunction combine<type>(arr1: type[], arr2: type[]): type[] {\n  return arr1.concat(arr2)\n}\n// const arr = combine([1,2,3], [\'1\']) // 将会报错，因为第一个参数决定了类型为number，而第二个参数又为string\nconst arr = combine<number | string>([1, 2, 3], ["1"]) // 不会报错，手动声明了泛型的范围\n\n\n1\n2\n3\n4\n5\n\n\n * 如何写一个合适的泛型\n   \n   * 使用 type 本身，而不是约束，如使用 type 而不是 type extends any\n   * 使用尽可能少的泛型参数\n   * 泛型参数总是要出现两次，一次是传入，一次是传出，如果只有一次需要这个类型，也许我们不需要泛型\n\n * 在回调函数中加入可选参数需要进一步限制类型，尽可能不要在回调函数中传入可选参数\n\n * 重载签名\n\nfunction makedate(timestamp: number): date // 重载签名1\nfunction makedate(m: number, d: number, y: number): date // 重载签名2 需要与重载签名1兼容\nfunction makedate(mortimestamp: number, d?: number, y?: number): date {\n  // 实现签名，需要与前两个重载签名兼容\n  if (d !== undefined && y !== undefined) {\n    return new date(y, mortimestamp, d)\n  } else {\n    return new date(mortimestamp)\n  }\n}\n\n// 此时 makedate 函数可以传入一个参数或者传入3个参数\nmakedate(12345678) // 传入一个参数\nmakedate(1, 2, 3) // 传入3个参数\n// makedate(1, 2) // 传入2个参数将会报错，因为没有定义传入两个参数的重载函数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n * 编写重载的规则\n   \n   * 尽可能使用联合类型的参数，而不是重载函数\n\n * 在函数中声明 this 的类型\n\ninterface user {\n  id: number\n  admin: false\n  becomeadmin: () => void\n}\n\ninterface db {\n  ... // 其他db的属性\n  filterusers(filter: (this: user) => boolean): user[];\n}\n\nconst user = {\n  id: 1,\n  admin: false,\n  becomeadmin: function () {\n    this.admin = true\n  }\n}\n\nconst db: db = getdb()\ndb.filterusers(function (this: user) { // 如果涉及到 this，务必使用 function 而不是箭头函数\n  return this.admin\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n * 其他需要了解到类型\n   \n   * void 表示不返回值的函数的返回值\n   * object (并非是 object)表示任何不是基元的值\n   * unknown 可以接受任何类型的值，但是 unknown 不能接受任何操作\n   * never 表示会报错或者终止程序的返回值，或是确定联合中已不剩任何内容\n   * function 描述了全局函数类型\n\n * 剩余参数\n\n// 使用展开运算符传入剩余参数\nfunction multiply(n: number, ...m: number[]) {\n  return m.map((x) => n * x)\n}\n\n// 同时也可以使用展开运算符传入参数\n// typescript 默认数组不是不可修改的，因此会有一些需要注意的地方\nconst args = [8, 5]\nconst angle = math.atan2(...args) // 扩张参数必须具有元组类型或传递给 rest 参数。\n\nconst args2 = [8, 5] as const // 使用 const 声明确保此数组不会发生变化\nconst angle2 = math.atan2(...args2) // 此时不会再报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 参数结构\n\n// 写法1\nfunction sum({ a, b, c }: { a: number; b: number; c: number }) {\n  return a + b + c\n}\n\n// 写法2\ntype abc = {\n  a: number\n  b: number\n  c: number\n}\n\nfunction sum({ a, b, c }: abc) {\n  return a + b + c\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * void 返回值\n\n// 通常定义返回值类型为void的函数可以返回值\ntype voidfunc = () => void\n\nconst f1: voidfunc = () => {\n  return true\n}\n\nconst f2: voidfunc = () => true\n\nconst f3: voidfunc = function () {\n  return true\n}\n\n// literal function 定义了void返回值但是返回将会报错\nfunction f(): void {\n  return 1 // 不能将类型“number”分配给类型“void”。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"技术",frontmatter:{title:"技术",date:"2024-05-19T19:28:20.000Z",permalink:"/technology/",categories:["技术"],tags:[null],article:!1,author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF.html",relativePath:"03.技术/01.技术.md",key:"v-4a7dec34",path:"/technology/",headersStr:null,content:"> 在这里，我想要写一些自己在非前端领域的技术积累，无论是语言方面，学习了 C++、Rust等，还是熟悉了Linux、macos操作指令，都希望放在这里",normalizedContent:"> 在这里，我想要写一些自己在非前端领域的技术积累，无论是语言方面，学习了 c++、rust等，还是熟悉了linux、macos操作指令，都希望放在这里",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"前言",frontmatter:{title:"前言",date:"2024-05-19T21:33:17.000Z",permalink:"/pages/064912/",categories:["技术","TypeScript"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.TypeScript/01.%E5%89%8D%E8%A8%80.html",relativePath:"03.技术/02.TypeScript/01.前言.md",key:"v-5862c350",path:"/pages/064912/",headers:[{level:4,title:"学习前对 TypeScript 的认知",slug:"学习前对-typescript-的认知",normalizedTitle:"学习前对 typescript 的认知",charIndex:2},{level:4,title:"对 TypeScript 的期待",slug:"对-typescript-的期待",normalizedTitle:"对 typescript 的期待",charIndex:138}],headersStr:"学习前对 TypeScript 的认知 对 TypeScript 的期待",content:"# 学习前对 TypeScript 的认知\n\n 1. 已有过使用TypeScript开发的经验，但是仅停留在半js半ts的阶段\n 2. 了解过ts的基本类型，但是对其编译的机制还不算很了解\n 3. 对于ts的高级特性还不算很熟悉，对泛型、函数重载、装饰器等概念一知半解\n\n# 对 TypeScript 的期待\n\n 1. 通过学习 ts，我能够养成规范开发的习惯，同时加强个人对面向对象的理解\n 2. 通过学习 ts，之后我学习其他静态类型的语言或许上手也能更快\n 3. 更重要的，学习 ts 让我能够更轻松地看懂当前的项目，不会因为技术上的原因受阻",normalizedContent:"# 学习前对 typescript 的认知\n\n 1. 已有过使用typescript开发的经验，但是仅停留在半js半ts的阶段\n 2. 了解过ts的基本类型，但是对其编译的机制还不算很了解\n 3. 对于ts的高级特性还不算很熟悉，对泛型、函数重载、装饰器等概念一知半解\n\n# 对 typescript 的期待\n\n 1. 通过学习 ts，我能够养成规范开发的习惯，同时加强个人对面向对象的理解\n 2. 通过学习 ts，之后我学习其他静态类型的语言或许上手也能更快\n 3. 更重要的，学习 ts 让我能够更轻松地看懂当前的项目，不会因为技术上的原因受阻",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"教程中的难点2",frontmatter:{title:"教程中的难点2",date:"2024-05-20T11:15:47.000Z",permalink:"/pages/e7bde6/",categories:["技术","TypeScript"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.TypeScript/03.%E6%95%99%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%9A%BE%E7%82%B92.html",relativePath:"03.技术/02.TypeScript/03.教程中的难点2.md",key:"v-e113a874",path:"/pages/e7bde6/",headers:[{level:4,title:"对象的类型",slug:"对象的类型",normalizedTitle:"对象的类型",charIndex:51},{level:4,title:"类型体操",slug:"类型体操",normalizedTitle:"类型体操",charIndex:5549},{level:5,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:5255},{level:5,title:"keyof 运算符",slug:"keyof-运算符",normalizedTitle:"keyof 运算符",charIndex:9249},{level:5,title:"typeof 类型运算符",slug:"typeof-类型运算符",normalizedTitle:"typeof 类型运算符",charIndex:9701},{level:5,title:"可以使用类型索引获取对象中的类型",slug:"可以使用类型索引获取对象中的类型",normalizedTitle:"可以使用类型索引获取对象中的类型",charIndex:10131},{level:5,title:"条件类型",slug:"条件类型",normalizedTitle:"条件类型",charIndex:10460},{level:5,title:"模版字符串",slug:"模版字符串",normalizedTitle:"模版字符串",charIndex:1840}],headersStr:"对象的类型 类型体操 泛型 keyof 运算符 typeof 类型运算符 可以使用类型索引获取对象中的类型 条件类型 模版字符串",content:'提示\n\n本文整理自 TypeScript 官方文档中的 handlebook，版本为 V5.4\n\n# 对象的类型\n\n * 对象的类型可以为匿名、类型别名、接口定义的\n\nfunction fn(options: {\n  childEle: HTMLElement\n  parentEle: Element\n  easing: (t: number) => number\n  duration: number | "auto"\n  callback?: () => void\n}): void {} // options 的类型是直接定义的，即匿名的\n\ntype FnOptions = { // 使用类型别名定义\n  childEle: HTMLElement\n  parentEle: Element\n  easing: (t: number) => number\n  duration: number | "auto"\n  callback?: () => void\n}\n\ninterface FnOptionApi { // 使用接口定义\n  childEle: HTMLElement\n  parentEle: Element\n  easing: (t: number) => number\n  duration: number | "auto"\n  callback?: () => void\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 类型中可以加入可选、只读、索引签名\n   * 可选\n\ntype Person = {\n  name: string\n  age?: boolean // 实际上相当于设置 age 的属性为 boolean | undefined\n}\n\n\n1\n2\n3\n4\n\n * 只读\n\ntype Person = {\n  name: string\n  readonly age: boolean // 在属性名前面加上 readonly 标志符将会使属性变为只读的\n}\nconst person: Person = {\n  name: \'joker\',\n  age: 20 // age 属性不可更改，只允许读取\n}\nconsole.log(person.age) // 20\nperson.age = 21 // setter 被禁用了，此时将会报错\n\n/**\n * @description ts 判断类型是否兼容时不会观察 readonly，可以通过这个特性将 readonly 变为可以修改的\n */\ninterface Person {\n  name: string;\n  age: number;\n}\n \ninterface ReadonlyPerson {\n  readonly name: string;\n  readonly age: number;\n}\n \nlet writablePerson: Person = {\n  name: "Person McPersonface",\n  age: 42,\n};\n \n// works\nlet readonlyPerson: ReadonlyPerson = writablePerson;\n \nconsole.log(readonlyPerson.age); // prints \'42\'\nwritablePerson.age++;\nconsole.log(readonlyPerson.age); // prints \'43\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n * 类型修饰\n\n/**\n * @description 类型索引可以帮助我们在不知道确切属性名的情况下对类型作出一定限制\n */\n// 例如当前并不知道数组哪些位置上有值，但是知道时数组，并且对应的值都为\ninterface StringArray {\n  [index: number]: string\n}\n\nconst arr: StringArray = [\'1\', \'2\', \'3\']\n// 索引签名属性允许 string number symbol 模版字符串 或者以上四种的组合\ninterface Person {\n  name: string\n  age: number\n  [action: number | symbol]: () => void\n}\n\nconst xiaoming: Person = { name: \'xiaoming\', age: 20 }\nconst fnSymbol = Symbol(\'小明会跑\')\nxiaoming[fnSymbol] = () => { console.log(\'小明开始跑了\') }\nxiaoming[fnSymbol]()\n\n// 索引签名可以设置 string | number | symbol 但是如果之前已经声明了相关类型，需要与之兼容\n\ninterface Dog {\n  name: string\n  age: number\n  [action: string]: string | number // 只有这样才是与上面两种兼容的，或者将属性名的类型换成 number | symbol，这样才可以赋其他值\n}\n\n// 在索引签名中，也可以加入 readonly，只允许初始化时赋值，之后不可修改\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n * 使用 mapping 操作符可以去除可选和只读修饰符\n\n/**\n * @description 使用 mapping 可以去除可选与只读的命令\n */\ninterface initialType {\n  name?: string\n  readonly age: number\n  readonly [index: number]: string\n  [action: symbol]: () => void\n}\n\n// 使用类型别名复制原来的类型\ntype copiedType = {\n  [T in keyof initialType]: initialType[T]\n}\n\n// 使用类型别名去除可选属性的可选修饰符 name\ntype requiredType = {\n  [T in keyof initialType]-?: initialType[T]\n}\n\n// 使用类型别名去除只读修饰符\ntype modifiableType = {\n  -readonly [T in keyof initialType]: initialType[T]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 在 TypeScript 4.1 以上，可以使用 as 操作符处理映射类型\n\n/**\n * @description 使用 as 操作符来操作映射\n */\ntype Getters<T> = {\n  [Property in keyof T as `get${Capitalize<string & Property>}`]: () => T[Property]\n}\ninterface Person {\n  name: string\n  age: number\n  location: string\n}\n\ntype LazyPerson = Getters<Person>\n\n// 可以通过将属性名的类型设置为 never 来过滤一些属性\ntype RemoveKindField<T> = {\n  [Property in keyof T as Exclude<Property, "kind">]: T[Property]\n}\ninterface Circle {\n  kind: "circle";\n  radius: number;\n}\n\ntype KindlessCircle = RemoveKindField<Circle>;\n\n// 可以联合的类型不只是 string | numebr | symbol\ntype EventConfig<Events extends { kind: string }> = {\n  [E in Events as E["kind"]]: (event: E) => void;\n}\n\ntype SquareEvent = { kind: "square", x: number, y: number };\ntype CircleEvent = { kind: "circle", radius: number };\n\ntype Config = EventConfig<SquareEvent | CircleEvent>\n\n// 进阶类型操作\ntype ExtractPII<Type> = {\n  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;\n};\n \ntype DBFields = {\n  id: { format: "incrementing" };\n  name: { type: string; pii: true };\n};\n \ntype ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * interface 与 type alias 都可以扩展类型，但是处理冲突的方式不一样\n\ninterface BasicAddress {\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalCode: string;\n}\n \ninterface AddressWithUnit extends BasicAddress {\n  unit: string;\n}\n\ninterface Colorful1 {\n  color: string;\n}\n \ninterface Circle1 {\n  radius: number;\n}\n \ninterface ColorfulCircle extends Colorful1, Circle1 {}\n\ntype ColorfulCircle2 = Colorful1 & Circle1\n \nconst cc: ColorfulCircle = {\n  color: "red",\n  radius: 42,\n};\n\nconst cc2: ColorfulCircle = {\n  color: "red",\n  radius: 42,\n};\n\n// 同一属性类型冲突\ninterface CircleArea {\n  kind: \'circle\'\n  radius: number\n  getArea: (radius: number) => number\n}\n\ninterface rectArea {\n  kind: \'rect\'\n  width: number\n  getArea: (width: number) => number\n}\n\ninterface newArea extends CircleArea, rectArea {} // 冲突后提示不能\ntype newArea2  = CircleArea & rectArea // 变为 never，但是不会报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n * 当能使用泛型时，优先使用泛型，而不是函数重载\n * 数组和只读数组的定义就使用了泛型 Array 和 ReadonlyArray\n   * Array 类型的值可以赋值给 ReadonlyArray 类型，反之则无法进行\n * 元组类型定义了每个位置上的值的类型\n   * 元组的可选操作符只能放在最后一位\n   * 元组可以使用展开运算符，将对应的数组和元组类型加入到里面，例如 type StringNumberBooleans = [string, number, ...boolean[]]\n   * 假设定义了某个元组并设置为 as const 将其类型设置为只读的元组是类似的\n\n# 类型体操\n\n# 泛型\n\nfunction Identity<T>(arg: T): T {\n  return arg\n}\n\nfunction numberIdentity (arg: number): number {\n  return arg\n}\n\ninterface GenericIdentityFn<T> {\n  (arg: T): T\n}\n\ntype IdentityFn<T> = (arg: T) => T\n\nconst myIdentity: <T>(arg: T) => T = Identity // 箭头函数形式\nconst myIdentity2: { <T>(arg: T): T } = Identity // 对象形式\nconst knownIdentity: GenericIdentityFn<number> = Identity // 加入 <number> 后，对应函数传入的参数的类型就已知了，不再是泛型了\n\n// 在调用泛型接口和类型别名时，必须传入对应的参数\nconst numberIdentity1: GenericIdentityFn = Identity\nconst numberIdentity4: IdentityFn = Identity\n\nconst numberIdentity2: GenericIdentityFn<string> = Identity\nconst numberIdentity3: GenericIdentityFn<string> = numberIdentity // 此时类型不匹配\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 类也有泛型的概念\n\nclass GenericNumber<NumType> {\n  zeroValue: NumType;\n  add: (x: NumType, y: NumType) => NumType;\n}\n \nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = "";\nstringNumeric.add = function (x, y) {\n  return x + y;\n};\n \nconsole.log(stringNumeric.add(stringNumeric.zeroValue, "test"));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * 泛型类仅在实例端有泛型，在静态端无法应用泛型\n\n * 通用约束\n\ninterface LengthWise {\n  length: number\n}\n\n\n1\n2\n3\n\n * 在泛型约束中也可以加入泛型\n\nfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: key) {\n  return obj[key]\n}\n\n\n1\n2\n3\n\n * 通过构造函数来创建类的实例的过程中，必须通过类的构造函数来引用类类型\n\nclass BeeKeeper {\n  hasMask: boolean = true;\n}\n \nclass ZooKeeper {\n  nametag: string = "Mikle";\n}\n \nclass Animal {\n  numLegs: number = 4;\n}\n \nclass Bee extends Animal {\n  numLegs = 6;\n  keeper: BeeKeeper = new BeeKeeper();\n}\n \nclass Lion extends Animal {\n  keeper: ZooKeeper = new ZooKeeper();\n}\n \nfunction createInstance<A extends Animal>(c: new () => A): A {\n  return new c();\n}\n \ncreateInstance(Lion).keeper.nametag;\ncreateInstance(Bee).keeper.hasMask;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 使用通用参数默认值可以简化函数重载的描述\n\ndeclare function create(): Container<HTMLDivElement, HTMLDivElement[]>;\ndeclare function create<T extends HTMLElement>(element: T): Container<T, T[]>;\ndeclare function create<T extends HTMLElement, U extends HTMLElement>(\n  element: T,\n  children: U[]\n): Container<T, U[]>;\n\n\n1\n2\n3\n4\n5\n6\n\n\ndeclare function create<T extends HTMLElement = HTMLDivElement, U = T[]>(\n  element?: T,\n  children?: U\n): Container<T, U>;\n \nconst div = create();\nconst p = create(new HTMLParagraphElement());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> A generic parameter default follows the following rules: 泛型参数默认遵循以下规则：\n\n> A type parameter is deemed optional if it has a default. 如果类型参数具有默认值，则该参数被视为可选参数。\n\n> Required type parameters must not follow optional type parameters. 必需的类型参数不得遵循可选的类型参数。\n\n> Default types for a type parameter must satisfy the constraint for the type parameter, if it exists. 类型参数的默认类型必须满足类型参数的约束（如果存在）。\n\n> When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types. 指定类型参数时，只需为所需的类型参数指定类型参数。未指定的类型参数将解析为其默认类型。\n\n> If a default type is specified and inference cannot choose a candidate, the default type is inferred. 如果指定了默认类型，并且推理无法选择候选类型，则推断默认类型。 A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter. 与现有类或接口声明合并的类或接口声明可能会为现有类型参数引入默认值。 A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default. 与现有类或接口声明合并的类或接口声明可以引入新的类型参数，只要它指定默认值即可。\n\n# keyof 运算符\n\n * keyof 运算符提取对象类型的键并生成对应的字符串和文本的联合。\n\ntype Point = { x: number; y: number };\ntype P = keyof Point;\n\n\n1\n2\n\n * 如果类型具有 string 或 number 索引签名，则 keyof 将改为返回这些类型\n\ntype Arrayish = { [n: number]: unknown };\ntype A = keyof Arrayish; // type A = number\n\ntype Mapish = { [k: string]: boolean };\ntype M = keyof Mapish; // type M = string | number\n\n\n1\n2\n3\n4\n5\n\n * 请注意，在此示例中， M 是 string | number — 这是因为 JavaScript 对象键总是强制到字符串，因此 obj[0] 始终与 obj["0"] 相同。\n\n# typeof 类型运算符\n\n * 在 JS 中，typeof 可以返回一个变量的类型\n\nconst str = \'Hello world\'\nconsole.log(typeof str) // string\n\n\n1\n2\n\n * TS 中加入了 typeof 运算符，可以使用 typeof 引用对应的变量或属性的类型\n\nconst s: string = \'Hello world\'\nconst citedType: typeof s = \'1\'\n\n\n1\n2\n\n * typeof 通常结合类型运算使用，对于基本类型来说作用不大\n\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype P = ReturnType<typeof f>; // f 是函数，typeof f 才是对应的类型\n\n\n1\n2\n3\n4\n\n * ts有意限制了typeof的作用，只有对变量与属性使用typeof才有效，对表达式使用会报错\n\n# 可以使用类型索引获取对象中的类型\n\ninterface eg {\n  name: string\n  age: number\n}\n\ntype nameType = eg[\'name\'] // 使用对应的键的类型可获取 string\ntype nameAndAgeType = eg[\'name\' | \'age\'] // 使用对应的键的类型可获取 string | number\n// type noneType = eg[\'111\'] // 不存在的属性类型将无法索引，会报错\nconst key = \'name\'\n// type nameType2 = eg[key] // 只能使用类型，不能使用变量\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 条件类型\n\n * 条件类型类似于 js 中的三目运算符\n\ninterface Animal {\n  live(): void\n}\n\ninterface Dog {\n  woof(): void\n}\n\ntype Example1 = Dog extends Animal ? number : string // number\ntype Example2 = RegExp extends Animal ? number : string // string\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 条件类型与泛型结合使用\n\ninterface IdLabel {\n  id: number\n}\n\ninterface nameLabel {\n  name: string\n}\n\n// 输入 id 返回包含number类型id属性的对象\nfunction createLabel(id: number): IdLabel\n// 输入 name 返回包含 string 类型name属性的对象\nfunction createLabel(name: string): nameLabel\n// 输入 可能为number 可能为string的对象时，两种返回都有可能\nfunction createLabel(idOrName: number | string): IdLabel | nameLabel\nfunction createLabel(idOrName: number | string): IdLabel | nameLabel {\n  throw \'unimplemented\' // 表示函数尚未实现\n}\n\n// 使用条件类型可以简化以上操作\ntype NameOrId<T extends number | string> = T extends number ? IdLabel : nameLabel\n\nfunction createLabel2<\n  T extends number | string // 保证 T 的类型为 string, number 或 string | number\n>(idOrName: T): NameOrId<T> {\n  throw \'unimplemented\'\n}\n\nconst var1 = createLabel("typescript"); // nameLabel\nconst var2 = createLabel(2)\nconst var3 = createLabel(Math.random() ? \'hello\' : 2024)\n\nconst v1 = createLabel2("javascript")\nconst v2 = createLabel2(2024)\nconst v3 = createLabel2(Math.random() ? \'yes\' : 0)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n * 条件类型约束\n\n// type MessageOf<T> = T[\'message\'] // 此时将会报错，因为T不一定有message名的类型\n// 加入条件类型约束将会保证T有message\ntype MessageOf<T extends { message: unknown }> = T[\'message\']\n\ninterface Email {\n  message: string\n}\n\ninterface Dog {\n  bark(): void\n}\n\ntype EmailMessageContents = MessageOf<Email> // string\n\n// 使用条件类型将可以处理边界值\ntype MessageOf2<T> = T extends { message: unknown } ? T[\'message\'] : never\ntype EmailMessageContents2 = MessageOf2<Email> // string\ntype DogMessageContent = MessageOf2<Dog> // never\n\n// 数组扁平化的例子\ntype Flatten<T> = T extends any[] ? T[number] : T // 如果有数组，则返回元素的类型，否则返回T的类型\ntype Str = Flatten<string[]> // string\ntype StrOrNumber = Flatten<(string | number)[]> // string | number\ntype onlyNumber = Flatten<number> // number\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * infer 关键字：在条件类型中推断\n\n// 重写 Flatten\ntype Flatten<T> = T extends Array<infer Item> ? Item : never\n\n// 使用 never 表示函数不应该接受任何参数\ntype GetReturnType<T extends (...args: never[]) => any> = T extends (...args: never[]) => infer Return ? Return : never\n\ntype Num = GetReturnType<() => number> // number\ntype Str2 = GetReturnType<(x: string) => string> // string\ntype Bools = GetReturnType<(a: boolean, b: boolean) => boolean[]> // boolean[]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 在学习infer的用法时，发现typescript对函数类型中never的判断可能存在一定问题\n\ntype judge1 = ((x: string) => number) extends ((...args: never[]) => any) ? true : false // true\ntype judge2 = ((x: string) => number) extends ((arg: never) => any) ? true : false // true\ntype judge3 = ((x: string) => number) extends ((arg: number) => any) ? true : false // false\ntype judge4 = string extends never ? true : false // false\n\n\n1\n2\n3\n4\n\n * 分配条件类型\n\n// 当传入的类型参数为联合类型时，他们会被 分配类型 \ntype ToArray<Type> = Type extends any ? Type[] : never;\n\n// 如果我们将联合类型传入 ToArray，则条件类型将应用于该联合类型的每个成员\ntype ToArray<Type> = Type extends any ? Type[] : never;\n \ntype StrArrOrNumArr = ToArray<string | number>; // string[] | number[]\n\n// 通常，分布性是所需的行为。要避免这种行为，可以用方括号括起 extends 关键字的两边\ntype ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;\n \n// \'StrOrNumArr\' 不再是一个联合类型\ntype StrOrNumArr = ToArrayNonDist<string | number>; // (string | number)[]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 使用 mapping 操作符可以去除可选和只读修饰符\n\n/**\n * @description 使用 mapping 可以去除可选与只读的命令\n */\ninterface initialType {\n  name?: string\n  readonly age: number\n  readonly [index: number]: string\n  [action: symbol]: () => void\n}\n\n// 使用类型别名复制原来的类型\ntype copiedType = {\n  [T in keyof initialType]: initialType[T]\n}\n\n// 使用类型别名去除可选属性的可选修饰符 name\ntype requiredType = {\n  [T in keyof initialType]-?: initialType[T]\n}\n\n// 使用类型别名去除只读修饰符\ntype modifiableType = {\n  -readonly [T in keyof initialType]: initialType[T]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 在 TypeScript 4.1 以上，可以使用 as 操作符处理映射类型\n\n/**\n * @description 使用 as 操作符来操作映射\n */\ntype Getters<T> = {\n  [Property in keyof T as `get${Capitalize<string & Property>}`]: () => T[Property]\n}\ninterface Person {\n  name: string\n  age: number\n  location: string\n}\n\ntype LazyPerson = Getters<Person>\n\n// 可以通过将属性名的类型设置为 never 来过滤一些属性\ntype RemoveKindField<T> = {\n  [Property in keyof T as Exclude<Property, "kind">]: T[Property]\n}\ninterface Circle {\n  kind: "circle";\n  radius: number;\n}\n\ntype KindlessCircle = RemoveKindField<Circle>;\n\n// 可以联合的类型不只是 string | numebr | symbol\ntype EventConfig<Events extends { kind: string }> = {\n  [E in Events as E["kind"]]: (event: E) => void;\n}\n\ntype SquareEvent = { kind: "square", x: number, y: number };\ntype CircleEvent = { kind: "circle", radius: number };\n\ntype Config = EventConfig<SquareEvent | CircleEvent>\n\n// 进阶类型操作\ntype ExtractPII<Type> = {\n  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;\n};\n \ntype DBFields = {\n  id: { format: "incrementing" };\n  name: { type: string; pii: true };\n};\n \ntype ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n# 模版字符串\n\n * 模版字符串的简单应用\n\n// 模版字符串可以进行简单的类型运算\ntype str1 = \'world\'\ntype str2 = `hello ${str1}` // "hello world"\n// 如果值不固定，将会计算所有组合\ntype str3 = \'lihua\' | \'xiaomei\'\ntype str4 = `i am ${str3}` // "i am lihua" | "i am xiaomei"\n// 多个变量同理\n\n// 结合模版字符串与keyof的例子\nconst passedObject = {\n  firstName: "Saoirse",\n  lastName: "Ronan",\n  age: 26,\n};\n\ntype PropEventSource<Type> = {\n  on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;\n};\n\ndeclare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;\n\nconst person = makeWatchedObject({\n  firstName: "Saoirse",\n  lastName: "Ronan",\n  age: 26\n});\n \nperson.on("firstNameChanged", () => {});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 进一步优化例子\n\n 1. 第一个参数中使用的文本被捕获为文本类型\n 2. 可以验证该文本类型是否处于泛型中有效属性的并集中\n 3. 可以使用索引访问在泛型的结构中查找已验证属性的类型\n 4. 然后，可以应用此类型化信息来确保回调函数的参数属于同一类型\n\ntype PropEventSource<Type> = {\n    on<Key extends string & keyof Type>\n        (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void): void;\n};\n \ndeclare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;\n \nconst person = makeWatchedObject({\n  firstName: "Saoirse",\n  lastName: "Ronan",\n  age: 26\n});\n \nperson.on("firstNameChanged", newName => {\n                                \n// (parameter) newName: string\n    console.log(`new name is ${newName.toUpperCase()}`);\n});\n \nperson.on("ageChanged", newAge => {              \n// (parameter) newAge: number\n    if (newAge < 0) {\n        console.warn("warning! negative age");\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 内部字符串操作\n\n 1. Uppercase 全大写\n 2. Lowercase 全小写\n 3. Capitalize 首字母大写\n 4. Uncapitalize 首字母小写',normalizedContent:'提示\n\n本文整理自 typescript 官方文档中的 handlebook，版本为 v5.4\n\n# 对象的类型\n\n * 对象的类型可以为匿名、类型别名、接口定义的\n\nfunction fn(options: {\n  childele: htmlelement\n  parentele: element\n  easing: (t: number) => number\n  duration: number | "auto"\n  callback?: () => void\n}): void {} // options 的类型是直接定义的，即匿名的\n\ntype fnoptions = { // 使用类型别名定义\n  childele: htmlelement\n  parentele: element\n  easing: (t: number) => number\n  duration: number | "auto"\n  callback?: () => void\n}\n\ninterface fnoptionapi { // 使用接口定义\n  childele: htmlelement\n  parentele: element\n  easing: (t: number) => number\n  duration: number | "auto"\n  callback?: () => void\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 类型中可以加入可选、只读、索引签名\n   * 可选\n\ntype person = {\n  name: string\n  age?: boolean // 实际上相当于设置 age 的属性为 boolean | undefined\n}\n\n\n1\n2\n3\n4\n\n * 只读\n\ntype person = {\n  name: string\n  readonly age: boolean // 在属性名前面加上 readonly 标志符将会使属性变为只读的\n}\nconst person: person = {\n  name: \'joker\',\n  age: 20 // age 属性不可更改，只允许读取\n}\nconsole.log(person.age) // 20\nperson.age = 21 // setter 被禁用了，此时将会报错\n\n/**\n * @description ts 判断类型是否兼容时不会观察 readonly，可以通过这个特性将 readonly 变为可以修改的\n */\ninterface person {\n  name: string;\n  age: number;\n}\n \ninterface readonlyperson {\n  readonly name: string;\n  readonly age: number;\n}\n \nlet writableperson: person = {\n  name: "person mcpersonface",\n  age: 42,\n};\n \n// works\nlet readonlyperson: readonlyperson = writableperson;\n \nconsole.log(readonlyperson.age); // prints \'42\'\nwritableperson.age++;\nconsole.log(readonlyperson.age); // prints \'43\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n * 类型修饰\n\n/**\n * @description 类型索引可以帮助我们在不知道确切属性名的情况下对类型作出一定限制\n */\n// 例如当前并不知道数组哪些位置上有值，但是知道时数组，并且对应的值都为\ninterface stringarray {\n  [index: number]: string\n}\n\nconst arr: stringarray = [\'1\', \'2\', \'3\']\n// 索引签名属性允许 string number symbol 模版字符串 或者以上四种的组合\ninterface person {\n  name: string\n  age: number\n  [action: number | symbol]: () => void\n}\n\nconst xiaoming: person = { name: \'xiaoming\', age: 20 }\nconst fnsymbol = symbol(\'小明会跑\')\nxiaoming[fnsymbol] = () => { console.log(\'小明开始跑了\') }\nxiaoming[fnsymbol]()\n\n// 索引签名可以设置 string | number | symbol 但是如果之前已经声明了相关类型，需要与之兼容\n\ninterface dog {\n  name: string\n  age: number\n  [action: string]: string | number // 只有这样才是与上面两种兼容的，或者将属性名的类型换成 number | symbol，这样才可以赋其他值\n}\n\n// 在索引签名中，也可以加入 readonly，只允许初始化时赋值，之后不可修改\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n * 使用 mapping 操作符可以去除可选和只读修饰符\n\n/**\n * @description 使用 mapping 可以去除可选与只读的命令\n */\ninterface initialtype {\n  name?: string\n  readonly age: number\n  readonly [index: number]: string\n  [action: symbol]: () => void\n}\n\n// 使用类型别名复制原来的类型\ntype copiedtype = {\n  [t in keyof initialtype]: initialtype[t]\n}\n\n// 使用类型别名去除可选属性的可选修饰符 name\ntype requiredtype = {\n  [t in keyof initialtype]-?: initialtype[t]\n}\n\n// 使用类型别名去除只读修饰符\ntype modifiabletype = {\n  -readonly [t in keyof initialtype]: initialtype[t]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 在 typescript 4.1 以上，可以使用 as 操作符处理映射类型\n\n/**\n * @description 使用 as 操作符来操作映射\n */\ntype getters<t> = {\n  [property in keyof t as `get${capitalize<string & property>}`]: () => t[property]\n}\ninterface person {\n  name: string\n  age: number\n  location: string\n}\n\ntype lazyperson = getters<person>\n\n// 可以通过将属性名的类型设置为 never 来过滤一些属性\ntype removekindfield<t> = {\n  [property in keyof t as exclude<property, "kind">]: t[property]\n}\ninterface circle {\n  kind: "circle";\n  radius: number;\n}\n\ntype kindlesscircle = removekindfield<circle>;\n\n// 可以联合的类型不只是 string | numebr | symbol\ntype eventconfig<events extends { kind: string }> = {\n  [e in events as e["kind"]]: (event: e) => void;\n}\n\ntype squareevent = { kind: "square", x: number, y: number };\ntype circleevent = { kind: "circle", radius: number };\n\ntype config = eventconfig<squareevent | circleevent>\n\n// 进阶类型操作\ntype extractpii<type> = {\n  [property in keyof type]: type[property] extends { pii: true } ? true : false;\n};\n \ntype dbfields = {\n  id: { format: "incrementing" };\n  name: { type: string; pii: true };\n};\n \ntype objectsneedinggdprdeletion = extractpii<dbfields>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * interface 与 type alias 都可以扩展类型，但是处理冲突的方式不一样\n\ninterface basicaddress {\n  name?: string;\n  street: string;\n  city: string;\n  country: string;\n  postalcode: string;\n}\n \ninterface addresswithunit extends basicaddress {\n  unit: string;\n}\n\ninterface colorful1 {\n  color: string;\n}\n \ninterface circle1 {\n  radius: number;\n}\n \ninterface colorfulcircle extends colorful1, circle1 {}\n\ntype colorfulcircle2 = colorful1 & circle1\n \nconst cc: colorfulcircle = {\n  color: "red",\n  radius: 42,\n};\n\nconst cc2: colorfulcircle = {\n  color: "red",\n  radius: 42,\n};\n\n// 同一属性类型冲突\ninterface circlearea {\n  kind: \'circle\'\n  radius: number\n  getarea: (radius: number) => number\n}\n\ninterface rectarea {\n  kind: \'rect\'\n  width: number\n  getarea: (width: number) => number\n}\n\ninterface newarea extends circlearea, rectarea {} // 冲突后提示不能\ntype newarea2  = circlearea & rectarea // 变为 never，但是不会报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n * 当能使用泛型时，优先使用泛型，而不是函数重载\n * 数组和只读数组的定义就使用了泛型 array 和 readonlyarray\n   * array 类型的值可以赋值给 readonlyarray 类型，反之则无法进行\n * 元组类型定义了每个位置上的值的类型\n   * 元组的可选操作符只能放在最后一位\n   * 元组可以使用展开运算符，将对应的数组和元组类型加入到里面，例如 type stringnumberbooleans = [string, number, ...boolean[]]\n   * 假设定义了某个元组并设置为 as const 将其类型设置为只读的元组是类似的\n\n# 类型体操\n\n# 泛型\n\nfunction identity<t>(arg: t): t {\n  return arg\n}\n\nfunction numberidentity (arg: number): number {\n  return arg\n}\n\ninterface genericidentityfn<t> {\n  (arg: t): t\n}\n\ntype identityfn<t> = (arg: t) => t\n\nconst myidentity: <t>(arg: t) => t = identity // 箭头函数形式\nconst myidentity2: { <t>(arg: t): t } = identity // 对象形式\nconst knownidentity: genericidentityfn<number> = identity // 加入 <number> 后，对应函数传入的参数的类型就已知了，不再是泛型了\n\n// 在调用泛型接口和类型别名时，必须传入对应的参数\nconst numberidentity1: genericidentityfn = identity\nconst numberidentity4: identityfn = identity\n\nconst numberidentity2: genericidentityfn<string> = identity\nconst numberidentity3: genericidentityfn<string> = numberidentity // 此时类型不匹配\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 类也有泛型的概念\n\nclass genericnumber<numtype> {\n  zerovalue: numtype;\n  add: (x: numtype, y: numtype) => numtype;\n}\n \nlet mygenericnumber = new genericnumber<number>();\nmygenericnumber.zerovalue = 0;\nmygenericnumber.add = function (x, y) {\n  return x + y;\n};\n\nlet stringnumeric = new genericnumber<string>();\nstringnumeric.zerovalue = "";\nstringnumeric.add = function (x, y) {\n  return x + y;\n};\n \nconsole.log(stringnumeric.add(stringnumeric.zerovalue, "test"));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * 泛型类仅在实例端有泛型，在静态端无法应用泛型\n\n * 通用约束\n\ninterface lengthwise {\n  length: number\n}\n\n\n1\n2\n3\n\n * 在泛型约束中也可以加入泛型\n\nfunction getproperty<type, key extends keyof type>(obj: type, key: key) {\n  return obj[key]\n}\n\n\n1\n2\n3\n\n * 通过构造函数来创建类的实例的过程中，必须通过类的构造函数来引用类类型\n\nclass beekeeper {\n  hasmask: boolean = true;\n}\n \nclass zookeeper {\n  nametag: string = "mikle";\n}\n \nclass animal {\n  numlegs: number = 4;\n}\n \nclass bee extends animal {\n  numlegs = 6;\n  keeper: beekeeper = new beekeeper();\n}\n \nclass lion extends animal {\n  keeper: zookeeper = new zookeeper();\n}\n \nfunction createinstance<a extends animal>(c: new () => a): a {\n  return new c();\n}\n \ncreateinstance(lion).keeper.nametag;\ncreateinstance(bee).keeper.hasmask;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 使用通用参数默认值可以简化函数重载的描述\n\ndeclare function create(): container<htmldivelement, htmldivelement[]>;\ndeclare function create<t extends htmlelement>(element: t): container<t, t[]>;\ndeclare function create<t extends htmlelement, u extends htmlelement>(\n  element: t,\n  children: u[]\n): container<t, u[]>;\n\n\n1\n2\n3\n4\n5\n6\n\n\ndeclare function create<t extends htmlelement = htmldivelement, u = t[]>(\n  element?: t,\n  children?: u\n): container<t, u>;\n \nconst div = create();\nconst p = create(new htmlparagraphelement());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> a generic parameter default follows the following rules: 泛型参数默认遵循以下规则：\n\n> a type parameter is deemed optional if it has a default. 如果类型参数具有默认值，则该参数被视为可选参数。\n\n> required type parameters must not follow optional type parameters. 必需的类型参数不得遵循可选的类型参数。\n\n> default types for a type parameter must satisfy the constraint for the type parameter, if it exists. 类型参数的默认类型必须满足类型参数的约束（如果存在）。\n\n> when specifying type arguments, you are only required to specify type arguments for the required type parameters. unspecified type parameters will resolve to their default types. 指定类型参数时，只需为所需的类型参数指定类型参数。未指定的类型参数将解析为其默认类型。\n\n> if a default type is specified and inference cannot choose a candidate, the default type is inferred. 如果指定了默认类型，并且推理无法选择候选类型，则推断默认类型。 a class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter. 与现有类或接口声明合并的类或接口声明可能会为现有类型参数引入默认值。 a class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default. 与现有类或接口声明合并的类或接口声明可以引入新的类型参数，只要它指定默认值即可。\n\n# keyof 运算符\n\n * keyof 运算符提取对象类型的键并生成对应的字符串和文本的联合。\n\ntype point = { x: number; y: number };\ntype p = keyof point;\n\n\n1\n2\n\n * 如果类型具有 string 或 number 索引签名，则 keyof 将改为返回这些类型\n\ntype arrayish = { [n: number]: unknown };\ntype a = keyof arrayish; // type a = number\n\ntype mapish = { [k: string]: boolean };\ntype m = keyof mapish; // type m = string | number\n\n\n1\n2\n3\n4\n5\n\n * 请注意，在此示例中， m 是 string | number — 这是因为 javascript 对象键总是强制到字符串，因此 obj[0] 始终与 obj["0"] 相同。\n\n# typeof 类型运算符\n\n * 在 js 中，typeof 可以返回一个变量的类型\n\nconst str = \'hello world\'\nconsole.log(typeof str) // string\n\n\n1\n2\n\n * ts 中加入了 typeof 运算符，可以使用 typeof 引用对应的变量或属性的类型\n\nconst s: string = \'hello world\'\nconst citedtype: typeof s = \'1\'\n\n\n1\n2\n\n * typeof 通常结合类型运算使用，对于基本类型来说作用不大\n\nfunction f() {\n  return { x: 10, y: 3 };\n}\ntype p = returntype<typeof f>; // f 是函数，typeof f 才是对应的类型\n\n\n1\n2\n3\n4\n\n * ts有意限制了typeof的作用，只有对变量与属性使用typeof才有效，对表达式使用会报错\n\n# 可以使用类型索引获取对象中的类型\n\ninterface eg {\n  name: string\n  age: number\n}\n\ntype nametype = eg[\'name\'] // 使用对应的键的类型可获取 string\ntype nameandagetype = eg[\'name\' | \'age\'] // 使用对应的键的类型可获取 string | number\n// type nonetype = eg[\'111\'] // 不存在的属性类型将无法索引，会报错\nconst key = \'name\'\n// type nametype2 = eg[key] // 只能使用类型，不能使用变量\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 条件类型\n\n * 条件类型类似于 js 中的三目运算符\n\ninterface animal {\n  live(): void\n}\n\ninterface dog {\n  woof(): void\n}\n\ntype example1 = dog extends animal ? number : string // number\ntype example2 = regexp extends animal ? number : string // string\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 条件类型与泛型结合使用\n\ninterface idlabel {\n  id: number\n}\n\ninterface namelabel {\n  name: string\n}\n\n// 输入 id 返回包含number类型id属性的对象\nfunction createlabel(id: number): idlabel\n// 输入 name 返回包含 string 类型name属性的对象\nfunction createlabel(name: string): namelabel\n// 输入 可能为number 可能为string的对象时，两种返回都有可能\nfunction createlabel(idorname: number | string): idlabel | namelabel\nfunction createlabel(idorname: number | string): idlabel | namelabel {\n  throw \'unimplemented\' // 表示函数尚未实现\n}\n\n// 使用条件类型可以简化以上操作\ntype nameorid<t extends number | string> = t extends number ? idlabel : namelabel\n\nfunction createlabel2<\n  t extends number | string // 保证 t 的类型为 string, number 或 string | number\n>(idorname: t): nameorid<t> {\n  throw \'unimplemented\'\n}\n\nconst var1 = createlabel("typescript"); // namelabel\nconst var2 = createlabel(2)\nconst var3 = createlabel(math.random() ? \'hello\' : 2024)\n\nconst v1 = createlabel2("javascript")\nconst v2 = createlabel2(2024)\nconst v3 = createlabel2(math.random() ? \'yes\' : 0)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n * 条件类型约束\n\n// type messageof<t> = t[\'message\'] // 此时将会报错，因为t不一定有message名的类型\n// 加入条件类型约束将会保证t有message\ntype messageof<t extends { message: unknown }> = t[\'message\']\n\ninterface email {\n  message: string\n}\n\ninterface dog {\n  bark(): void\n}\n\ntype emailmessagecontents = messageof<email> // string\n\n// 使用条件类型将可以处理边界值\ntype messageof2<t> = t extends { message: unknown } ? t[\'message\'] : never\ntype emailmessagecontents2 = messageof2<email> // string\ntype dogmessagecontent = messageof2<dog> // never\n\n// 数组扁平化的例子\ntype flatten<t> = t extends any[] ? t[number] : t // 如果有数组，则返回元素的类型，否则返回t的类型\ntype str = flatten<string[]> // string\ntype strornumber = flatten<(string | number)[]> // string | number\ntype onlynumber = flatten<number> // number\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * infer 关键字：在条件类型中推断\n\n// 重写 flatten\ntype flatten<t> = t extends array<infer item> ? item : never\n\n// 使用 never 表示函数不应该接受任何参数\ntype getreturntype<t extends (...args: never[]) => any> = t extends (...args: never[]) => infer return ? return : never\n\ntype num = getreturntype<() => number> // number\ntype str2 = getreturntype<(x: string) => string> // string\ntype bools = getreturntype<(a: boolean, b: boolean) => boolean[]> // boolean[]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 在学习infer的用法时，发现typescript对函数类型中never的判断可能存在一定问题\n\ntype judge1 = ((x: string) => number) extends ((...args: never[]) => any) ? true : false // true\ntype judge2 = ((x: string) => number) extends ((arg: never) => any) ? true : false // true\ntype judge3 = ((x: string) => number) extends ((arg: number) => any) ? true : false // false\ntype judge4 = string extends never ? true : false // false\n\n\n1\n2\n3\n4\n\n * 分配条件类型\n\n// 当传入的类型参数为联合类型时，他们会被 分配类型 \ntype toarray<type> = type extends any ? type[] : never;\n\n// 如果我们将联合类型传入 toarray，则条件类型将应用于该联合类型的每个成员\ntype toarray<type> = type extends any ? type[] : never;\n \ntype strarrornumarr = toarray<string | number>; // string[] | number[]\n\n// 通常，分布性是所需的行为。要避免这种行为，可以用方括号括起 extends 关键字的两边\ntype toarraynondist<type> = [type] extends [any] ? type[] : never;\n \n// \'strornumarr\' 不再是一个联合类型\ntype strornumarr = toarraynondist<string | number>; // (string | number)[]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 使用 mapping 操作符可以去除可选和只读修饰符\n\n/**\n * @description 使用 mapping 可以去除可选与只读的命令\n */\ninterface initialtype {\n  name?: string\n  readonly age: number\n  readonly [index: number]: string\n  [action: symbol]: () => void\n}\n\n// 使用类型别名复制原来的类型\ntype copiedtype = {\n  [t in keyof initialtype]: initialtype[t]\n}\n\n// 使用类型别名去除可选属性的可选修饰符 name\ntype requiredtype = {\n  [t in keyof initialtype]-?: initialtype[t]\n}\n\n// 使用类型别名去除只读修饰符\ntype modifiabletype = {\n  -readonly [t in keyof initialtype]: initialtype[t]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 在 typescript 4.1 以上，可以使用 as 操作符处理映射类型\n\n/**\n * @description 使用 as 操作符来操作映射\n */\ntype getters<t> = {\n  [property in keyof t as `get${capitalize<string & property>}`]: () => t[property]\n}\ninterface person {\n  name: string\n  age: number\n  location: string\n}\n\ntype lazyperson = getters<person>\n\n// 可以通过将属性名的类型设置为 never 来过滤一些属性\ntype removekindfield<t> = {\n  [property in keyof t as exclude<property, "kind">]: t[property]\n}\ninterface circle {\n  kind: "circle";\n  radius: number;\n}\n\ntype kindlesscircle = removekindfield<circle>;\n\n// 可以联合的类型不只是 string | numebr | symbol\ntype eventconfig<events extends { kind: string }> = {\n  [e in events as e["kind"]]: (event: e) => void;\n}\n\ntype squareevent = { kind: "square", x: number, y: number };\ntype circleevent = { kind: "circle", radius: number };\n\ntype config = eventconfig<squareevent | circleevent>\n\n// 进阶类型操作\ntype extractpii<type> = {\n  [property in keyof type]: type[property] extends { pii: true } ? true : false;\n};\n \ntype dbfields = {\n  id: { format: "incrementing" };\n  name: { type: string; pii: true };\n};\n \ntype objectsneedinggdprdeletion = extractpii<dbfields>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n# 模版字符串\n\n * 模版字符串的简单应用\n\n// 模版字符串可以进行简单的类型运算\ntype str1 = \'world\'\ntype str2 = `hello ${str1}` // "hello world"\n// 如果值不固定，将会计算所有组合\ntype str3 = \'lihua\' | \'xiaomei\'\ntype str4 = `i am ${str3}` // "i am lihua" | "i am xiaomei"\n// 多个变量同理\n\n// 结合模版字符串与keyof的例子\nconst passedobject = {\n  firstname: "saoirse",\n  lastname: "ronan",\n  age: 26,\n};\n\ntype propeventsource<type> = {\n  on(eventname: `${string & keyof type}changed`, callback: (newvalue: any) => void): void;\n};\n\ndeclare function makewatchedobject<type>(obj: type): type & propeventsource<type>;\n\nconst person = makewatchedobject({\n  firstname: "saoirse",\n  lastname: "ronan",\n  age: 26\n});\n \nperson.on("firstnamechanged", () => {});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 进一步优化例子\n\n 1. 第一个参数中使用的文本被捕获为文本类型\n 2. 可以验证该文本类型是否处于泛型中有效属性的并集中\n 3. 可以使用索引访问在泛型的结构中查找已验证属性的类型\n 4. 然后，可以应用此类型化信息来确保回调函数的参数属于同一类型\n\ntype propeventsource<type> = {\n    on<key extends string & keyof type>\n        (eventname: `${key}changed`, callback: (newvalue: type[key]) => void): void;\n};\n \ndeclare function makewatchedobject<type>(obj: type): type & propeventsource<type>;\n \nconst person = makewatchedobject({\n  firstname: "saoirse",\n  lastname: "ronan",\n  age: 26\n});\n \nperson.on("firstnamechanged", newname => {\n                                \n// (parameter) newname: string\n    console.log(`new name is ${newname.touppercase()}`);\n});\n \nperson.on("agechanged", newage => {              \n// (parameter) newage: number\n    if (newage < 0) {\n        console.warn("warning! negative age");\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 内部字符串操作\n\n 1. uppercase 全大写\n 2. lowercase 全小写\n 3. capitalize 首字母大写\n 4. uncapitalize 首字母小写',charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"sequelize学习",frontmatter:{title:"sequelize学习",date:"2024-06-14T13:56:45.000Z",permalink:"/pages/0a08d6/",categories:["技术","NodeJS"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/03.NodeJS/01.sequelize%E5%AD%A6%E4%B9%A0.html",relativePath:"03.技术/03.NodeJS/01.sequelize学习.md",key:"v-207166ad",path:"/pages/0a08d6/",headers:[{level:4,title:"学习目标",slug:"学习目标",normalizedTitle:"学习目标",charIndex:72},{level:4,title:"在数据库中定义模型",slug:"在数据库中定义模型",normalizedTitle:"在数据库中定义模型",charIndex:113},{level:4,title:"根据模型创建实例，向表中加入新数据",slug:"根据模型创建实例-向表中加入新数据",normalizedTitle:"根据模型创建实例，向表中加入新数据",charIndex:1293},{level:4,title:"基础查询",slug:"基础查询",normalizedTitle:"基础查询",charIndex:1903},{level:5,title:"INSERT",slug:"insert",normalizedTitle:"insert",charIndex:1911},{level:5,title:"SELECT",slug:"select",normalizedTitle:"select",charIndex:2206},{level:5,title:"UPDATE",slug:"update",normalizedTitle:"update",charIndex:2894},{level:5,title:"DELETE",slug:"delete",normalizedTitle:"delete",charIndex:3072},{level:5,title:"批量创建",slug:"批量创建",normalizedTitle:"批量创建",charIndex:3188},{level:5,title:"排序",slug:"排序",normalizedTitle:"排序",charIndex:3716},{level:5,title:"分组",slug:"分组",normalizedTitle:"分组",charIndex:6125},{level:5,title:"限制与分页",slug:"限制与分页",normalizedTitle:"限制与分页",charIndex:6229},{level:5,title:"实用方法",slug:"实用方法",normalizedTitle:"实用方法",charIndex:6287},{level:4,title:"模型查找器",slug:"模型查找器",normalizedTitle:"模型查找器",charIndex:6868}],headersStr:"学习目标 在数据库中定义模型 根据模型创建实例，向表中加入新数据 基础查询 INSERT SELECT UPDATE DELETE 批量创建 排序 分组 限制与分页 实用方法 模型查找器",content:"提示\n\n在写 egg.js 项目时发现自己对于 sequelize 还不太熟悉，于是打算看着官方文档学习一下 Sequelize官方文档\n\n# 学习目标\n\n学习 sequelize 主要为了使用，因此主要关注应用方面。\n\n# 在数据库中定义模型\n\n * sequelize.define(modelName, attributes, options) 调用实例的 define 方法可以将对应的模型加入到 sequelize 中，绑定为 sequelize.models[modelName]。\n\nconst { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = new Sequelize('sqlite::memory:');\n\nconst User = sequelize.define('User', {\n  // 在这里定义模型属性\n  firstName: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  lastName: {\n    type: DataTypes.STRING\n    // allowNull 默认为 true\n  }\n}, {\n  // 这是其他模型参数\n});\n\n// `sequelize.define` 会返回模型\nconsole.log(User === sequelize.models.User); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 首先继承 Model ，并调用父类的 init 方法来定义\n\nconst { Sequelize, DataTypes, Model } = require('sequelize');\nconst sequelize = new Sequelize('sqlite::memory:');\n\nclass User extends Model {}\n\nUser.init({\n  // 在这里定义模型属性\n  firstName: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  lastName: {\n    type: DataTypes.STRING\n    // allowNull 默认为 true\n  }\n}, {\n  // 这是其他模型参数\n  sequelize, // 我们需要传递连接实例\n  modelName: 'User' // 我们需要选择模型名称\n});\n\n// 定义的模型是类本身\nconsole.log(User === sequelize.models.User); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 两种方法实际上是共用一个方法，是等效的\n\n# 根据模型创建实例，向表中加入新数据\n\n * 完整流程 build + save\n   * build 是少数非异步的方法，大部分方法都是异步的\n\nconst jane = User.build({ name: \"Jane\" });\nconsole.log(jane instanceof User); // true\nconsole.log(jane.name); // \"Jane\"\n\nawait jane.save();\nconsole.log('Jane 已保存到数据库!');\n\n\n1\n2\n3\n4\n5\n6\n\n * 快捷流程 create\n\nconst jane = await User.create({ name: \"Jane\" });\n// Jane 现在存在于数据库中！\nconsole.log(jane instanceof User); // true\nconsole.log(jane.name); // \"Jane\"\n\n\n1\n2\n3\n4\n\n * 更新实例：create后使用set更新实例，之后进行保存\n * 删除实例：create后使用destroy销毁实例\n * 重载实例：create后使用reload可以获取数据库中的最新记录\n * 保存实例：保存时可以指定fields来指定仅保留部分字段\n * 使用 increment 和 decrement 方法可以解决递增和递减时的并发问题\n\n# 基础查询\n\n# INSERT\n\n * 使用 create 方法即可插入新数据\n\nconst user = await User.create({\n  username: 'alice123',\n  isAdmin: true\n}, { fields: ['username'] }); // 在这里可以读取哪些字段，其他的调用为默认值，但是实际作用应该不大\n// 假设 isAdmin 的默认值为 false\nconsole.log(user.username); // 'alice123'\nconsole.log(user.isAdmin); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# SELECT\n\n * 使用 findAll() 查询一个表中的所有字段，等价于 SELECT * FROM TABLE_NAME\n * 加入 attributes 属性，可以查询表中的对应字段，attributes 一定要为数组，等价于 SELECT attribute1, attribute2, ... FROM TABLE_NAME\n   * 在数组中嵌套数组表示重命名\n\nModel.findAll({\n  attributes: ['foo', ['bar', 'baz'], 'qux']\n});\n\n\n1\n2\n3\n\n\nSELECT foo, bar AS baz, qux FROM ...\n\n\n1\n\n * attributes 中可以加入聚合属性，聚合属性必须要有对应的别名\n\nModel.findAll({\n  attributes: [\n    'foo',\n    [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats'],\n    'bar'\n  ]\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nSELECT foo, COUNT(hats) AS n_hats, bar FROM ...\n\n\n1\n\n\n * 只想添加聚合时，可以使用 include 属性\n\n * 想要排除某些字段时，可以使用 exclude 属性\n\n * where 可以传递查询条件，默认为相等，为 [Op.eq]\n\n * 除此之外，sequelize的Op属性中还有非常多的操作符，具体使用时可以关注模型查询（基础）\n\n# UPDATE\n\n第一个参数传递要修改的值，第二个参数可以传递一些选项，比如 where 和 transaction\n\n// 将所有没有姓氏的人更改为 \"Doe\"\nawait User.update({ lastName: \"Doe\" }, {\n  where: {\n    lastName: null\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n# DELETE\n\n * 根据条件删除可以传入 where\n * 删除所有条目可以使用 truncate\n\n// 截断表格\nawait User.destroy({\n  truncate: true\n});\n\n\n1\n2\n3\n4\n\n\n# 批量创建\n\nModel.bulkCreate 允许在一次查询中创建多个记录，可以在 bulkCreate 方法中添加参数 validate 来为每个对象进行检验，但是只有所有都通过之后才会创建成功\n\nconst Foo = sequelize.define('foo', {\n  name: {\n    type: DataTypes.TEXT,\n    validate: {\n      len: [4, 6]\n    }\n  }\n});\n\n// 这不会引发错误,两个实例都将被创建\nawait Foo.bulkCreate([\n  { name: 'abc123' },\n  { name: 'name too long' }\n]);\n\n// 这将引发错误,不会创建任何内容\nawait Foo.bulkCreate([\n  { name: 'abc123' },\n  { name: 'name too long' }\n], { validate: true });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 同时 bulkCreate 也可以加入 fields 参数\n\n# 排序\n\n向查询中添加 order 可以选择对应的排序方式\n\nSubtask.findAll({\n  order: [\n    // 将转义 title 并针对有效方向列表进行降序排列\n    ['title', 'DESC'],\n\n    // 将按最大年龄进行升序排序\n    sequelize.fn('max', sequelize.col('age')),\n\n    // 将按最大年龄进行降序排序\n    [sequelize.fn('max', sequelize.col('age')), 'DESC'],\n\n    // 将按 otherfunction(`col1`, 12, 'lalala') 进行降序排序\n    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],\n\n    // 将使用模型名称作为关联名称按关联模型的 createdAt 排序.\n    [Task, 'createdAt', 'DESC'],\n\n    // 将使用模型名称作为关联名称通过关联模型的 createdAt 排序.\n    [Task, Project, 'createdAt', 'DESC'],\n\n    // 将使用关联名称按关联模型的 createdAt 排序.\n    ['Task', 'createdAt', 'DESC'],\n\n    // 将使用关联的名称按嵌套的关联模型的 createdAt 排序.\n    ['Task', 'Project', 'createdAt', 'DESC'],\n\n    // 将使用关联对象按关联模型的 createdAt 排序. (首选方法)\n    [Subtask.associations.Task, 'createdAt', 'DESC'],\n\n    // 将使用关联对象按嵌套关联模型的 createdAt 排序. (首选方法)\n    [Subtask.associations.Task, Task.associations.Project, 'createdAt', 'DESC'],\n\n    // 将使用简单的关联对象按关联模型的 createdAt 排序.\n    [{model: Task, as: 'Task'}, 'createdAt', 'DESC'],\n\n    // 将由嵌套关联模型的 createdAt 简单关联对象排序.\n    [{model: Task, as: 'Task'}, {model: Project, as: 'Project'}, 'createdAt', 'DESC']\n  ],\n\n  // 将按最大年龄降序排列\n  order: sequelize.literal('max(age) DESC'),\n\n  // 如果忽略方向,则默认升序,将按最大年龄升序排序\n  order: sequelize.fn('max', sequelize.col('age')),\n\n  // 如果省略方向,则默认升序, 将按年龄升序排列\n  order: sequelize.col('age'),\n\n  // 将根据方言随机排序(但不是 fn('RAND') 或 fn('RANDOM'))\n  order: sequelize.random()\n});\n\nFoo.findOne({\n  order: [\n    // 将返回 `name`\n    ['name'],\n    // 将返回 `username` DESC\n    ['username', 'DESC'],\n    // 将返回 max(`age`)\n    sequelize.fn('max', sequelize.col('age')),\n    // 将返回 max(`age`) DESC\n    [sequelize.fn('max', sequelize.col('age')), 'DESC'],\n    // 将返回 otherfunction(`col1`, 12, 'lalala') DESC\n    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],\n    // 将返回 otherfunction(awesomefunction(`col`)) DESC, 这种嵌套可能是无限的!\n    [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC']\n  ]\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n> 回顾一下,order 数组的元素可以如下： 一个字符串 (它将被自动引用), 一个数组, 其第一个元素将被引用,第二个将被逐字追加, 一个具有 raw 字段的对象:raw 内容将不加引用地逐字添加,其他所有内容都将被忽略,如果未设置 raw,查询将失败 调用 Sequelize.fn (这将在 SQL 中生成一个函数调用), 调用 Sequelize.col (这将引用列名),\n\n# 分组\n\n分组和排序的语法几乎一样，但是没有升序和降序之别\n\n注意\n\n你还可以将字符串直接传递给 group,该字符串将直接(普通)包含在生成的 SQL 中. 请谨慎使用,请勿与用户生成的内容一起使用.\n\n# 限制与分页\n\n在查询中，加入 limit 可以限制查询的最多数目，加入 offset 可以声明开始查询的条目\n\n# 实用方法\n\n * count 计算数据库中元素出现的数目\n\nconsole.log(`这有 ${await Project.count()} 个项目`);\n\nconst amount = await Project.count({\n  where: {\n    id: {\n      [Op.gt]: 25\n    }\n  }\n});\nconsole.log(`这有 ${amount} 个项目 id 大于 25`);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * max min sum\n\nawait User.max('age'); // 40\nawait User.max('age', { where: { age: { [Op.lt]: 20 } } }); // 10\nawait User.min('age'); // 5\nawait User.min('age', { where: { age: { [Op.gt]: 5 } } }); // 10\nawait User.sum('age'); // 55\nawait User.sum('age', { where: { age: { [Op.gt]: 5 } } }); // 50\n\n\n1\n2\n3\n4\n5\n6\n\n * increment,decrement （前面已有）\n\n# 模型查找器\n\n * findAll 查询所有条目\n * findByPk 根据主键进行查找\n * findOne 查找满足条件的第一个条目\n * findOrCreate 除非找到一个满足查询参数的结果,否则方法 findOrCreate 将在表中创建一个条目. 在这两种情况下,它将返回一个实例(找到的实例或创建的实例)和一个布尔值,指示该实例是已创建还是已经存在.\n\n提示\n\n使用 where 参数来查找条目,而使用 defaults 参数来定义必须创建的内容. 如果 defaults 不包含每一列的值,则 Sequelize 将采用 where 的值(如果存在). 假设我们有一个空的数据库,该数据库具有一个 User 模型,该模型具有一个 username 和一个 job.\n\nconst [user, created] = await User.findOrCreate({\n  where: { username: 'sdepold' },\n  defaults: {\n    job: 'Technical Lead JavaScript'\n  }\n});\nconsole.log(user.username); // 'sdepold'\nconsole.log(user.job); // 这可能是也可能不是 'Technical Lead JavaScript'\nconsole.log(created); // 指示此实例是否刚刚创建的布尔值\nif (created) {\n  console.log(user.job); // 这里肯定是 'Technical Lead JavaScript'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * findAndCountAll 结合了 findAll 和 count 的便捷方法. 在处理与分页有关的查询时非常有用,在分页中,你想检索带有 limit 和 offset 的数据,但又需要知道与查询匹配的记录总数.\n\n提示\n\n当提供了 group 时, findAndCountAll 方法返回一个具有两个属性的对象：\n\ncount - 一个数组对象 - 包含每组中的合计和预设属性 rows - 一个数组对象 - 获得的记录\n\n提示\n\n至此，已经基本学习了 sequelize 的基本语法，剩下的内容更适合阅读学习，只有遇到场景时才需要查阅。",normalizedContent:"提示\n\n在写 egg.js 项目时发现自己对于 sequelize 还不太熟悉，于是打算看着官方文档学习一下 sequelize官方文档\n\n# 学习目标\n\n学习 sequelize 主要为了使用，因此主要关注应用方面。\n\n# 在数据库中定义模型\n\n * sequelize.define(modelname, attributes, options) 调用实例的 define 方法可以将对应的模型加入到 sequelize 中，绑定为 sequelize.models[modelname]。\n\nconst { sequelize, datatypes } = require('sequelize');\nconst sequelize = new sequelize('sqlite::memory:');\n\nconst user = sequelize.define('user', {\n  // 在这里定义模型属性\n  firstname: {\n    type: datatypes.string,\n    allownull: false\n  },\n  lastname: {\n    type: datatypes.string\n    // allownull 默认为 true\n  }\n}, {\n  // 这是其他模型参数\n});\n\n// `sequelize.define` 会返回模型\nconsole.log(user === sequelize.models.user); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 首先继承 model ，并调用父类的 init 方法来定义\n\nconst { sequelize, datatypes, model } = require('sequelize');\nconst sequelize = new sequelize('sqlite::memory:');\n\nclass user extends model {}\n\nuser.init({\n  // 在这里定义模型属性\n  firstname: {\n    type: datatypes.string,\n    allownull: false\n  },\n  lastname: {\n    type: datatypes.string\n    // allownull 默认为 true\n  }\n}, {\n  // 这是其他模型参数\n  sequelize, // 我们需要传递连接实例\n  modelname: 'user' // 我们需要选择模型名称\n});\n\n// 定义的模型是类本身\nconsole.log(user === sequelize.models.user); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 两种方法实际上是共用一个方法，是等效的\n\n# 根据模型创建实例，向表中加入新数据\n\n * 完整流程 build + save\n   * build 是少数非异步的方法，大部分方法都是异步的\n\nconst jane = user.build({ name: \"jane\" });\nconsole.log(jane instanceof user); // true\nconsole.log(jane.name); // \"jane\"\n\nawait jane.save();\nconsole.log('jane 已保存到数据库!');\n\n\n1\n2\n3\n4\n5\n6\n\n * 快捷流程 create\n\nconst jane = await user.create({ name: \"jane\" });\n// jane 现在存在于数据库中！\nconsole.log(jane instanceof user); // true\nconsole.log(jane.name); // \"jane\"\n\n\n1\n2\n3\n4\n\n * 更新实例：create后使用set更新实例，之后进行保存\n * 删除实例：create后使用destroy销毁实例\n * 重载实例：create后使用reload可以获取数据库中的最新记录\n * 保存实例：保存时可以指定fields来指定仅保留部分字段\n * 使用 increment 和 decrement 方法可以解决递增和递减时的并发问题\n\n# 基础查询\n\n# insert\n\n * 使用 create 方法即可插入新数据\n\nconst user = await user.create({\n  username: 'alice123',\n  isadmin: true\n}, { fields: ['username'] }); // 在这里可以读取哪些字段，其他的调用为默认值，但是实际作用应该不大\n// 假设 isadmin 的默认值为 false\nconsole.log(user.username); // 'alice123'\nconsole.log(user.isadmin); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# select\n\n * 使用 findall() 查询一个表中的所有字段，等价于 select * from table_name\n * 加入 attributes 属性，可以查询表中的对应字段，attributes 一定要为数组，等价于 select attribute1, attribute2, ... from table_name\n   * 在数组中嵌套数组表示重命名\n\nmodel.findall({\n  attributes: ['foo', ['bar', 'baz'], 'qux']\n});\n\n\n1\n2\n3\n\n\nselect foo, bar as baz, qux from ...\n\n\n1\n\n * attributes 中可以加入聚合属性，聚合属性必须要有对应的别名\n\nmodel.findall({\n  attributes: [\n    'foo',\n    [sequelize.fn('count', sequelize.col('hats')), 'n_hats'],\n    'bar'\n  ]\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nselect foo, count(hats) as n_hats, bar from ...\n\n\n1\n\n\n * 只想添加聚合时，可以使用 include 属性\n\n * 想要排除某些字段时，可以使用 exclude 属性\n\n * where 可以传递查询条件，默认为相等，为 [op.eq]\n\n * 除此之外，sequelize的op属性中还有非常多的操作符，具体使用时可以关注模型查询（基础）\n\n# update\n\n第一个参数传递要修改的值，第二个参数可以传递一些选项，比如 where 和 transaction\n\n// 将所有没有姓氏的人更改为 \"doe\"\nawait user.update({ lastname: \"doe\" }, {\n  where: {\n    lastname: null\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n# delete\n\n * 根据条件删除可以传入 where\n * 删除所有条目可以使用 truncate\n\n// 截断表格\nawait user.destroy({\n  truncate: true\n});\n\n\n1\n2\n3\n4\n\n\n# 批量创建\n\nmodel.bulkcreate 允许在一次查询中创建多个记录，可以在 bulkcreate 方法中添加参数 validate 来为每个对象进行检验，但是只有所有都通过之后才会创建成功\n\nconst foo = sequelize.define('foo', {\n  name: {\n    type: datatypes.text,\n    validate: {\n      len: [4, 6]\n    }\n  }\n});\n\n// 这不会引发错误,两个实例都将被创建\nawait foo.bulkcreate([\n  { name: 'abc123' },\n  { name: 'name too long' }\n]);\n\n// 这将引发错误,不会创建任何内容\nawait foo.bulkcreate([\n  { name: 'abc123' },\n  { name: 'name too long' }\n], { validate: true });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 同时 bulkcreate 也可以加入 fields 参数\n\n# 排序\n\n向查询中添加 order 可以选择对应的排序方式\n\nsubtask.findall({\n  order: [\n    // 将转义 title 并针对有效方向列表进行降序排列\n    ['title', 'desc'],\n\n    // 将按最大年龄进行升序排序\n    sequelize.fn('max', sequelize.col('age')),\n\n    // 将按最大年龄进行降序排序\n    [sequelize.fn('max', sequelize.col('age')), 'desc'],\n\n    // 将按 otherfunction(`col1`, 12, 'lalala') 进行降序排序\n    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'desc'],\n\n    // 将使用模型名称作为关联名称按关联模型的 createdat 排序.\n    [task, 'createdat', 'desc'],\n\n    // 将使用模型名称作为关联名称通过关联模型的 createdat 排序.\n    [task, project, 'createdat', 'desc'],\n\n    // 将使用关联名称按关联模型的 createdat 排序.\n    ['task', 'createdat', 'desc'],\n\n    // 将使用关联的名称按嵌套的关联模型的 createdat 排序.\n    ['task', 'project', 'createdat', 'desc'],\n\n    // 将使用关联对象按关联模型的 createdat 排序. (首选方法)\n    [subtask.associations.task, 'createdat', 'desc'],\n\n    // 将使用关联对象按嵌套关联模型的 createdat 排序. (首选方法)\n    [subtask.associations.task, task.associations.project, 'createdat', 'desc'],\n\n    // 将使用简单的关联对象按关联模型的 createdat 排序.\n    [{model: task, as: 'task'}, 'createdat', 'desc'],\n\n    // 将由嵌套关联模型的 createdat 简单关联对象排序.\n    [{model: task, as: 'task'}, {model: project, as: 'project'}, 'createdat', 'desc']\n  ],\n\n  // 将按最大年龄降序排列\n  order: sequelize.literal('max(age) desc'),\n\n  // 如果忽略方向,则默认升序,将按最大年龄升序排序\n  order: sequelize.fn('max', sequelize.col('age')),\n\n  // 如果省略方向,则默认升序, 将按年龄升序排列\n  order: sequelize.col('age'),\n\n  // 将根据方言随机排序(但不是 fn('rand') 或 fn('random'))\n  order: sequelize.random()\n});\n\nfoo.findone({\n  order: [\n    // 将返回 `name`\n    ['name'],\n    // 将返回 `username` desc\n    ['username', 'desc'],\n    // 将返回 max(`age`)\n    sequelize.fn('max', sequelize.col('age')),\n    // 将返回 max(`age`) desc\n    [sequelize.fn('max', sequelize.col('age')), 'desc'],\n    // 将返回 otherfunction(`col1`, 12, 'lalala') desc\n    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'desc'],\n    // 将返回 otherfunction(awesomefunction(`col`)) desc, 这种嵌套可能是无限的!\n    [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'desc']\n  ]\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n> 回顾一下,order 数组的元素可以如下： 一个字符串 (它将被自动引用), 一个数组, 其第一个元素将被引用,第二个将被逐字追加, 一个具有 raw 字段的对象:raw 内容将不加引用地逐字添加,其他所有内容都将被忽略,如果未设置 raw,查询将失败 调用 sequelize.fn (这将在 sql 中生成一个函数调用), 调用 sequelize.col (这将引用列名),\n\n# 分组\n\n分组和排序的语法几乎一样，但是没有升序和降序之别\n\n注意\n\n你还可以将字符串直接传递给 group,该字符串将直接(普通)包含在生成的 sql 中. 请谨慎使用,请勿与用户生成的内容一起使用.\n\n# 限制与分页\n\n在查询中，加入 limit 可以限制查询的最多数目，加入 offset 可以声明开始查询的条目\n\n# 实用方法\n\n * count 计算数据库中元素出现的数目\n\nconsole.log(`这有 ${await project.count()} 个项目`);\n\nconst amount = await project.count({\n  where: {\n    id: {\n      [op.gt]: 25\n    }\n  }\n});\nconsole.log(`这有 ${amount} 个项目 id 大于 25`);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * max min sum\n\nawait user.max('age'); // 40\nawait user.max('age', { where: { age: { [op.lt]: 20 } } }); // 10\nawait user.min('age'); // 5\nawait user.min('age', { where: { age: { [op.gt]: 5 } } }); // 10\nawait user.sum('age'); // 55\nawait user.sum('age', { where: { age: { [op.gt]: 5 } } }); // 50\n\n\n1\n2\n3\n4\n5\n6\n\n * increment,decrement （前面已有）\n\n# 模型查找器\n\n * findall 查询所有条目\n * findbypk 根据主键进行查找\n * findone 查找满足条件的第一个条目\n * findorcreate 除非找到一个满足查询参数的结果,否则方法 findorcreate 将在表中创建一个条目. 在这两种情况下,它将返回一个实例(找到的实例或创建的实例)和一个布尔值,指示该实例是已创建还是已经存在.\n\n提示\n\n使用 where 参数来查找条目,而使用 defaults 参数来定义必须创建的内容. 如果 defaults 不包含每一列的值,则 sequelize 将采用 where 的值(如果存在). 假设我们有一个空的数据库,该数据库具有一个 user 模型,该模型具有一个 username 和一个 job.\n\nconst [user, created] = await user.findorcreate({\n  where: { username: 'sdepold' },\n  defaults: {\n    job: 'technical lead javascript'\n  }\n});\nconsole.log(user.username); // 'sdepold'\nconsole.log(user.job); // 这可能是也可能不是 'technical lead javascript'\nconsole.log(created); // 指示此实例是否刚刚创建的布尔值\nif (created) {\n  console.log(user.job); // 这里肯定是 'technical lead javascript'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * findandcountall 结合了 findall 和 count 的便捷方法. 在处理与分页有关的查询时非常有用,在分页中,你想检索带有 limit 和 offset 的数据,但又需要知道与查询匹配的记录总数.\n\n提示\n\n当提供了 group 时, findandcountall 方法返回一个具有两个属性的对象：\n\ncount - 一个数组对象 - 包含每组中的合计和预设属性 rows - 一个数组对象 - 获得的记录\n\n提示\n\n至此，已经基本学习了 sequelize 的基本语法，剩下的内容更适合阅读学习，只有遇到场景时才需要查阅。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"教程中的难点3",frontmatter:{title:"教程中的难点3",date:"2024-05-29T23:51:17.000Z",permalink:"/pages/d8612d/",categories:["技术","TypeScript"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.TypeScript/04.%E6%95%99%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%9A%BE%E7%82%B93.html",relativePath:"03.技术/02.TypeScript/04.教程中的难点3.md",key:"v-5cdd16c2",path:"/pages/d8612d/",headers:[{level:4,title:"类",slug:"类",normalizedTitle:"类",charIndex:51},{level:5,title:"类的组成部分",slug:"类的组成部分",normalizedTitle:"类的组成部分",charIndex:56},{level:5,title:"类的继承",slug:"类的继承",normalizedTitle:"类的继承",charIndex:1360},{level:5,title:"成员可见性",slug:"成员可见性",normalizedTitle:"成员可见性",charIndex:714},{level:6,title:"pulblic",slug:"pulblic",normalizedTitle:"pulblic",charIndex:3709},{level:6,title:"protected",slug:"protected",normalizedTitle:"protected",charIndex:3756},{level:6,title:"private",slug:"private",normalizedTitle:"private",charIndex:381},{level:5,title:"静态成员",slug:"静态成员",normalizedTitle:"静态成员",charIndex:5612},{level:5,title:"静态代码块",slug:"静态代码块",normalizedTitle:"静态代码块",charIndex:5942},{level:5,title:"泛型类",slug:"泛型类",normalizedTitle:"泛型类",charIndex:6273},{level:5,title:"类与 this",slug:"类与-this",normalizedTitle:"类与 this",charIndex:6511},{level:5,title:"this 的类型",slug:"this-的类型",normalizedTitle:"this 的类型",charIndex:7279},{level:6,title:"基于 this 的类型守卫",slug:"基于-this-的类型守卫",normalizedTitle:"基于 this 的类型守卫",charIndex:8166},{level:5,title:"参数修饰符",slug:"参数修饰符",normalizedTitle:"参数修饰符",charIndex:9535},{level:5,title:"类表达式",slug:"类表达式",normalizedTitle:"类表达式",charIndex:9936},{level:5,title:"构造函数签名",slug:"构造函数签名",normalizedTitle:"构造函数签名",charIndex:10209},{level:5,title:"抽象类和抽象成员",slug:"抽象类和抽象成员",normalizedTitle:"抽象类和抽象成员",charIndex:10710},{level:6,title:"从抽象类派生类中创造实例",slug:"从抽象类派生类中创造实例",normalizedTitle:"从抽象类派生类中创造实例",charIndex:11259},{level:5,title:"类之间的关系",slug:"类之间的关系",normalizedTitle:"类之间的关系",charIndex:11595}],headersStr:"类 类的组成部分 类的继承 成员可见性 pulblic protected private 静态成员 静态代码块 泛型类 类与 this this 的类型 基于 this 的类型守卫 参数修饰符 类表达式 构造函数签名 抽象类和抽象成员 从抽象类派生类中创造实例 类之间的关系",content:'提示\n\n本文整理自 TypeScript 官方文档中的 handlebook，版本为 V5.4\n\n# 类\n\n# 类的组成部分\n\n 1. 类的字段\n\n * 字段声明可以在类上创建公共可写属性\n * 可以声明类型，不声明则隐式为any\n * 类的字段在声明时可以给定初始值\n * 设置 strictPropertyInitialization 为 true 则必须给字段初始值\n * 如果不希望初始化，但是又设置了 strictPropertyInitialization，可以使用非空断言\n * 在字段面前加入 readonly 则该字段不能被修改\n\nclass Person {\n  name: string\n  age // 隐式为any\n  gender!: \'male\' | \'female\' // 设置非空断言时不初始化也不会报错\n  readonly privateHobby: string // 设置了 readonly 后无法修改 \n}\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 类的构造函数\n\n * 类的构造函数也可以加入带有注释、默认值、重载的参数\n * 类的构造函数不能有类型参数，即无法使用泛型\n * 类的构造函数不能设置返回值的类型\n * 调用 super() 必须要在使用 this 之前\n\n 3. 类的方法\n\n * 除了类型标注意外，ts的类方法与js无异\n\n 4. 类的 getter 和 setter\n\n * 对访问器有一些限制\n   * get存在而set不存在时默认只读\n   * 未指定setter的类型，将会从getter的返回类型进行推断\n   * getter和setter必须有相同的成员可见性\n   * ts 4.3 开始，getter和setter可以设置不同的参数类型\n\nclass Thing {\n  _size = 0;\n \n  get size(): number {\n    return this._size;\n  }\n \n  set size(value: string | number | boolean) {\n    let num = Number(value);\n \n    // Don\'t allow NaN, Infinity, etc\n \n    if (!Number.isFinite(num)) {\n      this._size = 0;\n      return;\n    }\n \n    this._size = num;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 索引签名，与对象的索引签名类似\n\nclass MyClass {\n  [s: string]: boolean | ((s: string) => boolean);\n \n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n由于索引签名类型还需要捕获方法的类型，因此要有效地使用这些类型并不容易。通常，最好将索引数据存储在另一个位置，而不是存储在类实例本身上。\n\n# 类的继承\n\n * implements 子句用以判断 class 是否实现了 interface 中的所有成员\n\n * implements 实现多个 interface，中间使用逗号隔开\n   \n   * 值得注意的时，implements 子句不会完善 class 的类型，一切都还需要自己重新声明\n\n * extends\n   \n   * 当使用 extends 关键字时，派生类会继承基类所有的属性与方法，同时还可以定义其他成员\n   * 派生类可以重写基类的方法，如果需要使用基类方法，可以使用 super.method() 的写法\n\n * 值得注意的一点是，派生类在重写基类方法时，一定要遵循基类的规范，因为在ts的背景下，会使用基类来引用派生类的实例\n\nclass Base {\n  greet() {\n    console.log("Hello, world!");\n  }\n}\n \nclass Derived extends Base {\n  greet(name?: string) {\n    if (name === undefined) {\n      super.greet();\n    } else {\n      console.log(`Hello, ${name.toUpperCase()}`);\n    }\n  }\n}\n \nconst d = new Derived();\nd.greet();\nd.greet("reader");\n\n// Alias the derived instance through a base class reference\nconst b: Base = d;\n// No problem\nb.greet();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n注意\n\n当 target >= ES2022 或 useDefineForClassFields 为 true 时，类字段将在父类构造函数完成后初始化，覆盖父类设置的任何值。当您只想为继承的字段重新声明更准确的类型时，这可能是一个问题。若要处理这些情况，可以编写 declare 以指示 TypeScript 此字段声明不应具有运行时效果。\n\ninterface Animal {\n  dateOfBirth: any;\n}\n \ninterface Dog extends Animal {\n  breed: any;\n}\n \nclass AnimalHouse {\n  resident: Animal;\n  constructor(animal: Animal) {\n    this.resident = animal;\n  }\n}\n \nclass DogHouse extends AnimalHouse {\n  // Does not emit JavaScript code,\n  // only ensures the types are correct\n  declare resident: Dog;\n  constructor(dog: Dog) {\n    super(dog);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * JavaScript 类的初始化顺序如下：\n   * 基类字段初始化 -> 基类 constructor 运行 -> 派生类字段初始化 -> 派生类 constructor 运行\n   * 基类 constructor 运行时已经看到了自己的字段，但是还没有看到派生类的字段\n\n提示\n\nextends 有一定的历史兼容性问题 在 ES2015 中，返回对象的构造函数隐式地将 this 的值替换为 super(...) 的任何调用方。生成的构造函数代码必须捕获 super(...) 的任何潜在返回值并将其替换为 this 。 因此，子类化 Error 、 Array 和其他 可能不再按预期工作。这是因为 Error ， Array 等的构造函数使用 ECMAScript 6 的 new.target 来调整原型链;但是，在 ECMAScript 5 中调用构造函数时，无法确保 new.target 的值。默认情况下，其他下层编译器通常具有相同的限制。\n\n建议在任何 super(...) 调用后立即手动调整原型。\n\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n \n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MsgError.prototype);\n  }\n \n  sayHello() {\n    return "hello " + this.message;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n但是， MsgError 的任何子类也必须手动设置原型。对于不支持 Object.setPrototypeOf 的运行时，您可以改用 __proto__\n\n遗憾的是，这些解决方法不适用于 Internet Explorer 10 及更早版本。可以手动将方法从原型复制到实例本身（即 MsgError.prototype 到 this ），但原型链本身无法固定。\n\n# 成员可见性\n\n# pulblic\n\n类成员的默认可见性为 public ，可以在类的任何位置上访问类成员\n\n# protected\n\nprotected 成员仅对类本身及继承类的派生类可见\n\nclass Greeter {\n  public greet() {\n    console.log("Hello, " + this.getName());\n  }\n  protected getName() {\n    return "hi";\n  }\n}\n \nclass SpecialGreeter extends Greeter {\n  public howdy() {\n    // OK to access protected member here\n    console.log("Howdy, " + this.getName());\n  }\n}\nconst g = new SpecialGreeter();\ng.greet(); // OK\ng.getName();\n// Property \'getName\' is protected and only accessible within class \'Greeter\' and its subclasses.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 派生类可以将基类的 protected 属性变为 public\n\nclass Base {\n  protected m = 10;\n}\nclass Derived extends Base {\n  // No modifier, so default is \'public\'\n  m = 15;\n}\nconst d = new Derived();\nconsole.log(d.m); // OK\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 如果要保证 m 仍然为 protected 的，需要加入修饰符，否则会默认为 public\n\n * 不同派生类之间无法通过基类来访问 protected 可见性的成员\n\nclass Base {\n  protected x: number = 1;\n}\nclass Derived1 extends Base {\n  protected x: number = 5;\n}\nclass Derived2 extends Base {\n  f1(other: Derived2) {\n    other.x = 10;\n  }\n  f2(other: Derived1) {\n    // Property \'x\' is protected and only accessible within class \'Derived1\' and its subclasses.\n    other.x = 10;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# private\n\n * 仅允许类本身访问其 private 可见性的成员\n\n * ts 允许跨实例访问 private 成员\n\nclass A {\n  private x = 10;\n \n  public sameAs(other: A) {\n    // No error\n    return other.x === this.x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\n与 TypeScript 类型系统的其他方面一样， private 和 protected 仅在类型检查期间强制执行。\n\n这意味着 JavaScript 运行时构造（如 in 或简单属性查找）仍然可以访问 private 或 protected 成员\n\nprivate 还允许在类型检查期间使用括号表示法进行访问。这使得 private 声明的字段可能更容易访问单元测试等内容，缺点是这些字段是软私有的，并且不严格强制执行隐私。\n\n与 TypeScripts 的 private 不同，JavaScript 的私有字段 （ # ） 在编译后保持私有，并且不提供前面提到的转义舱口，如括号符号访问，使它们成为硬私有的。\n\n编译到 ES2021 或更低版本时，TypeScript 将使用 WeakMaps 代替 # 。\n\n如果需要保护类中的值免受恶意执行者的侵害，则应使用提供硬运行时隐私的机制，例如闭包、WeakMaps 或私有字段。请注意，在运行时添加的这些隐私检查可能会影响性能。\n\n# 静态成员\n\n静态成员不与类的特定实例相绑定，而只能通过类的构造函数对象本身去访问\n\nclass MyClass {\n  static x = 0;\n  static printX() {\n    console.log(MyClass.x);\n  }\n}\nconsole.log(MyClass.x);\nMyClass.printX();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 静态成员也可以使用 public protected private 来修饰\n * 静态成员是可以继承的\n * 特殊的静态成员。函数的属性，例如 name length call 是无法被设置为静态成员的\n * TS中不需要静态的类，因为只有一个实例的类对应着一个对象\n\n# 静态代码块\n\n在静态代码块中，我们可以访问到 private 的属性并可以读写对应的值，这可以帮助我们初始化，完全访问内部变量而不会造成变量泄漏\n\nclass Foo {\n  static #count = 0;\n \n  get count() {\n    return Foo.#count;\n  }\n \n  static {\n    try {\n      const lastInstances = loadLastInstances();\n      Foo.#count += lastInstances.length;\n    }\n    catch {}\n}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 泛型类\n\n * 可以通过在类中加入泛型来控制类中某些成员的类型，泛型可以使用约束和接口来书写\n\nclass Box<Type> {\n  contents: Type;\n  constructor(value: Type) {\n    this.contents = value;\n  }\n}\n \nconst b = new Box("hello!");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 静态成员不可以加入泛型，因为静态成员是所有类共用的，不是每个实例私有的\n\n# 类与 this\n\n * js 中的 this 取决于如何被调用，当被直接调用时，访问的是类作为 this，如果被实例调用时，则访问的是实例中的属性\n\nclass MyClass {\n  name = "MyClass";\n  getName() {\n    return this.name;\n  }\n}\nconst c = new MyClass();\nconst obj = {\n  name: "obj",\n  getName: c.getName,\n};\n \n// Prints "obj", not "MyClass"\nconsole.log(obj.getName());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n * 使用箭头函数可以修正上述问题，因为箭头函数没有自己的 this，因此总会使用类中的 this，但是也有一些缺陷\n   \n   * 箭头函数不会被绑定在类的 prototype 上，因此，每个实例都会创建自己的箭头函数，从而占用更多的内存\n   * 箭头函数无法被继承，只能通过 super.method 来进行访问\n\n * 也可以通过为函数的 this 绑定特定的类型来进行限制，确保函数被正确访问\n\nclass MyClass {\n  name = "MyClass";\n  getName(this: MyClass) {\n    return this.name;\n  }\n}\nconst c = new MyClass();\n// OK\nc.getName();\n \n// Error, would crash\nconst g = c.getName;\nconsole.log(g());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# this 的类型\n\n * this 总指向调用他的类\n\nclass Box {\n  content: string = \'\'\n\n  set (val: string) {\n    this.content = val\n    return this\n  }\n}\n\nclass ClearableBox extends Box {\n  clear () {\n    this.content = \'\'\n  }\n}\n\nconst clearableBox = new ClearableBox()\nconst anotherClearableBox = clearableBox.set(\'hello\') // anotherClearableBox 的类型将会为 ClearableBox\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 如果通过参数闭包了类的 this，将无法传递其他的类\n\nclass Box {\n  content: string = "";\n  sameAs(other: this) {\n    return other.content === this.content;\n  }\n}\n \nclass DerivedBox extends Box {\n  otherContent: string = "?";\n}\n \nconst base = new Box();\nconst derived = new DerivedBox();\nderived.sameAs(base);\n// Argument of type \'Box\' is not assignable to parameter of type \'DerivedBox\'.\n// Property \'otherContent\' is missing in type \'Box\' but required in type \'DerivedBox\'.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 基于 this 的类型守卫\n\n * 使用类型谓语做类型缩窄\n\nclass FileSystemObject {\n  isFile(): this is FileRep {\n    return this instanceof FileRep;\n  }\n  isDirectory(): this is Directory {\n    return this instanceof Directory;\n  }\n  isNetworked(): this is Networked & this {\n    return this.networked;\n  }\n  constructor(public path: string, private networked: boolean) {}\n}\n \nclass FileRep extends FileSystemObject {\n  constructor(path: string, public content: string) {\n    super(path, false);\n  }\n}\n \nclass Directory extends FileSystemObject {\n  children: FileSystemObject[];\n}\n \ninterface Networked {\n  host: string;\n}\n \nconst fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");\n \nif (fso.isFile()) {\n  fso.content;\n// const fso: FileRep\n} else if (fso.isDirectory()) {\n  fso.children;\n// const fso: Directory\n} else if (fso.isNetworked()) {\n  fso.host;\n// const fso: Networked & FileSystemObject\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * 通常这种方式被用来限定不为 undefined\n\nclass Box<T> {\n  value?: T;\n \n  hasValue(): this is { value: T } {\n    return this.value !== undefined;\n  }\n}\n \nconst box = new Box<string>();\nbox.value = "Gameboy";\n \nbox.value;\n     \n// (property) Box<string>.value?: string\n \nif (box.hasValue()) {\n  box.value;\n// (property) value: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 参数修饰符\n\n * 可以为参数添加 public protected private 等修饰符\n\nclass Params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number\n  ) {\n    // No body necessary\n  }\n}\nconst a = new Params(1, 2, 3);\nconsole.log(a.x);\n// (property) Params.x: number\nconsole.log(a.z);\n// Property \'z\' is private and only accessible within class \'Params\'.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 类表达式\n\n类表达式与类声明非常相似。唯一真正的区别是类表达式不需要名称，尽管我们可以通过它们最终绑定到的任何标识符来引用它们\n\nconst someClass = class<Type> {\n  content: Type;\n  constructor(value: Type) {\n    this.content = value;\n  }\n};\n \nconst m = new someClass("Hello, world");\n// const m: someClass<string>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 构造函数签名\n\nJavaScript 类使用 new 运算符实例化。给定类本身的类型，InstanceType 实用工具类型将对此操作进行建模。\n\nclass Point {\n  createdAt: number;\n  x: number;\n  y: number\n  constructor(x: number, y: number) {\n    this.createdAt = Date.now()\n    this.x = x;\n    this.y = y;\n  }\n}\ntype PointInstance = InstanceType<typeof Point> // 从这里获取到了 class 类的 实例的类型\n \nfunction moveRight(point: PointInstance) {\n  point.x += 5;\n}\n \nconst point = new Point(3, 4);\nmoveRight(point);\npoint.x; // => 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 抽象类和抽象成员\n\nTypeScript 中的类、方法和字段可能是抽象的。\n\n抽象方法或抽象字段是尚未提供实现的方法或抽象字段。这些成员必须存在于抽象类中，不能直接实例化。\n\n抽象类的作用是充当子类的基类，这些子类确实实现了所有抽象成员。当一个类没有任何抽象成员时，它被称为具体的。\n\nabstract class Base {\n  abstract getName(): string;\n \n  printName() {\n    console.log("Hello, " + this.getName());\n  }\n}\n \nconst b = new Base();\n// Cannot create an instance of an abstract class.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们不能用 new 实例化 Base ，因为它是抽象的。相反，我们需要创建一个派生类并实现抽象成员：\n\nclass Derived extends Base {\n  getName() {\n    return "world";\n  }\n}\n \nconst d = new Derived();\nd.printName();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 从抽象类派生类中创造实例\n\nfunction greet(ctor: new () => Base) {\n  const instance = new ctor();\n  instance.printName();\n}\ngreet(Derived);\ngreet(Base);\n// Argument of type \'typeof Base\' is not assignable to parameter of type \'new () => Base\'.\n  // Cannot assign an abstract constructor type to a non-abstract constructor type.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 类之间的关系\n\n * 当类的结构相同时，被认为是同一个类\n\n * 即使类之间没有显式继承，类之间仍然会存在父子关系\n\nclass Person {\n  name: string;\n  age: number;\n}\n \nclass Employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n \n// OK\nconst p: Person = new Employee();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n提示\n\n空类没有成员，可以被任何其他类所替代，但是同样地，空类也没法做任何事情，不建议使用。',normalizedContent:'提示\n\n本文整理自 typescript 官方文档中的 handlebook，版本为 v5.4\n\n# 类\n\n# 类的组成部分\n\n 1. 类的字段\n\n * 字段声明可以在类上创建公共可写属性\n * 可以声明类型，不声明则隐式为any\n * 类的字段在声明时可以给定初始值\n * 设置 strictpropertyinitialization 为 true 则必须给字段初始值\n * 如果不希望初始化，但是又设置了 strictpropertyinitialization，可以使用非空断言\n * 在字段面前加入 readonly 则该字段不能被修改\n\nclass person {\n  name: string\n  age // 隐式为any\n  gender!: \'male\' | \'female\' // 设置非空断言时不初始化也不会报错\n  readonly privatehobby: string // 设置了 readonly 后无法修改 \n}\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 类的构造函数\n\n * 类的构造函数也可以加入带有注释、默认值、重载的参数\n * 类的构造函数不能有类型参数，即无法使用泛型\n * 类的构造函数不能设置返回值的类型\n * 调用 super() 必须要在使用 this 之前\n\n 3. 类的方法\n\n * 除了类型标注意外，ts的类方法与js无异\n\n 4. 类的 getter 和 setter\n\n * 对访问器有一些限制\n   * get存在而set不存在时默认只读\n   * 未指定setter的类型，将会从getter的返回类型进行推断\n   * getter和setter必须有相同的成员可见性\n   * ts 4.3 开始，getter和setter可以设置不同的参数类型\n\nclass thing {\n  _size = 0;\n \n  get size(): number {\n    return this._size;\n  }\n \n  set size(value: string | number | boolean) {\n    let num = number(value);\n \n    // don\'t allow nan, infinity, etc\n \n    if (!number.isfinite(num)) {\n      this._size = 0;\n      return;\n    }\n \n    this._size = num;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 索引签名，与对象的索引签名类似\n\nclass myclass {\n  [s: string]: boolean | ((s: string) => boolean);\n \n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n由于索引签名类型还需要捕获方法的类型，因此要有效地使用这些类型并不容易。通常，最好将索引数据存储在另一个位置，而不是存储在类实例本身上。\n\n# 类的继承\n\n * implements 子句用以判断 class 是否实现了 interface 中的所有成员\n\n * implements 实现多个 interface，中间使用逗号隔开\n   \n   * 值得注意的时，implements 子句不会完善 class 的类型，一切都还需要自己重新声明\n\n * extends\n   \n   * 当使用 extends 关键字时，派生类会继承基类所有的属性与方法，同时还可以定义其他成员\n   * 派生类可以重写基类的方法，如果需要使用基类方法，可以使用 super.method() 的写法\n\n * 值得注意的一点是，派生类在重写基类方法时，一定要遵循基类的规范，因为在ts的背景下，会使用基类来引用派生类的实例\n\nclass base {\n  greet() {\n    console.log("hello, world!");\n  }\n}\n \nclass derived extends base {\n  greet(name?: string) {\n    if (name === undefined) {\n      super.greet();\n    } else {\n      console.log(`hello, ${name.touppercase()}`);\n    }\n  }\n}\n \nconst d = new derived();\nd.greet();\nd.greet("reader");\n\n// alias the derived instance through a base class reference\nconst b: base = d;\n// no problem\nb.greet();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n注意\n\n当 target >= es2022 或 usedefineforclassfields 为 true 时，类字段将在父类构造函数完成后初始化，覆盖父类设置的任何值。当您只想为继承的字段重新声明更准确的类型时，这可能是一个问题。若要处理这些情况，可以编写 declare 以指示 typescript 此字段声明不应具有运行时效果。\n\ninterface animal {\n  dateofbirth: any;\n}\n \ninterface dog extends animal {\n  breed: any;\n}\n \nclass animalhouse {\n  resident: animal;\n  constructor(animal: animal) {\n    this.resident = animal;\n  }\n}\n \nclass doghouse extends animalhouse {\n  // does not emit javascript code,\n  // only ensures the types are correct\n  declare resident: dog;\n  constructor(dog: dog) {\n    super(dog);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * javascript 类的初始化顺序如下：\n   * 基类字段初始化 -> 基类 constructor 运行 -> 派生类字段初始化 -> 派生类 constructor 运行\n   * 基类 constructor 运行时已经看到了自己的字段，但是还没有看到派生类的字段\n\n提示\n\nextends 有一定的历史兼容性问题 在 es2015 中，返回对象的构造函数隐式地将 this 的值替换为 super(...) 的任何调用方。生成的构造函数代码必须捕获 super(...) 的任何潜在返回值并将其替换为 this 。 因此，子类化 error 、 array 和其他 可能不再按预期工作。这是因为 error ， array 等的构造函数使用 ecmascript 6 的 new.target 来调整原型链;但是，在 ecmascript 5 中调用构造函数时，无法确保 new.target 的值。默认情况下，其他下层编译器通常具有相同的限制。\n\n建议在任何 super(...) 调用后立即手动调整原型。\n\nclass msgerror extends error {\n  constructor(m: string) {\n    super(m);\n \n    // set the prototype explicitly.\n    object.setprototypeof(this, msgerror.prototype);\n  }\n \n  sayhello() {\n    return "hello " + this.message;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n但是， msgerror 的任何子类也必须手动设置原型。对于不支持 object.setprototypeof 的运行时，您可以改用 __proto__\n\n遗憾的是，这些解决方法不适用于 internet explorer 10 及更早版本。可以手动将方法从原型复制到实例本身（即 msgerror.prototype 到 this ），但原型链本身无法固定。\n\n# 成员可见性\n\n# pulblic\n\n类成员的默认可见性为 public ，可以在类的任何位置上访问类成员\n\n# protected\n\nprotected 成员仅对类本身及继承类的派生类可见\n\nclass greeter {\n  public greet() {\n    console.log("hello, " + this.getname());\n  }\n  protected getname() {\n    return "hi";\n  }\n}\n \nclass specialgreeter extends greeter {\n  public howdy() {\n    // ok to access protected member here\n    console.log("howdy, " + this.getname());\n  }\n}\nconst g = new specialgreeter();\ng.greet(); // ok\ng.getname();\n// property \'getname\' is protected and only accessible within class \'greeter\' and its subclasses.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 派生类可以将基类的 protected 属性变为 public\n\nclass base {\n  protected m = 10;\n}\nclass derived extends base {\n  // no modifier, so default is \'public\'\n  m = 15;\n}\nconst d = new derived();\nconsole.log(d.m); // ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 如果要保证 m 仍然为 protected 的，需要加入修饰符，否则会默认为 public\n\n * 不同派生类之间无法通过基类来访问 protected 可见性的成员\n\nclass base {\n  protected x: number = 1;\n}\nclass derived1 extends base {\n  protected x: number = 5;\n}\nclass derived2 extends base {\n  f1(other: derived2) {\n    other.x = 10;\n  }\n  f2(other: derived1) {\n    // property \'x\' is protected and only accessible within class \'derived1\' and its subclasses.\n    other.x = 10;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# private\n\n * 仅允许类本身访问其 private 可见性的成员\n\n * ts 允许跨实例访问 private 成员\n\nclass a {\n  private x = 10;\n \n  public sameas(other: a) {\n    // no error\n    return other.x === this.x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意\n\n与 typescript 类型系统的其他方面一样， private 和 protected 仅在类型检查期间强制执行。\n\n这意味着 javascript 运行时构造（如 in 或简单属性查找）仍然可以访问 private 或 protected 成员\n\nprivate 还允许在类型检查期间使用括号表示法进行访问。这使得 private 声明的字段可能更容易访问单元测试等内容，缺点是这些字段是软私有的，并且不严格强制执行隐私。\n\n与 typescripts 的 private 不同，javascript 的私有字段 （ # ） 在编译后保持私有，并且不提供前面提到的转义舱口，如括号符号访问，使它们成为硬私有的。\n\n编译到 es2021 或更低版本时，typescript 将使用 weakmaps 代替 # 。\n\n如果需要保护类中的值免受恶意执行者的侵害，则应使用提供硬运行时隐私的机制，例如闭包、weakmaps 或私有字段。请注意，在运行时添加的这些隐私检查可能会影响性能。\n\n# 静态成员\n\n静态成员不与类的特定实例相绑定，而只能通过类的构造函数对象本身去访问\n\nclass myclass {\n  static x = 0;\n  static printx() {\n    console.log(myclass.x);\n  }\n}\nconsole.log(myclass.x);\nmyclass.printx();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 静态成员也可以使用 public protected private 来修饰\n * 静态成员是可以继承的\n * 特殊的静态成员。函数的属性，例如 name length call 是无法被设置为静态成员的\n * ts中不需要静态的类，因为只有一个实例的类对应着一个对象\n\n# 静态代码块\n\n在静态代码块中，我们可以访问到 private 的属性并可以读写对应的值，这可以帮助我们初始化，完全访问内部变量而不会造成变量泄漏\n\nclass foo {\n  static #count = 0;\n \n  get count() {\n    return foo.#count;\n  }\n \n  static {\n    try {\n      const lastinstances = loadlastinstances();\n      foo.#count += lastinstances.length;\n    }\n    catch {}\n}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 泛型类\n\n * 可以通过在类中加入泛型来控制类中某些成员的类型，泛型可以使用约束和接口来书写\n\nclass box<type> {\n  contents: type;\n  constructor(value: type) {\n    this.contents = value;\n  }\n}\n \nconst b = new box("hello!");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 静态成员不可以加入泛型，因为静态成员是所有类共用的，不是每个实例私有的\n\n# 类与 this\n\n * js 中的 this 取决于如何被调用，当被直接调用时，访问的是类作为 this，如果被实例调用时，则访问的是实例中的属性\n\nclass myclass {\n  name = "myclass";\n  getname() {\n    return this.name;\n  }\n}\nconst c = new myclass();\nconst obj = {\n  name: "obj",\n  getname: c.getname,\n};\n \n// prints "obj", not "myclass"\nconsole.log(obj.getname());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n * 使用箭头函数可以修正上述问题，因为箭头函数没有自己的 this，因此总会使用类中的 this，但是也有一些缺陷\n   \n   * 箭头函数不会被绑定在类的 prototype 上，因此，每个实例都会创建自己的箭头函数，从而占用更多的内存\n   * 箭头函数无法被继承，只能通过 super.method 来进行访问\n\n * 也可以通过为函数的 this 绑定特定的类型来进行限制，确保函数被正确访问\n\nclass myclass {\n  name = "myclass";\n  getname(this: myclass) {\n    return this.name;\n  }\n}\nconst c = new myclass();\n// ok\nc.getname();\n \n// error, would crash\nconst g = c.getname;\nconsole.log(g());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# this 的类型\n\n * this 总指向调用他的类\n\nclass box {\n  content: string = \'\'\n\n  set (val: string) {\n    this.content = val\n    return this\n  }\n}\n\nclass clearablebox extends box {\n  clear () {\n    this.content = \'\'\n  }\n}\n\nconst clearablebox = new clearablebox()\nconst anotherclearablebox = clearablebox.set(\'hello\') // anotherclearablebox 的类型将会为 clearablebox\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 如果通过参数闭包了类的 this，将无法传递其他的类\n\nclass box {\n  content: string = "";\n  sameas(other: this) {\n    return other.content === this.content;\n  }\n}\n \nclass derivedbox extends box {\n  othercontent: string = "?";\n}\n \nconst base = new box();\nconst derived = new derivedbox();\nderived.sameas(base);\n// argument of type \'box\' is not assignable to parameter of type \'derivedbox\'.\n// property \'othercontent\' is missing in type \'box\' but required in type \'derivedbox\'.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 基于 this 的类型守卫\n\n * 使用类型谓语做类型缩窄\n\nclass filesystemobject {\n  isfile(): this is filerep {\n    return this instanceof filerep;\n  }\n  isdirectory(): this is directory {\n    return this instanceof directory;\n  }\n  isnetworked(): this is networked & this {\n    return this.networked;\n  }\n  constructor(public path: string, private networked: boolean) {}\n}\n \nclass filerep extends filesystemobject {\n  constructor(path: string, public content: string) {\n    super(path, false);\n  }\n}\n \nclass directory extends filesystemobject {\n  children: filesystemobject[];\n}\n \ninterface networked {\n  host: string;\n}\n \nconst fso: filesystemobject = new filerep("foo/bar.txt", "foo");\n \nif (fso.isfile()) {\n  fso.content;\n// const fso: filerep\n} else if (fso.isdirectory()) {\n  fso.children;\n// const fso: directory\n} else if (fso.isnetworked()) {\n  fso.host;\n// const fso: networked & filesystemobject\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * 通常这种方式被用来限定不为 undefined\n\nclass box<t> {\n  value?: t;\n \n  hasvalue(): this is { value: t } {\n    return this.value !== undefined;\n  }\n}\n \nconst box = new box<string>();\nbox.value = "gameboy";\n \nbox.value;\n     \n// (property) box<string>.value?: string\n \nif (box.hasvalue()) {\n  box.value;\n// (property) value: string\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 参数修饰符\n\n * 可以为参数添加 public protected private 等修饰符\n\nclass params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number\n  ) {\n    // no body necessary\n  }\n}\nconst a = new params(1, 2, 3);\nconsole.log(a.x);\n// (property) params.x: number\nconsole.log(a.z);\n// property \'z\' is private and only accessible within class \'params\'.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 类表达式\n\n类表达式与类声明非常相似。唯一真正的区别是类表达式不需要名称，尽管我们可以通过它们最终绑定到的任何标识符来引用它们\n\nconst someclass = class<type> {\n  content: type;\n  constructor(value: type) {\n    this.content = value;\n  }\n};\n \nconst m = new someclass("hello, world");\n// const m: someclass<string>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 构造函数签名\n\njavascript 类使用 new 运算符实例化。给定类本身的类型，instancetype 实用工具类型将对此操作进行建模。\n\nclass point {\n  createdat: number;\n  x: number;\n  y: number\n  constructor(x: number, y: number) {\n    this.createdat = date.now()\n    this.x = x;\n    this.y = y;\n  }\n}\ntype pointinstance = instancetype<typeof point> // 从这里获取到了 class 类的 实例的类型\n \nfunction moveright(point: pointinstance) {\n  point.x += 5;\n}\n \nconst point = new point(3, 4);\nmoveright(point);\npoint.x; // => 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 抽象类和抽象成员\n\ntypescript 中的类、方法和字段可能是抽象的。\n\n抽象方法或抽象字段是尚未提供实现的方法或抽象字段。这些成员必须存在于抽象类中，不能直接实例化。\n\n抽象类的作用是充当子类的基类，这些子类确实实现了所有抽象成员。当一个类没有任何抽象成员时，它被称为具体的。\n\nabstract class base {\n  abstract getname(): string;\n \n  printname() {\n    console.log("hello, " + this.getname());\n  }\n}\n \nconst b = new base();\n// cannot create an instance of an abstract class.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们不能用 new 实例化 base ，因为它是抽象的。相反，我们需要创建一个派生类并实现抽象成员：\n\nclass derived extends base {\n  getname() {\n    return "world";\n  }\n}\n \nconst d = new derived();\nd.printname();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 从抽象类派生类中创造实例\n\nfunction greet(ctor: new () => base) {\n  const instance = new ctor();\n  instance.printname();\n}\ngreet(derived);\ngreet(base);\n// argument of type \'typeof base\' is not assignable to parameter of type \'new () => base\'.\n  // cannot assign an abstract constructor type to a non-abstract constructor type.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 类之间的关系\n\n * 当类的结构相同时，被认为是同一个类\n\n * 即使类之间没有显式继承，类之间仍然会存在父子关系\n\nclass person {\n  name: string;\n  age: number;\n}\n \nclass employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n \n// ok\nconst p: person = new employee();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n提示\n\n空类没有成员，可以被任何其他类所替代，但是同样地，空类也没法做任何事情，不建议使用。',charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"写在前面",frontmatter:{title:"写在前面",date:"2024-06-22T00:27:31.000Z",permalink:"/pages/fbac8b/",categories:["技术","shell"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.shell/01.%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2.html",relativePath:"03.技术/04.shell/01.写在前面.md",key:"v-363c7954",path:"/pages/fbac8b/",headersStr:null,content:"提示\n\n为了能够更好地适应前端项目的配置，以及给自己更大的可能性，我需要学习一下常见的 shell 命令，方便自己写一些简单的命令行脚本\n\n * 出于学习的目的，我并不希望自己钻研过深，只需要达到足以应付实践的水平。",normalizedContent:"提示\n\n为了能够更好地适应前端项目的配置，以及给自己更大的可能性，我需要学习一下常见的 shell 命令，方便自己写一些简单的命令行脚本\n\n * 出于学习的目的，我并不希望自己钻研过深，只需要达到足以应付实践的水平。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"使用postman进行服务端开发",frontmatter:{title:"使用postman进行服务端开发",date:"2024-07-30T13:52:11.000Z",permalink:"/pages/1d60cd/",categories:["技术","NodeJS"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/03.NodeJS/02.%E4%BD%BF%E7%94%A8postman%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91.html",relativePath:"03.技术/03.NodeJS/02.使用postman进行服务端开发.md",key:"v-ba40a92e",path:"/pages/1d60cd/",headersStr:null,content:"提示\n\n在进行接口调试时，有时候前端没有对应的UI与接口调用，在浏览器端调试相对来说较为繁琐，而使用 postman 进行调试，可以快速判断接口逻辑是否有缺陷。\n\n\n# 使用 postman 进行调试\n\n * 从官网下载 postman\n * 在 chorme 商店中下载 postman interceptor 插件\n   * 这个插件会自动获取进入对应域名下的 cookie 信息\n * 在 postman 中设置 Sync Cookie 的对应域名\n * 在浏览器中访问过对应地址后，即可凭借浏览器认证信息，使用 postman 进行对应域名的接口调试",normalizedContent:"提示\n\n在进行接口调试时，有时候前端没有对应的ui与接口调用，在浏览器端调试相对来说较为繁琐，而使用 postman 进行调试，可以快速判断接口逻辑是否有缺陷。\n\n\n# 使用 postman 进行调试\n\n * 从官网下载 postman\n * 在 chorme 商店中下载 postman interceptor 插件\n   * 这个插件会自动获取进入对应域名下的 cookie 信息\n * 在 postman 中设置 sync cookie 的对应域名\n * 在浏览器中访问过对应地址后，即可凭借浏览器认证信息，使用 postman 进行对应域名的接口调试",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"基础了解",frontmatter:{title:"基础了解",date:"2024-06-22T00:29:49.000Z",permalink:"/pages/453cda/",categories:["技术","shell"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.shell/02.%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3.html",relativePath:"03.技术/04.shell/02.基础了解.md",key:"v-6e816d0a",path:"/pages/453cda/",headers:[{level:2,title:"什么是Shell脚本",slug:"什么是shell脚本",normalizedTitle:"什么是shell脚本",charIndex:30},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:45},{level:3,title:"示例解释",slug:"示例解释",normalizedTitle:"示例解释",charIndex:158},{level:3,title:"shell和shell脚本的概念",slug:"shell和shell脚本的概念",normalizedTitle:"shell和shell脚本的概念",charIndex:396},{level:2,title:"环境",slug:"环境",normalizedTitle:"环境",charIndex:705},{level:3,title:"OS",slug:"os",normalizedTitle:"os",charIndex:770},{level:4,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:809},{level:4,title:"Mac OS",slug:"mac-os",normalizedTitle:"mac os",charIndex:857},{level:4,title:"Windows上的模拟器",slug:"windows上的模拟器",normalizedTitle:"windows上的模拟器",charIndex:965},{level:3,title:"脚本解释器",slug:"脚本解释器",normalizedTitle:"脚本解释器",charIndex:173},{level:4,title:"sh",slug:"sh",normalizedTitle:"sh",charIndex:64},{level:4,title:"bash",slug:"bash",normalizedTitle:"bash",charIndex:922},{level:4,title:"高级编程语言",slug:"高级编程语言",normalizedTitle:"高级编程语言",charIndex:2056},{level:2,title:"如何选择shell编程语言",slug:"如何选择shell编程语言",normalizedTitle:"如何选择shell编程语言",charIndex:2469},{level:3,title:"熟悉 vs 陌生",slug:"熟悉-vs-陌生",normalizedTitle:"熟悉 vs 陌生",charIndex:2487},{level:3,title:"简单 vs 高级",slug:"简单-vs-高级",normalizedTitle:"简单 vs 高级",charIndex:2666},{level:3,title:"环境兼容性",slug:"环境兼容性",normalizedTitle:"环境兼容性",charIndex:3003},{level:2,title:"第一个shell脚本",slug:"第一个shell脚本",normalizedTitle:"第一个shell脚本",charIndex:3150},{level:3,title:"编写",slug:"编写",normalizedTitle:"编写",charIndex:557},{level:3,title:"运行",slug:"运行",normalizedTitle:"运行",charIndex:3336},{level:4,title:"作为可执行程序",slug:"作为可执行程序",normalizedTitle:"作为可执行程序",charIndex:3359},{level:4,title:"作为解释器参数",slug:"作为解释器参数",normalizedTitle:"作为解释器参数",charIndex:3741},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:3859},{level:3,title:"定义变量",slug:"定义变量",normalizedTitle:"定义变量",charIndex:3866},{level:3,title:"使用变量",slug:"使用变量",normalizedTitle:"使用变量",charIndex:4006},{level:3,title:"重定义变量",slug:"重定义变量",normalizedTitle:"重定义变量",charIndex:4401},{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:4562},{level:3,title:"多行注释",slug:"多行注释",normalizedTitle:"多行注释",charIndex:4592},{level:2,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:5127},{level:3,title:"单引号",slug:"单引号",normalizedTitle:"单引号",charIndex:5186},{level:3,title:"双引号",slug:"双引号",normalizedTitle:"双引号",charIndex:5194},{level:3,title:"字符串操作",slug:"字符串操作",normalizedTitle:"字符串操作",charIndex:5443},{level:4,title:"拼接字符串",slug:"拼接字符串",normalizedTitle:"拼接字符串",charIndex:5452},{level:4,title:"获取字符串长度：",slug:"获取字符串长度",normalizedTitle:"获取字符串长度：",charIndex:5577},{level:4,title:"提取子字符串",slug:"提取子字符串",normalizedTitle:"提取子字符串",charIndex:5627},{level:4,title:"查找子字符串",slug:"查找子字符串",normalizedTitle:"查找子字符串",charIndex:5703},{level:4,title:"更多",slug:"更多",normalizedTitle:"更多",charIndex:5829},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:2897},{level:2,title:"管道",slug:"管道",normalizedTitle:"管道",charIndex:5899},{level:2,title:"条件判断",slug:"条件判断",normalizedTitle:"条件判断",charIndex:5906},{level:2,title:"流程控制",slug:"流程控制",normalizedTitle:"流程控制",charIndex:5915},{level:3,title:"if else",slug:"if-else",normalizedTitle:"if else",charIndex:6297},{level:4,title:"if",slug:"if",normalizedTitle:"if",charIndex:5959},{level:4,title:"if else",slug:"if-else-2",normalizedTitle:"if else",charIndex:6297},{level:4,title:"if else-if else",slug:"if-else-if-else",normalizedTitle:"if else-if else",charIndex:6550},{level:3,title:"for while",slug:"for-while",normalizedTitle:"for while",charIndex:6645},{level:4,title:"for",slug:"for",normalizedTitle:"for",charIndex:102},{level:4,title:"C风格的for",slug:"c风格的for",normalizedTitle:"c风格的for",charIndex:6829},{level:4,title:"while",slug:"while",normalizedTitle:"while",charIndex:6649},{level:4,title:"无限循环",slug:"无限循环",normalizedTitle:"无限循环",charIndex:6951},{level:4,title:"until",slug:"until",normalizedTitle:"until",charIndex:7040},{level:3,title:"case",slug:"case",normalizedTitle:"case",charIndex:7085},{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:2884},{level:3,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:2765},{level:3,title:"调用",slug:"调用",normalizedTitle:"调用",charIndex:2972},{level:2,title:"文件包含",slug:"文件包含",normalizedTitle:"文件包含",charIndex:7523},{level:2,title:"用户输入",slug:"用户输入",normalizedTitle:"用户输入",charIndex:7830},{level:3,title:"执行脚本时传入",slug:"执行脚本时传入",normalizedTitle:"执行脚本时传入",charIndex:7878},{level:3,title:"脚本运行中输入",slug:"脚本运行中输入",normalizedTitle:"脚本运行中输入",charIndex:7890},{level:3,title:"select菜单",slug:"select菜单",normalizedTitle:"select菜单",charIndex:7902},{level:2,title:"stdin和stdout",slug:"stdin和stdout",normalizedTitle:"stdin和stdout",charIndex:7915},{level:2,title:"常用的命令",slug:"常用的命令",normalizedTitle:"常用的命令",charIndex:7932},{level:3,title:"ps",slug:"ps",normalizedTitle:"ps",charIndex:470},{level:3,title:"grep",slug:"grep",normalizedTitle:"grep",charIndex:1015},{level:4,title:"排除grep自身",slug:"排除grep自身",normalizedTitle:"排除grep自身",charIndex:8057},{level:4,title:"查找与target相邻的结果",slug:"查找与target相邻的结果",normalizedTitle:"查找与target相邻的结果",charIndex:8069},{level:3,title:"awk",slug:"awk",normalizedTitle:"awk",charIndex:1021},{level:3,title:"sed",slug:"sed",normalizedTitle:"sed",charIndex:7976},{level:4,title:"插入",slug:"插入",normalizedTitle:"插入",charIndex:8020},{level:4,title:"替换",slug:"替换",normalizedTitle:"替换",charIndex:8109},{level:4,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:8022},{level:3,title:"xargs",slug:"xargs",normalizedTitle:"xargs",charIndex:8122},{level:3,title:"curl",slug:"curl",normalizedTitle:"curl",charIndex:1026},{level:2,title:"综合案例",slug:"综合案例",normalizedTitle:"综合案例",charIndex:8141},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5841}],headersStr:"什么是Shell脚本 示例 示例解释 shell和shell脚本的概念 环境 OS Linux Mac OS Windows上的模拟器 脚本解释器 sh bash 高级编程语言 如何选择shell编程语言 熟悉 vs 陌生 简单 vs 高级 环境兼容性 第一个shell脚本 编写 运行 作为可执行程序 作为解释器参数 变量 定义变量 使用变量 重定义变量 注释 多行注释 字符串 单引号 双引号 字符串操作 拼接字符串 获取字符串长度： 提取子字符串 查找子字符串 更多 数组 管道 条件判断 流程控制 if else if if else if else-if else for while for C风格的for while 无限循环 until case 函数 定义 调用 文件包含 用户输入 执行脚本时传入 脚本运行中输入 select菜单 stdin和stdout 常用的命令 ps grep 排除grep自身 查找与target相邻的结果 awk sed 插入 替换 删除 xargs curl 综合案例 参考资料",content:'提示\n\n以下内容非原创，摘自SHELL30分钟教程\n\n\n# 什么是Shell脚本\n\n\n# 示例\n\n看个例子吧：\n\n#!/bin/sh\ncd ~\nmkdir shell_tut\ncd shell_tut\n\nfor ((i=0; i<10; i++)); do\n\ttouch test_$i.txt\ndone\n\n\n\n# 示例解释\n\n * 第1行：指定脚本解释器，这里是用/bin/sh做解释器的\n * 第2行：切换到当前用户的home目录\n * 第3行：创建一个目录shell_tut\n * 第4行：切换到shell_tut目录\n * 第5行：循环条件，一共循环10次\n * 第6行：创建一个test_0…9.txt文件\n * 第7行：循环体结束\n\nmkdir, touch都是系统自带的程序，一般在/bin或者/usr/bin目录下。for, do, done是sh脚本语言的关键字。\n\n\n# shell和shell脚本的概念\n\nshell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。\n\nshell脚本（shell script），是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）。\n\n\n# 环境\n\nshell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。\n\n\n# OS\n\n当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。\n\n# Linux\n\nLinux默认安装就带了shell解释器。\n\n# Mac OS\n\nMac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。\n\n# Windows上的模拟器\n\nwindows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。\n\n * cygwin\n * mingw\n\n\n# 脚本解释器\n\n# sh\n\n即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。\n\n本文讲的是sh，如果你使用其它语言用作shell编程，请自行参考相应语言的文档。\n\n# bash\n\nBash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。\n\n在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:\n\n[root@centosraw ~]# ls -l /bin/*sh\n-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash\n-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dash\nlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -> bash\n\n\n但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:\n\niMac:~ wuxiao$ ls -l /bin/*sh\n-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash\n-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh\n-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh\n-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh\n-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh\n-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh\n\n\n# 高级编程语言\n\n理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。\n\n编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。\n\n如下是一个PHP Shell Script示例（假设文件名叫test.php）：\n\n#!/usr/bin/php\n<?php\nfor ($i=0; $i < 10; $i++)\n        echo $i . "\\n";\n\n\n执行：\n\n/usr/bin/php test.php\n\n\n或者：\n\nchmod +x test.php\n./test.php\n\n\n\n# 如何选择shell编程语言\n\n\n# 熟悉 vs 陌生\n\n如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。\n\n新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。\n\n\n# 简单 vs 高级\n\n如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。\n\nshell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：\n\n * 它的函数只能返回字串，无法返回数组\n * 它不支持面向对象，你无法实现一些优雅的设计模式\n * 它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错\n\n\n# 环境兼容性\n\n如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。\n\n\n# 第一个shell脚本\n\n\n# 编写\n\n打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。\n\n输入一些代码，第一行一般是这样：\n\n#!/bin/bash\n#!/usr/bin/php\n\n\n“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。\n\n\n# 运行\n\n运行Shell脚本有两种方法：\n\n# 作为可执行程序\n\nchmod +x test.sh\n./test.sh\n\n\n注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。\n\n通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。\n\n这里的"系统"，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。\n\n# 作为解释器参数\n\n这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：\n\n/bin/sh test.sh\n/bin/php test.php\n\n\n这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。\n\n\n# 变量\n\n\n# 定义变量\n\n定义变量时，变量名不加美元符号（$），如：\n\nyour_name="qinjx"\n\n\n注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。\n\n除了显式地直接赋值，还可以用语句给变量赋值，如：\n\nfor file in `ls /etc`\n\n\n\n# 使用变量\n\n使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\n\nyour_name="qinjx"\necho $your_name\necho ${your_name}\n\n\n变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\n\nfor skill in Ada Coffe Action Java; do\n\techo "I am good at ${skill}Script"\ndone\n\n\n如果不给skill变量加花括号，写成echo "I am good at $skillScript"，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。\n\n推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。\n\n\n# 重定义变量\n\n已定义的变量，可以被重新定义，如：\n\nyour_name="qinjx"\necho $your_name\n\nyour_name="alibaba"\necho $your_name\n\n\n这样写是合法的，但注意，第二次赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符。\n\n\n# 注释\n\n以“#”开头的行就是注释，会被解释器忽略。\n\n\n# 多行注释\n\nsh里没有多行注释，只能每一行加一个#号。就像这样：\n\n#--------------------------------------------\n# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：https://github.com/webfrogs/xcode_shell/blob/master/ipa-build\n\n# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包\n# 特色：全自动打包，不需要输入任何参数\n#--------------------------------------------\n\n##### 用户配置区 开始 #####\n#\n#\n# 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了\n# 应用名，确保和Xcode里Product下的target_name.app名字一致\n#\n##### 用户配置区 结束  #####\n\n\n如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。\n\n\n# 字符串\n\n字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。\n\n\n# 单引号\n\nstr=\'this is a string\'\n\n\n单引号字符串的限制：\n\n * 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的\n * 单引号字串中不能出现单引号（对单引号使用转义符后也不行）\n\n\n# 双引号\n\nyour_name=\'qinjx\'\nstr="Hello, I know your are \\"$your_name\\"! \\n"\n\n\n * 双引号里可以有变量\n * 双引号里可以出现转义字符\n\n\n# 字符串操作\n\n# 拼接字符串\n\nyour_name="qinjx"\ngreeting="hello, "$your_name" !"\ngreeting_1="hello, ${your_name} !"\n\necho $greeting $greeting_1\n\n\n# 获取字符串长度：\n\nstring="abcd"\necho ${#string} #输出：4\n\n\n# 提取子字符串\n\nstring="alibaba is a great company"\necho ${string:1:4} #输出：liba\n\n\n# 查找子字符串\n\nstring="alibaba is a great company"\necho `expr index "$string" is`#输出：3，这个语句的意思是：找出字母i在这名话中的位置，要在linux下运行，mac下会报错\n\n\n# 更多\n\n参见本文档末尾的参考资料中Advanced Bash-Scripting Guid Chapter 10.1\n\n\n# 数组\n\n\n# 管道\n\n\n# 条件判断\n\n\n# 流程控制\n\n和Java、PHP等语言不一样，sh的流程控制不可为空，如：\n\n<?php\nif (isset($_GET["q"])) {\n\tsearch(q);\n}\nelse {\n\t//do nothing\n}\n\n\n在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。\n\n还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟Java/PHP里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在CentOS上，它在/usr/bin目录下：\n\nll /usr/bin/[\n-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[\n\n\n正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]\n\n\n# if else\n\n# if\n\nif condition\nthen\n\tcommand1 \n\tcommand2\n\t...\n\tcommandN \nfi\n\n\n写成一行（适用于终端命令提示符）：\n\nif `ps -ef | grep ssh`;  then echo hello; fi\n\n\n末尾的fi就是if倒过来拼写，后面还会遇到类似的\n\n# if else\n\nif condition\nthen\n\tcommand1 \n\tcommand2\n\t...\n\tcommandN\nelse\n\tcommand\nfi\n\n\n# if else-if else\n\nif condition1\nthen\n\tcommand1\nelif condition2\n\tcommand2\nelse\n\tcommandN\nfi\n\n\n\n# for while\n\n# for\n\n在开篇的示例里演示过了：\n\nfor var in item1 item2 ... itemN\ndo\n\tcommand1\n\tcommand2\n\t...\n\tcommandN\ndone\n\n\n写成一行：\n\nfor var in item1 item2 ... itemN; do command1; command2… done;\n\n\n# C风格的for\n\nfor (( EXP1; EXP2; EXP3 ))\ndo\n\tcommand1\n\tcommand2\n\tcommand3\ndone\n\n\n# while\n\nwhile condition\ndo\n\tcommand\ndone\n\n\n# 无限循环\n\nwhile :\ndo\n\tcommand\ndone\n\n\n或者\n\nwhile true\ndo\n\tcommand\ndone\n\n\n或者\n\nfor (( ; ; ))\n\n\n# until\n\nuntil condition\ndo\n\tcommand\ndone\n\n\n\n# case\n\ncase "${opt}" in\n\t"Install-Puppet-Server" )\n\t\tinstall_master $1\n\t\texit\n\t;;\n\n\t"Install-Puppet-Client" )\n\t\tinstall_client $1\n\t\texit\n\t;;\n\n\t"Config-Puppet-Server" )\n\t\tconfig_puppet_master\n\t\texit\n\t;;\n\n\t"Config-Puppet-Client" )\n\t\tconfig_puppet_client\n\t\texit\n\t;;\n\n\t"Exit" )\n\t\texit\n\t;;\n\n\t* ) echo "Bad option, please choose again"\nesac\n\n\ncase的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break\n\n\n# 函数\n\n\n# 定义\n\n\n# 调用\n\n\n# 文件包含\n\n可以使用source和.关键字，如：\n\nsource ./function.sh\n. ./function.sh\n\n\n在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似PHP里的include），为了更好的可移植性，推荐使用第二种写法。\n\n包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:\n\n. ./function.sh\n\n\n不可以写作：\n\n. function.sh\n\n\n如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：\n\nreal_path=`readlink -f $1`#$1是用户输入的参数，如function.sh\n. $real_path\n\n\n\n# 用户输入\n\n\n# 执行脚本时传入\n\n\n# 脚本运行中输入\n\n\n# select菜单\n\n\n# stdin和stdout\n\n\n# 常用的命令\n\nsh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。\n\n\n# ps\n\n查看进程列表\n\n\n# grep\n\n# 排除grep自身\n\n# 查找与target相邻的结果\n\n\n# awk\n\n\n# sed\n\n# 插入\n\n# 替换\n\n# 删除\n\n\n# xargs\n\n\n# curl\n\n\n# 综合案例\n\n\n# 参考资料\n\n * Advanced Bash-Scripting Guide，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅\n * Unix Shell Programming\n * Linux Shell Scripting Tutorial - A Beginner\'s handbook',normalizedContent:'提示\n\n以下内容非原创，摘自shell30分钟教程\n\n\n# 什么是shell脚本\n\n\n# 示例\n\n看个例子吧：\n\n#!/bin/sh\ncd ~\nmkdir shell_tut\ncd shell_tut\n\nfor ((i=0; i<10; i++)); do\n\ttouch test_$i.txt\ndone\n\n\n\n# 示例解释\n\n * 第1行：指定脚本解释器，这里是用/bin/sh做解释器的\n * 第2行：切换到当前用户的home目录\n * 第3行：创建一个目录shell_tut\n * 第4行：切换到shell_tut目录\n * 第5行：循环条件，一共循环10次\n * 第6行：创建一个test_0…9.txt文件\n * 第7行：循环体结束\n\nmkdir, touch都是系统自带的程序，一般在/bin或者/usr/bin目录下。for, do, done是sh脚本语言的关键字。\n\n\n# shell和shell脚本的概念\n\nshell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。ken thompson的sh是第一种unix shell，windows explorer是一个典型的图形界面shell。\n\nshell脚本（shell script），是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如windows explorer扩展开发）。\n\n\n# 环境\n\nshell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。\n\n\n# os\n\n当前主流的操作系统都支持shell编程，本文档所述的shell编程是指linux下的shell，讲的基本都是posix标准下的功能，所以，也适用于unix及bsd（如mac os）。\n\n# linux\n\nlinux默认安装就带了shell解释器。\n\n# mac os\n\nmac os不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。\n\n# windows上的模拟器\n\nwindows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。\n\n * cygwin\n * mingw\n\n\n# 脚本解释器\n\n# sh\n\n即bourne shell，posix（portable operating system interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由bell labs开发。\n\n本文讲的是sh，如果你使用其它语言用作shell编程，请自行参考相应语言的文档。\n\n# bash\n\nbash是bourne shell的替代品，属gnu project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉linux bash编程，精通shell编程。\n\n在centos里，/bin/sh是一个指向/bin/bash的符号链接:\n\n[root@centosraw ~]# ls -l /bin/*sh\n-rwxr-xr-x. 1 root root 903272 feb 22 05:09 /bin/bash\n-rwxr-xr-x. 1 root root 106216 oct 17  2012 /bin/dash\nlrwxrwxrwx. 1 root root      4 mar 22 10:22 /bin/sh -> bash\n\n\n但在mac os上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:\n\nimac:~ wuxiao$ ls -l /bin/*sh\n-r-xr-xr-x  1 root  wheel  1371648  6 nov 16:52 /bin/bash\n-rwxr-xr-x  2 root  wheel   772992  6 nov 16:52 /bin/csh\n-r-xr-xr-x  1 root  wheel  2180736  6 nov 16:52 /bin/ksh\n-r-xr-xr-x  1 root  wheel  1371712  6 nov 16:52 /bin/sh\n-rwxr-xr-x  2 root  wheel   772992  6 nov 16:52 /bin/tcsh\n-rwxr-xr-x  1 root  wheel  1103984  6 nov 16:52 /bin/zsh\n\n\n# 高级编程语言\n\n理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：perl、tcl、python、php、ruby。perl是最老牌的脚本编程语言了，python这些年也成了一些linux发行版的预置解释器。\n\n编译型语言，只要有解释器，也可以用作脚本编程，如c shell是内置的（/bin/csh），java有第三方解释器jshell，ada有收费的解释器adascript。\n\n如下是一个php shell script示例（假设文件名叫test.php）：\n\n#!/usr/bin/php\n<?php\nfor ($i=0; $i < 10; $i++)\n        echo $i . "\\n";\n\n\n执行：\n\n/usr/bin/php test.php\n\n\n或者：\n\nchmod +x test.php\n./test.php\n\n\n\n# 如何选择shell编程语言\n\n\n# 熟悉 vs 陌生\n\n如果你已经掌握了一门编程语言（如php、python、java、javascript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、ide、第三方类库）。\n\n新增的学习成本很小，只要学会怎么使用shell解释器（jshell、adascript）就可以了。\n\n\n# 简单 vs 高级\n\n如果你觉得自己熟悉的语言（如java、c）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。\n\nshell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用python、perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：\n\n * 它的函数只能返回字串，无法返回数组\n * 它不支持面向对象，你无法实现一些优雅的设计模式\n * 它是解释型的，一边解释一边执行，连php那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错\n\n\n# 环境兼容性\n\n如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。\n\n\n# 第一个shell脚本\n\n\n# 编写\n\n打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。\n\n输入一些代码，第一行一般是这样：\n\n#!/bin/bash\n#!/usr/bin/php\n\n\n“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。\n\n\n# 运行\n\n运行shell脚本有两种方法：\n\n# 作为可执行程序\n\nchmod +x test.sh\n./test.sh\n\n\n注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去path里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在path里，你的当前目录通常不在path里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。\n\n通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。\n\n这里的"系统"，其实就是shell这个应用程序（想象一下windows explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。\n\n# 作为解释器参数\n\n这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：\n\n/bin/sh test.sh\n/bin/php test.php\n\n\n这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。\n\n\n# 变量\n\n\n# 定义变量\n\n定义变量时，变量名不加美元符号（$），如：\n\nyour_name="qinjx"\n\n\n注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。\n\n除了显式地直接赋值，还可以用语句给变量赋值，如：\n\nfor file in `ls /etc`\n\n\n\n# 使用变量\n\n使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\n\nyour_name="qinjx"\necho $your_name\necho ${your_name}\n\n\n变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\n\nfor skill in ada coffe action java; do\n\techo "i am good at ${skill}script"\ndone\n\n\n如果不给skill变量加花括号，写成echo "i am good at $skillscript"，解释器就会把$skillscript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。\n\n推荐给所有变量加上花括号，这是个好的编程习惯。intellij idea编写shell script时，ide就会提示加花括号。\n\n\n# 重定义变量\n\n已定义的变量，可以被重新定义，如：\n\nyour_name="qinjx"\necho $your_name\n\nyour_name="alibaba"\necho $your_name\n\n\n这样写是合法的，但注意，第二次赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符。\n\n\n# 注释\n\n以“#”开头的行就是注释，会被解释器忽略。\n\n\n# 多行注释\n\nsh里没有多行注释，只能每一行加一个#号。就像这样：\n\n#--------------------------------------------\n# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：https://github.com/webfrogs/xcode_shell/blob/master/ipa-build\n\n# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包\n# 特色：全自动打包，不需要输入任何参数\n#--------------------------------------------\n\n##### 用户配置区 开始 #####\n#\n#\n# 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了\n# 应用名，确保和xcode里product下的target_name.app名字一致\n#\n##### 用户配置区 结束  #####\n\n\n如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。\n\n\n# 字符串\n\n字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟php类似。\n\n\n# 单引号\n\nstr=\'this is a string\'\n\n\n单引号字符串的限制：\n\n * 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的\n * 单引号字串中不能出现单引号（对单引号使用转义符后也不行）\n\n\n# 双引号\n\nyour_name=\'qinjx\'\nstr="hello, i know your are \\"$your_name\\"! \\n"\n\n\n * 双引号里可以有变量\n * 双引号里可以出现转义字符\n\n\n# 字符串操作\n\n# 拼接字符串\n\nyour_name="qinjx"\ngreeting="hello, "$your_name" !"\ngreeting_1="hello, ${your_name} !"\n\necho $greeting $greeting_1\n\n\n# 获取字符串长度：\n\nstring="abcd"\necho ${#string} #输出：4\n\n\n# 提取子字符串\n\nstring="alibaba is a great company"\necho ${string:1:4} #输出：liba\n\n\n# 查找子字符串\n\nstring="alibaba is a great company"\necho `expr index "$string" is`#输出：3，这个语句的意思是：找出字母i在这名话中的位置，要在linux下运行，mac下会报错\n\n\n# 更多\n\n参见本文档末尾的参考资料中advanced bash-scripting guid chapter 10.1\n\n\n# 数组\n\n\n# 管道\n\n\n# 条件判断\n\n\n# 流程控制\n\n和java、php等语言不一样，sh的流程控制不可为空，如：\n\n<?php\nif (isset($_get["q"])) {\n\tsearch(q);\n}\nelse {\n\t//do nothing\n}\n\n\n在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。\n\n还要注意，sh里的if [ $foo -eq 0 ]，这个方括号跟java/php里if后面的圆括号大不相同，它是一个可执行程序（和ls, grep一样），想不到吧？在centos上，它在/usr/bin目录下：\n\nll /usr/bin/[\n-rwxr-xr-x. 1 root root 33408 6月  22 2012 /usr/bin/[\n\n\n正因为方括号在这里是一个可执行程序，方括号后面必须加空格，不能写成if [$foo -eq 0]\n\n\n# if else\n\n# if\n\nif condition\nthen\n\tcommand1 \n\tcommand2\n\t...\n\tcommandn \nfi\n\n\n写成一行（适用于终端命令提示符）：\n\nif `ps -ef | grep ssh`;  then echo hello; fi\n\n\n末尾的fi就是if倒过来拼写，后面还会遇到类似的\n\n# if else\n\nif condition\nthen\n\tcommand1 \n\tcommand2\n\t...\n\tcommandn\nelse\n\tcommand\nfi\n\n\n# if else-if else\n\nif condition1\nthen\n\tcommand1\nelif condition2\n\tcommand2\nelse\n\tcommandn\nfi\n\n\n\n# for while\n\n# for\n\n在开篇的示例里演示过了：\n\nfor var in item1 item2 ... itemn\ndo\n\tcommand1\n\tcommand2\n\t...\n\tcommandn\ndone\n\n\n写成一行：\n\nfor var in item1 item2 ... itemn; do command1; command2… done;\n\n\n# c风格的for\n\nfor (( exp1; exp2; exp3 ))\ndo\n\tcommand1\n\tcommand2\n\tcommand3\ndone\n\n\n# while\n\nwhile condition\ndo\n\tcommand\ndone\n\n\n# 无限循环\n\nwhile :\ndo\n\tcommand\ndone\n\n\n或者\n\nwhile true\ndo\n\tcommand\ndone\n\n\n或者\n\nfor (( ; ; ))\n\n\n# until\n\nuntil condition\ndo\n\tcommand\ndone\n\n\n\n# case\n\ncase "${opt}" in\n\t"install-puppet-server" )\n\t\tinstall_master $1\n\t\texit\n\t;;\n\n\t"install-puppet-client" )\n\t\tinstall_client $1\n\t\texit\n\t;;\n\n\t"config-puppet-server" )\n\t\tconfig_puppet_master\n\t\texit\n\t;;\n\n\t"config-puppet-client" )\n\t\tconfig_puppet_client\n\t\texit\n\t;;\n\n\t"exit" )\n\t\texit\n\t;;\n\n\t* ) echo "bad option, please choose again"\nesac\n\n\ncase的语法和c family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break\n\n\n# 函数\n\n\n# 定义\n\n\n# 调用\n\n\n# 文件包含\n\n可以使用source和.关键字，如：\n\nsource ./function.sh\n. ./function.sh\n\n\n在bash里，source和.是等效的，他们都是读入function.sh的内容并执行其内容（类似php里的include），为了更好的可移植性，推荐使用第二种写法。\n\n包含一个文件和执行一个文件一样，也要写这个文件的路径，不能光写文件名，比如上述例子中:\n\n. ./function.sh\n\n\n不可以写作：\n\n. function.sh\n\n\n如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：\n\nreal_path=`readlink -f $1`#$1是用户输入的参数，如function.sh\n. $real_path\n\n\n\n# 用户输入\n\n\n# 执行脚本时传入\n\n\n# 脚本运行中输入\n\n\n# select菜单\n\n\n# stdin和stdout\n\n\n# 常用的命令\n\nsh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。\n\n\n# ps\n\n查看进程列表\n\n\n# grep\n\n# 排除grep自身\n\n# 查找与target相邻的结果\n\n\n# awk\n\n\n# sed\n\n# 插入\n\n# 替换\n\n# 删除\n\n\n# xargs\n\n\n# curl\n\n\n# 综合案例\n\n\n# 参考资料\n\n * advanced bash-scripting guide，非常详细，非常易读，大量example，既可以当入门教材，也可以当做工具书查阅\n * unix shell programming\n * linux shell scripting tutorial - a beginner\'s handbook',charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"前言",frontmatter:{title:"前言",date:"2024-07-09T18:58:34.000Z",permalink:"/pages/9a9b72/",categories:["技术","vscode开发"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.vscode%E5%BC%80%E5%8F%91/01.%E5%89%8D%E8%A8%80.html",relativePath:"03.技术/05.vscode开发/01.前言.md",key:"v-b5138e64",path:"/pages/9a9b72/",headersStr:null,content:"提示\n\n最近的工作涉及到了 vscode 插件开发，许多知识还不太了解，为了减少自己的知识盲区，特此学习 vscode 插件开发\n\n * 面向业务的学习，只看对应的 API",normalizedContent:"提示\n\n最近的工作涉及到了 vscode 插件开发，许多知识还不太了解，为了减少自己的知识盲区，特此学习 vscode 插件开发\n\n * 面向业务的学习，只看对应的 api",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"vscode的command",frontmatter:{title:"vscode的command",date:"2024-07-09T19:00:44.000Z",permalink:"/pages/16af6e/",categories:["技术","vscode开发"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.vscode%E5%BC%80%E5%8F%91/02.vscode%E7%9A%84command.html",relativePath:"03.技术/05.vscode开发/02.vscode的command.md",key:"v-29605e9b",path:"/pages/16af6e/",headers:[{level:3,title:"Using Commands",slug:"using-commands",normalizedTitle:"using commands",charIndex:2},{level:3,title:"Command Uris",slug:"command-uris",normalizedTitle:"command uris",charIndex:180},{level:3,title:"创建命令",slug:"创建命令",normalizedTitle:"创建命令",charIndex:242},{level:4,title:"注册命令",slug:"注册命令",normalizedTitle:"注册命令",charIndex:250},{level:4,title:"控制面板",slug:"控制面板",normalizedTitle:"控制面板",charIndex:286}],headersStr:"Using Commands Command Uris 创建命令 注册命令 控制面板",content:"# Using Commands\n\n * vscode 提供了一些 built-in 的功能，可以直接使用 vscode.commands.excuteCommand 方法调用\n   * 如 editor.action.addCommentLine 加入一行评论\n   * vscode.excuteDefinitionProvider 提供注解功能\n\n\n# Command Uris\n\n * URI 是 vscode 插件的内部协议实现，是 vscode 插件中信息的载体\n\n\n# 创建命令\n\n# 注册命令\n\n * 在插件激活周期中将对应的命令绑定在插件上下文上\n\n# 控制面板\n\n * 想要命令出现在控制面板上时可以通过配置 contributes\n * 想要命令按需显示，可以按照 vscodereferencce 配置对应的 when",normalizedContent:"# using commands\n\n * vscode 提供了一些 built-in 的功能，可以直接使用 vscode.commands.excutecommand 方法调用\n   * 如 editor.action.addcommentline 加入一行评论\n   * vscode.excutedefinitionprovider 提供注解功能\n\n\n# command uris\n\n * uri 是 vscode 插件的内部协议实现，是 vscode 插件中信息的载体\n\n\n# 创建命令\n\n# 注册命令\n\n * 在插件激活周期中将对应的命令绑定在插件上下文上\n\n# 控制面板\n\n * 想要命令出现在控制面板上时可以通过配置 contributes\n * 想要命令按需显示，可以按照 vscodereferencce 配置对应的 when",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"学习阮一峰bash教程",frontmatter:{title:"学习阮一峰bash教程",date:"2024-06-22T00:46:40.000Z",permalink:"/pages/d72ce4/",categories:["技术","shell"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.shell/03.%E5%AD%A6%E4%B9%A0%E9%98%AE%E4%B8%80%E5%B3%B0bash%E6%95%99%E7%A8%8B.html",relativePath:"03.技术/04.shell/03.学习阮一峰bash教程.md",key:"v-5d1debe1",path:"/pages/d72ce4/",headers:[{level:4,title:"命令格式",slug:"命令格式",normalizedTitle:"命令格式",charIndex:31},{level:4,title:"命令组合符",slug:"命令组合符",normalizedTitle:"命令组合符",charIndex:109},{level:4,title:"模式扩展",slug:"模式扩展",normalizedTitle:"模式扩展",charIndex:200},{level:4,title:"量词语法",slug:"量词语法",normalizedTitle:"量词语法",charIndex:1736},{level:4,title:"shopt 命令",slug:"shopt-命令",normalizedTitle:"shopt 命令",charIndex:2594}],headersStr:"命令格式 命令组合符 模式扩展 量词语法 shopt 命令",content:"提示\n\n阮一峰的bash教程，地址在阮一峰Bash教程\n\n# 命令格式\n\n * bash 的命令格式总是这样的：command [arg1 ... [argN]]\n * 参数有长短形式，-l 等同于 -list\n\n# 命令组合符\n\n * && 表示前一个命令执行成功后，才执行后一个命令\n * || 表示前一个命令执行失败后，才执行后一个命令\n * ; 表示两个命令都执行，但并不关心执行结果\n\n# 模式扩展\n\n * ? 扩展，匹配任意一个字符，可以连用，例如 ??.txt\n * * 扩展，匹配任意多个字符\n   * .* 用来匹配隐藏文件，.[!.]* 用来匹配除了 . 和 .. 之外的所有文件\n   * Bash 4.0 引入了一个参数globstar，当该参数打开时，允许**匹配零个或多个子目录。因此，**/*.txt可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面shopt命令的介绍。\n * 方括号扩展，匹配任意一个字符，同正则，可以使用范围，如[a-z]\n * 花括号扩展，扩展一个字符为给定的值，如 d{a,e,i,o,u}g 会变为 dag,deg,dig,dag,dug\n   * ,前面可以没有值，表示空\n   * 花括号扩展可以与其他模式共用，且总是领先于其他模式\n   * {a..b..c}，会扩展为a-b，步长为c的序列\n   * 多个扩展连用，会有类似循环的效果\n     * echo {a..c}{1..3}，输出 a1 a2 a3 b1 b2 b3 c1 c2 c3\n * ${!string*}或${!string@}返回所有匹配给定字符串string的变量名。\n * $(...) 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。\n\n$ echo $(date)\nTue Jan 28 00:01:13 CST 2020\n\n\n1\n2\n\n\n上面例子中，$(date) 返回 date 命令的运行结果。\n\n还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。\n\n$ echo `date`\nTue Jan 28 00:01:13 CST 2020\n\n\n1\n2\n\n\n$(...)可以嵌套，比如$(ls $(pwd))。\n\n$((...))可以扩展成整数运算的结果。\n\n$ echo $((2 + 2))\n4\n\n\n1\n2\n\n * [[:class:]]表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。\n\n[[:alnum:]]：匹配任意英文字母与数字\n[[:alpha:]]：匹配任意英文字母\n[[:blank:]]：空格和 Tab 键。\n[[:cntrl:]]：ASCII 码 0-31 的不可打印字符。\n[[:digit:]]：匹配任意数字 0-9。\n[[:graph:]]：A-Z、a-z、0-9 和标点符号。\n[[:lower:]]：匹配任意小写字母 a-z。\n[[:print:]]：ASCII 码 32-127 的可打印字符。\n[[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。\n[[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。\n[[:upper:]]：匹配任意大写字母 A-Z。\n[[:xdigit:]]：16进制字符（A-F、a-f、0-9）。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n请看下面的例子。\n\n$ echo [[:upper:]]*\n\n\n1\n\n\n上面命令输出所有大写字母开头的文件名。\n\n字符类的第一个方括号后面，可以加上感叹号!（或^），表示否定。比如，![:digit:]匹配所有非数字。\n\n$ echo [![:digit:]]*\n\n\n1\n\n\n上面命令输出所有不以数字开头的文件名。\n\n字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。\n\n不存在以大写字母开头的文件\n\n$ echo [[:upper:]]*\n[[:upper:]]*\n\n\n1\n2\n\n\n上面例子中，由于没有可匹配的文件，字符类就原样输出了。\n\n# 量词语法\n\n量词语法用来控制模式匹配的次数。它只有在 Bash 的extglob参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。\n\n$ shopt extglob\nextglob        \ton\n\n\n1\n2\n\n\n如果extglob参数是关闭的，可以用下面的命令打开。\n\n$ shopt -s extglob 量词语法有下面几个。\n\n?(pattern-list)：模式匹配零次或一次。\n*(pattern-list)：模式匹配零次或多次。\n+(pattern-list)：模式匹配一次或多次。\n@(pattern-list)：只匹配一次模式。\n!(pattern-list)：匹配给定模式以外的任何内容。\n\n\n1\n2\n3\n4\n5\n\n\n$ ls abc?(.)txt\nabctxt abc.txt\n\n\n1\n2\n\n\n上面例子中，?(.)匹配零个或一个点。\n\n$ ls abc?(def)\nabc abcdef\n\n\n1\n2\n\n\n上面例子中，?(def)匹配零个或一个def。\n\n$ ls abc@(.txt|.php)\nabc.php abc.txt\n\n\n1\n2\n\n\n上面例子中，@(.txt|.php)匹配文件有且只有一个.txt或.php后缀名。\n\n$ ls abc+(.txt)\nabc.txt abc.txt.txt\n\n\n1\n2\n\n\n上面例子中，+(.txt)匹配文件有一个或多个.txt后缀名。\n\n$ ls a!(b).txt\na.txt abb.txt ac.txt\n\n\n1\n2\n\n\n上面例子中，!(b)表示匹配单个字母b以外的任意内容，所以除了ab.txt以外，其他文件名都能匹配。\n\n量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。\n\n没有 abc 开头的文件名\n\n$ ls abc?(def)\nls: 无法访问'abc?(def)': 没有那个文件或目录\n\n\n1\n2\n\n\n上面例子中，由于没有可匹配的文件，abc?(def)就原样输出，导致ls命令报错。\n\n# shopt 命令\n\nshopt命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。\n\nshopt命令的使用方法如下。\n\n打开某个参数\n\n$ shopt -s [optionname]\n\n\n1\n\n\n关闭某个参数\n\n$ shopt -u [optionname]\n\n\n1\n\n\n查询某个参数关闭还是打开\n\n$ shopt [optionname]\n\n\n1\n\n 1. dotglob 参数\n\ndotglob参数可以让扩展结果包括隐藏文件（即点开头的文件）。\n\n正常情况下，扩展结果不包括隐藏文件。\n\n$ ls *\nabc.txt\n\n\n1\n2\n\n\n打开dotglob，就会包括隐藏文件。\n\n$ shopt -s dotglob\n$ ls *\nabc.txt .config\n\n\n1\n2\n3\n\n 2. nullglob 参数\n\nnullglob参数可以让通配符不匹配任何文件名时，返回空字符。\n\n默认情况下，通配符不匹配任何文件名时，会保持不变。\n\n$ rm b*\nrm: 无法删除'b*': 没有那个文件或目录\n\n\n1\n2\n\n\n上面例子中，由于当前目录不包括b开头的文件名，导致b*不会发生文件名扩展，保持原样不变，所以rm命令报错没有b*这个文件。\n\n打开nullglob参数，就可以让不匹配的通配符返回空字符串。\n\n$ shopt -s nullglob\n$ rm b*\nrm: 缺少操作数\n\n\n1\n2\n3\n\n\n上面例子中，由于没有b*匹配的文件名，所以rm b*扩展成了rm，导致报错变成了”缺少操作数“。\n\n 3. failglob 参数\n\nfailglob参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。\n\n$ shopt -s failglob\n$ rm b*\nbash: 无匹配: b*\n\n\n1\n2\n3\n\n\n上面例子中，打开failglob以后，由于b*不匹配任何文件名，Bash 直接报错了，不再让rm命令去处理。\n\n 4. extglob 参数\n\nextglob参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。\n\n$ shopt extglob\nextglob        \ton\n\n\n1\n2\n\n\n它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。\n\n$ shopt -u extglob\n\n\n1\n\n 5. nocaseglob 参数\n\nnocaseglob参数可以让通配符扩展不区分大小写。\n\n$ shopt -s nocaseglob\n$ ls /windows/program*\n/windows/ProgramData\n/windows/Program Files\n/windows/Program Files (x86)\n\n\n1\n2\n3\n4\n5\n\n\n上面例子中，打开nocaseglob以后，program*就不区分大小写了，可以匹配ProgramData等。\n\n 6. globstar 参数\n\nglobstar参数可以使得**匹配零个或多个子目录。该参数默认是关闭的。\n\n假设有下面的文件结构。\n\na.txt sub1/b.txt sub1/sub2/c.txt 上面的文件结构中，顶层目录、第一级子目录sub1、第二级子目录sub1\\sub2里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来？\n\n默认情况下，只能写成下面这样。\n\n$ ls *.txt */*.txt */*/*.txt\na.txt  sub1/b.txt  sub1/sub2/c.txt\n\n\n1\n2\n\n\n这是因为*只匹配当前目录，如果要匹配子目录，只能一层层写出来。\n\n打开globstar参数以后，匹配零个或多个子目录。因此，/*.txt就可以得到想要的结果。\n\n$ shopt -s globstar\n$ ls **/*.txt\na.txt  sub1/b.txt  sub1/sub2/c.txt\n\n\n1\n2\n3\n\n\n提示\n\n在阅读过程中发现，bash的教程对我并没有太大的工作上的帮助，剩余的内容我将阅读，不做整理，必要时查阅教程。",normalizedContent:"提示\n\n阮一峰的bash教程，地址在阮一峰bash教程\n\n# 命令格式\n\n * bash 的命令格式总是这样的：command [arg1 ... [argn]]\n * 参数有长短形式，-l 等同于 -list\n\n# 命令组合符\n\n * && 表示前一个命令执行成功后，才执行后一个命令\n * || 表示前一个命令执行失败后，才执行后一个命令\n * ; 表示两个命令都执行，但并不关心执行结果\n\n# 模式扩展\n\n * ? 扩展，匹配任意一个字符，可以连用，例如 ??.txt\n * * 扩展，匹配任意多个字符\n   * .* 用来匹配隐藏文件，.[!.]* 用来匹配除了 . 和 .. 之外的所有文件\n   * bash 4.0 引入了一个参数globstar，当该参数打开时，允许**匹配零个或多个子目录。因此，**/*.txt可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面shopt命令的介绍。\n * 方括号扩展，匹配任意一个字符，同正则，可以使用范围，如[a-z]\n * 花括号扩展，扩展一个字符为给定的值，如 d{a,e,i,o,u}g 会变为 dag,deg,dig,dag,dug\n   * ,前面可以没有值，表示空\n   * 花括号扩展可以与其他模式共用，且总是领先于其他模式\n   * {a..b..c}，会扩展为a-b，步长为c的序列\n   * 多个扩展连用，会有类似循环的效果\n     * echo {a..c}{1..3}，输出 a1 a2 a3 b1 b2 b3 c1 c2 c3\n * ${!string*}或${!string@}返回所有匹配给定字符串string的变量名。\n * $(...) 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。\n\n$ echo $(date)\ntue jan 28 00:01:13 cst 2020\n\n\n1\n2\n\n\n上面例子中，$(date) 返回 date 命令的运行结果。\n\n还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。\n\n$ echo `date`\ntue jan 28 00:01:13 cst 2020\n\n\n1\n2\n\n\n$(...)可以嵌套，比如$(ls $(pwd))。\n\n$((...))可以扩展成整数运算的结果。\n\n$ echo $((2 + 2))\n4\n\n\n1\n2\n\n * [[:class:]]表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。\n\n[[:alnum:]]：匹配任意英文字母与数字\n[[:alpha:]]：匹配任意英文字母\n[[:blank:]]：空格和 tab 键。\n[[:cntrl:]]：ascii 码 0-31 的不可打印字符。\n[[:digit:]]：匹配任意数字 0-9。\n[[:graph:]]：a-z、a-z、0-9 和标点符号。\n[[:lower:]]：匹配任意小写字母 a-z。\n[[:print:]]：ascii 码 32-127 的可打印字符。\n[[:punct:]]：标点符号（除了 a-z、a-z、0-9 的可打印字符）。\n[[:space:]]：空格、tab、lf（10）、vt（11）、ff（12）、cr（13）。\n[[:upper:]]：匹配任意大写字母 a-z。\n[[:xdigit:]]：16进制字符（a-f、a-f、0-9）。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n请看下面的例子。\n\n$ echo [[:upper:]]*\n\n\n1\n\n\n上面命令输出所有大写字母开头的文件名。\n\n字符类的第一个方括号后面，可以加上感叹号!（或^），表示否定。比如，![:digit:]匹配所有非数字。\n\n$ echo [![:digit:]]*\n\n\n1\n\n\n上面命令输出所有不以数字开头的文件名。\n\n字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。\n\n不存在以大写字母开头的文件\n\n$ echo [[:upper:]]*\n[[:upper:]]*\n\n\n1\n2\n\n\n上面例子中，由于没有可匹配的文件，字符类就原样输出了。\n\n# 量词语法\n\n量词语法用来控制模式匹配的次数。它只有在 bash 的extglob参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。\n\n$ shopt extglob\nextglob        \ton\n\n\n1\n2\n\n\n如果extglob参数是关闭的，可以用下面的命令打开。\n\n$ shopt -s extglob 量词语法有下面几个。\n\n?(pattern-list)：模式匹配零次或一次。\n*(pattern-list)：模式匹配零次或多次。\n+(pattern-list)：模式匹配一次或多次。\n@(pattern-list)：只匹配一次模式。\n!(pattern-list)：匹配给定模式以外的任何内容。\n\n\n1\n2\n3\n4\n5\n\n\n$ ls abc?(.)txt\nabctxt abc.txt\n\n\n1\n2\n\n\n上面例子中，?(.)匹配零个或一个点。\n\n$ ls abc?(def)\nabc abcdef\n\n\n1\n2\n\n\n上面例子中，?(def)匹配零个或一个def。\n\n$ ls abc@(.txt|.php)\nabc.php abc.txt\n\n\n1\n2\n\n\n上面例子中，@(.txt|.php)匹配文件有且只有一个.txt或.php后缀名。\n\n$ ls abc+(.txt)\nabc.txt abc.txt.txt\n\n\n1\n2\n\n\n上面例子中，+(.txt)匹配文件有一个或多个.txt后缀名。\n\n$ ls a!(b).txt\na.txt abb.txt ac.txt\n\n\n1\n2\n\n\n上面例子中，!(b)表示匹配单个字母b以外的任意内容，所以除了ab.txt以外，其他文件名都能匹配。\n\n量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。\n\n没有 abc 开头的文件名\n\n$ ls abc?(def)\nls: 无法访问'abc?(def)': 没有那个文件或目录\n\n\n1\n2\n\n\n上面例子中，由于没有可匹配的文件，abc?(def)就原样输出，导致ls命令报错。\n\n# shopt 命令\n\nshopt命令可以调整 bash 的行为。它有好几个参数跟通配符扩展有关。\n\nshopt命令的使用方法如下。\n\n打开某个参数\n\n$ shopt -s [optionname]\n\n\n1\n\n\n关闭某个参数\n\n$ shopt -u [optionname]\n\n\n1\n\n\n查询某个参数关闭还是打开\n\n$ shopt [optionname]\n\n\n1\n\n 1. dotglob 参数\n\ndotglob参数可以让扩展结果包括隐藏文件（即点开头的文件）。\n\n正常情况下，扩展结果不包括隐藏文件。\n\n$ ls *\nabc.txt\n\n\n1\n2\n\n\n打开dotglob，就会包括隐藏文件。\n\n$ shopt -s dotglob\n$ ls *\nabc.txt .config\n\n\n1\n2\n3\n\n 2. nullglob 参数\n\nnullglob参数可以让通配符不匹配任何文件名时，返回空字符。\n\n默认情况下，通配符不匹配任何文件名时，会保持不变。\n\n$ rm b*\nrm: 无法删除'b*': 没有那个文件或目录\n\n\n1\n2\n\n\n上面例子中，由于当前目录不包括b开头的文件名，导致b*不会发生文件名扩展，保持原样不变，所以rm命令报错没有b*这个文件。\n\n打开nullglob参数，就可以让不匹配的通配符返回空字符串。\n\n$ shopt -s nullglob\n$ rm b*\nrm: 缺少操作数\n\n\n1\n2\n3\n\n\n上面例子中，由于没有b*匹配的文件名，所以rm b*扩展成了rm，导致报错变成了”缺少操作数“。\n\n 3. failglob 参数\n\nfailglob参数使得通配符不匹配任何文件名时，bash 会直接报错，而不是让各个命令去处理。\n\n$ shopt -s failglob\n$ rm b*\nbash: 无匹配: b*\n\n\n1\n2\n3\n\n\n上面例子中，打开failglob以后，由于b*不匹配任何文件名，bash 直接报错了，不再让rm命令去处理。\n\n 4. extglob 参数\n\nextglob参数使得 bash 支持 ksh 的一些扩展语法。它默认应该是打开的。\n\n$ shopt extglob\nextglob        \ton\n\n\n1\n2\n\n\n它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。\n\n$ shopt -u extglob\n\n\n1\n\n 5. nocaseglob 参数\n\nnocaseglob参数可以让通配符扩展不区分大小写。\n\n$ shopt -s nocaseglob\n$ ls /windows/program*\n/windows/programdata\n/windows/program files\n/windows/program files (x86)\n\n\n1\n2\n3\n4\n5\n\n\n上面例子中，打开nocaseglob以后，program*就不区分大小写了，可以匹配programdata等。\n\n 6. globstar 参数\n\nglobstar参数可以使得**匹配零个或多个子目录。该参数默认是关闭的。\n\n假设有下面的文件结构。\n\na.txt sub1/b.txt sub1/sub2/c.txt 上面的文件结构中，顶层目录、第一级子目录sub1、第二级子目录sub1\\sub2里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来？\n\n默认情况下，只能写成下面这样。\n\n$ ls *.txt */*.txt */*/*.txt\na.txt  sub1/b.txt  sub1/sub2/c.txt\n\n\n1\n2\n\n\n这是因为*只匹配当前目录，如果要匹配子目录，只能一层层写出来。\n\n打开globstar参数以后，匹配零个或多个子目录。因此，/*.txt就可以得到想要的结果。\n\n$ shopt -s globstar\n$ ls **/*.txt\na.txt  sub1/b.txt  sub1/sub2/c.txt\n\n\n1\n2\n3\n\n\n提示\n\n在阅读过程中发现，bash的教程对我并没有太大的工作上的帮助，剩余的内容我将阅读，不做整理，必要时查阅教程。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"树视图",frontmatter:{title:"树视图",date:"2024-07-10T10:27:16.000Z",permalink:"/pages/8c3c18/",categories:["技术","vscode开发"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.vscode%E5%BC%80%E5%8F%91/03.%E6%A0%91%E8%A7%86%E5%9B%BE.html",relativePath:"03.技术/05.vscode开发/03.树视图.md",key:"v-66d9d8bd",path:"/pages/8c3c18/",headers:[{level:3,title:"TreeView",slug:"treeview",normalizedTitle:"treeview",charIndex:2}],headersStr:"TreeView",content:"# TreeView\n\n * TreeView 允许插件在侧边栏中展示一些内容\n   * 可以在侧边栏加入一个自己的功能图标，和资源管理器一样\n   * 可以使用package.json设置treeview的条目\n   * 可以在生命周期内更新treeview的条目",normalizedContent:"# treeview\n\n * treeview 允许插件在侧边栏中展示一些内容\n   * 可以在侧边栏加入一个自己的功能图标，和资源管理器一样\n   * 可以使用package.json设置treeview的条目\n   * 可以在生命周期内更新treeview的条目",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"webview",frontmatter:{title:"webview",date:"2024-07-10T11:34:49.000Z",permalink:"/pages/e6e3c2/",categories:["技术","vscode开发"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/05.vscode%E5%BC%80%E5%8F%91/04.webview.html",relativePath:"03.技术/05.vscode开发/04.webview.md",key:"v-23976180",path:"/pages/e6e3c2/",headers:[{level:3,title:"webview 用于自定义界面",slug:"webview-用于自定义界面",normalizedTitle:"webview 用于自定义界面",charIndex:2}],headersStr:"webview 用于自定义界面",content:"# webview 用于自定义界面\n\n * 加载欢迎页\n * markdown预览\n * 需要注意的是webview本质是iframe，要使用 window.postMessage 与其他页面进行通信",normalizedContent:"# webview 用于自定义界面\n\n * 加载欢迎页\n * markdown预览\n * 需要注意的是webview本质是iframe，要使用 window.postmessage 与其他页面进行通信",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"更多",frontmatter:{title:"更多",date:"2024-05-19T19:30:15.000Z",permalink:"/more/",categories:["更多"],tags:[null],article:!1,author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E6%9B%B4%E5%A4%9A.html",relativePath:"04.更多/01.更多.md",key:"v-b7ae6a94",path:"/more/",headersStr:null,content:"> 在这里，我希望能够记录自己在面试方面的经历，也有可能会记录一些鸡汤",normalizedContent:"> 在这里，我希望能够记录自己在面试方面的经历，也有可能会记录一些鸡汤",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"了解Web及网络基础",frontmatter:{title:"了解Web及网络基础",date:"2024-08-08T17:05:25.000Z",permalink:"/pages/3ebda0/",categories:["技术","图解HTTP阅读"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%9B%BE%E8%A7%A3HTTP%E9%98%85%E8%AF%BB/01.%E4%BA%86%E8%A7%A3Web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.html",relativePath:"03.技术/06.图解HTTP阅读/01.了解Web及网络基础.md",key:"v-4093cc6a",path:"/pages/3ebda0/",headers:[{level:2,title:"名词定义",slug:"名词定义",normalizedTitle:"名词定义",charIndex:46},{level:2,title:"TCP/IP",slug:"tcp-ip",normalizedTitle:"tcp/ip",charIndex:282},{level:3,title:"TCP/IP 的分层管理",slug:"tcp-ip-的分层管理",normalizedTitle:"tcp/ip 的分层管理",charIndex:505},{level:4,title:"应用层",slug:"应用层",normalizedTitle:"应用层",charIndex:522},{level:4,title:"传输层",slug:"传输层",normalizedTitle:"传输层",charIndex:526},{level:4,title:"网络层",slug:"网络层",normalizedTitle:"网络层",charIndex:530},{level:4,title:"数据链路层",slug:"数据链路层",normalizedTitle:"数据链路层",charIndex:534},{level:3,title:"TCP/IP 通信传输流",slug:"tcp-ip-通信传输流",normalizedTitle:"tcp/ip 通信传输流",charIndex:1042},{level:3,title:"IP、TCP、DNS",slug:"ip、tcp、dns",normalizedTitle:"ip、tcp、dns",charIndex:1168},{level:4,title:"IP",slug:"ip",normalizedTitle:"ip",charIndex:286},{level:5,title:"使用 ARP 协议凭借 MAC 地址进行通信",slug:"使用-arp-协议凭借-mac-地址进行通信",normalizedTitle:"使用 arp 协议凭借 mac 地址进行通信",charIndex:1373},{level:2,title:"URI 和 URL",slug:"uri-和-url",normalizedTitle:"uri 和 url",charIndex:1638},{level:3,title:"URI 的概念",slug:"uri-的概念",normalizedTitle:"uri 的概念",charIndex:1652},{level:3,title:"URI 的格式",slug:"uri-的格式",normalizedTitle:"uri 的格式",charIndex:2062}],headersStr:"名词定义 TCP/IP TCP/IP 的分层管理 应用层 传输层 网络层 数据链路层 TCP/IP 通信传输流 IP、TCP、DNS IP 使用 ARP 协议凭借 MAC 地址进行通信 URI 和 URL URI 的概念 URI 的格式",content:"提示\n\n * Web 是建立在何种技术之上\n * HTTP 协议是如何诞生并发展的\n\n\n# 名词定义\n\n客户端：通过请求获取服务器资源的客体，如浏览器\n\nHTTP（HyperText Transfer Protocol）：超文本传输协议\n\nWWW（World Wide Web）：万维网\n\n协议： 计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）\n\nTCP/IP：TCP/IP 是互联网相关的各类协议族的总称。协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。像这样把与互联网相关联的协议集合起来总称为 TCP/IP。也有说法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。\n\n\n# TCP/IP\n\n\n# TCP/IP 的分层管理\n\n四层：应用层、传输层、网络层、数据链路层\n\n# 应用层\n\n应用层决定了向用户提供应用服务时通信的活动。\n\n常见协议：\n\n * FTP（File Transfer Protocol）文件传输协议\n * DNS（Domain Name System）域名系统\n * HTTP\n\n# 传输层\n\n对接应用层，提供处于网络连接中的两台计算机之间的数据传输\n\n常见协议：\n\n * TCP（Transmission Control Protocol）\n * UDP（User Data Protocol）\n\n# 网络层\n\n网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。\n\n与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。\n\nIP 协议在这一层\n\n# 数据链路层\n\n用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。\n\n\n# TCP/IP 通信传输流\n\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。\n\n这种把数据信息包装起来的做法称为封装（encapsulate）。\n\n\n\n\n# IP、TCP、DNS\n\n# IP\n\nIP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。\n\nIP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。\n\n# 使用 ARP 协议凭借 MAC 地址进行通信\n\nIP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（AddressResolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。\n\n提示\n\n无论哪台计算机、哪台网络设备，他们都无法全面掌握互联网中的细节\n\n\n\n\n# URI 和 URL\n\n\n# URI 的概念\n\nURI 是 Uniform Resource Identifier 的缩写。\n\nURI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。\n\nftp://ftp.is.co.za/rfc/rfc1808.txt\nhttp://www.ietf.org/rfc/rfc2396.txt\nldap://[2001:db8::7]/c=GB?objectClass?one\nmailto:John.Doe@example.com\nnews:comp.infosystems.www.servers.unix\ntel:+1-816-555-1212\ntelnet://192.0.2.16:80/\nurn:oasis:names:specification:docbook:dtd:xml:4.1.2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# URI 的格式\n\n绝对 URI 的格式，以如下的 URI 为例\n\nhttp://user:pass@www.example.jp:80/dir/index.html?uid=1#ch1\n\n协议类型：http: https:\n\n登录信息（认证）：user:pass 指定用户名和密码作为从服务端获取资源时的必要登录信息（身份认证）。此项是可选项\n\n服务器地址：www.example.jp 使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。\n\n服务器端口：80 指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。\n\n带层次的文件路径：/dir/index.html 指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。\n\n查询字符串：uid=1 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。\n\n片段标识符：使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。",normalizedContent:"提示\n\n * web 是建立在何种技术之上\n * http 协议是如何诞生并发展的\n\n\n# 名词定义\n\n客户端：通过请求获取服务器资源的客体，如浏览器\n\nhttp（hypertext transfer protocol）：超文本传输协议\n\nwww（world wide web）：万维网\n\n协议： 计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）\n\ntcp/ip：tcp/ip 是互联网相关的各类协议族的总称。协议中存在各式各样的内容。从电缆的规格到 ip 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 web 页面显示需要处理的步骤，等等。像这样把与互联网相关联的协议集合起来总称为 tcp/ip。也有说法认为，tcp/ip 是指 tcp 和 ip 这两种协议。还有一种说法认为，tcp/ip 是在 ip 协议的通信过程中，使用到的协议族的统称。\n\n\n# tcp/ip\n\n\n# tcp/ip 的分层管理\n\n四层：应用层、传输层、网络层、数据链路层\n\n# 应用层\n\n应用层决定了向用户提供应用服务时通信的活动。\n\n常见协议：\n\n * ftp（file transfer protocol）文件传输协议\n * dns（domain name system）域名系统\n * http\n\n# 传输层\n\n对接应用层，提供处于网络连接中的两台计算机之间的数据传输\n\n常见协议：\n\n * tcp（transmission control protocol）\n * udp（user data protocol）\n\n# 网络层\n\n网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。\n\n与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。\n\nip 协议在这一层\n\n# 数据链路层\n\n用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、nic（network interface card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。\n\n\n# tcp/ip 通信传输流\n\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。\n\n这种把数据信息包装起来的做法称为封装（encapsulate）。\n\n\n\n\n# ip、tcp、dns\n\n# ip\n\nip 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 ip 地址和 mac 地址（media access control address）。\n\nip 地址指明了节点被分配到的地址，mac 地址是指网卡所属的固定地址。ip 地址可以和 mac 地址进行配对。ip 地址可变换，但 mac 地址基本上不会更改。\n\n# 使用 arp 协议凭借 mac 地址进行通信\n\nip 间的通信依赖 mac 地址。在网络上，通信的双方在同一局域网（lan）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 mac 地址来搜索下一个中转目标。这时，会采用 arp 协议（addressresolution protocol）。arp 是一种用以解析地址的协议，根据通信方的 ip 地址就可以反查出对应的 mac 地址。\n\n提示\n\n无论哪台计算机、哪台网络设备，他们都无法全面掌握互联网中的细节\n\n\n\n\n# uri 和 url\n\n\n# uri 的概念\n\nuri 是 uniform resource identifier 的缩写。\n\nuri 用字符串标识某一互联网资源，而 url 表示资源的地点（互联网上所处的位置）。可见 url 是 uri 的子集。\n\nftp://ftp.is.co.za/rfc/rfc1808.txt\nhttp://www.ietf.org/rfc/rfc2396.txt\nldap://[2001:db8::7]/c=gb?objectclass?one\nmailto:john.doe@example.com\nnews:comp.infosystems.www.servers.unix\ntel:+1-816-555-1212\ntelnet://192.0.2.16:80/\nurn:oasis:names:specification:docbook:dtd:xml:4.1.2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# uri 的格式\n\n绝对 uri 的格式，以如下的 uri 为例\n\nhttp://user:pass@www.example.jp:80/dir/index.html?uid=1#ch1\n\n协议类型：http: https:\n\n登录信息（认证）：user:pass 指定用户名和密码作为从服务端获取资源时的必要登录信息（身份认证）。此项是可选项\n\n服务器地址：www.example.jp 使用绝对 uri 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 dns 可解析的名称，或是 192.168.1.1 这类 ipv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 ipv6 地址名。\n\n服务器端口：80 指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。\n\n带层次的文件路径：/dir/index.html 指定服务器上的文件路径来定位特指的资源。这与 unix 系统的文件目录结构相似。\n\n查询字符串：uid=1 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。\n\n片段标识符：使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 rfc 中并没有明确规定其使用方法。该项也为可选项。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"简单的HTTP协议",frontmatter:{title:"简单的HTTP协议",date:"2024-09-08T09:52:37.000Z",permalink:"/pages/f3d2f4/",categories:["技术","图解HTTP阅读"],tags:["核心技术"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/06.%E5%9B%BE%E8%A7%A3HTTP%E9%98%85%E8%AF%BB/02.%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE.html",relativePath:"03.技术/06.图解HTTP阅读/02.简单的HTTP协议.md",key:"v-311fd1d0",path:"/pages/f3d2f4/",headers:[{level:3,title:"PUT 方法",slug:"put-方法",normalizedTitle:"put 方法",charIndex:2}],headersStr:"PUT 方法",content:"# PUT 方法\n\n虽然 PUT 方法在设计之初是用来上传文件的，但是由于PUT方法自身不带验证机制，所以在RESTful标准中被用来创建或更新资源。",normalizedContent:"# put 方法\n\n虽然 put 方法在设计之初是用来上传文件的，但是由于put方法自身不带验证机制，所以在restful标准中被用来创建或更新资源。",charsets:{cjk:!0},lastUpdated:"2024/09/11, 17:01:03",lastUpdatedTimestamp:1726045263e3},{title:"好用工具",frontmatter:{title:"好用工具",date:"2024-07-30T14:13:56.000Z",permalink:"/pages/8d7ea0/",categories:["更多"],tags:["核心工具"],author:{name:"leon yu",link:"https://github.com/lampeggiante"},sticky:7},regularPath:"/04.%E6%9B%B4%E5%A4%9A/04.%E5%A5%BD%E7%94%A8%E5%B7%A5%E5%85%B7.html",relativePath:"04.更多/04.好用工具.md",key:"v-22079d2f",path:"/pages/8d7ea0/",headersStr:null,content:"提示\n\n开发好物\n\n\n# mac\n\nraycast\n\nwarp\n\nsnippaste\n\ngiphy capture\n\ntailscale\n\nshadowrocket",normalizedContent:"提示\n\n开发好物\n\n\n# mac\n\nraycast\n\nwarp\n\nsnippaste\n\ngiphy capture\n\ntailscale\n\nshadowrocket",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"专有名词学习",frontmatter:{title:"专有名词学习",date:"2024-07-30T14:03:24.000Z",permalink:"/pages/815283/",categories:["更多"],tags:["核心概念"],author:{name:"leon yu",link:"https://github.com/lampeggiante"},sticky:8},regularPath:"/04.%E6%9B%B4%E5%A4%9A/03.%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%E5%AD%A6%E4%B9%A0.html",relativePath:"04.更多/03.专有名词学习.md",key:"v-447ce33c",path:"/pages/815283/",headers:[{level:2,title:"B/S 架构",slug:"b-s-架构",normalizedTitle:"b/s 架构",charIndex:39},{level:2,title:"CI/CD",slug:"ci-cd",normalizedTitle:"ci/cd",charIndex:159},{level:2,title:"MVP",slug:"mvp",normalizedTitle:"mvp",charIndex:282},{level:2,title:"大前端",slug:"大前端",normalizedTitle:"大前端",charIndex:371},{level:2,title:"微前端",slug:"微前端",normalizedTitle:"微前端",charIndex:488}],headersStr:"B/S 架构 CI/CD MVP 大前端 微前端",content:"提示\n\n记录一些常见的前端专业名词，防止后续忘记。\n\n\n# 业界术语\n\n\n# B/S 架构\n\nB/S架构（Browser/Server，浏览器/服务器架构）是一种网络架构模式，它将客户端功能通过浏览器实现，服务器负责处理业务逻辑和数据存储。用户通过浏览器访问服务器上的应用程序，而不需要安装专门的客户端软件。\n\n\n# CI/CD\n\nCI/CD（Continuous Integration/Continuous Deployment or Delivery，持续集成/持续交付或持续部署）是一组现代软件开发实践，用于自动化和提高软件交付过程的效率和质量。\n\n\n# MVP\n\n最简可行产品（英语：minimum viable product, MVP），是新产品开发中的名词，是指有部分机能，恰好可以让设计者表达其核心设计概念的产品。\n\n\n# 大前端\n\n大前端是所有前端的统称，包括Android、iOS、web、Watch等，最接近用户的是UI层。 它的最大特点在于一次开发，就能同时适用于所有平台，开发者不用为一个APP需要做Android和iOS两种模式而担心。\n\n\n# 微前端\n\n微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来仍然是内聚的单个产品。",normalizedContent:"提示\n\n记录一些常见的前端专业名词，防止后续忘记。\n\n\n# 业界术语\n\n\n# b/s 架构\n\nb/s架构（browser/server，浏览器/服务器架构）是一种网络架构模式，它将客户端功能通过浏览器实现，服务器负责处理业务逻辑和数据存储。用户通过浏览器访问服务器上的应用程序，而不需要安装专门的客户端软件。\n\n\n# ci/cd\n\nci/cd（continuous integration/continuous deployment or delivery，持续集成/持续交付或持续部署）是一组现代软件开发实践，用于自动化和提高软件交付过程的效率和质量。\n\n\n# mvp\n\n最简可行产品（英语：minimum viable product, mvp），是新产品开发中的名词，是指有部分机能，恰好可以让设计者表达其核心设计概念的产品。\n\n\n# 大前端\n\n大前端是所有前端的统称，包括android、ios、web、watch等，最接近用户的是ui层。 它的最大特点在于一次开发，就能同时适用于所有平台，开发者不用为一个app需要做android和ios两种模式而担心。\n\n\n# 微前端\n\n微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来仍然是内聚的单个产品。",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"2024年5月",frontmatter:{title:"2024年5月",date:"2024-05-19T20:32:20.000Z",permalink:"/pages/29fb55/",categories:["更多","个人记录"],tags:[null],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/02.%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/01.2024%E5%B9%B45%E6%9C%88.html",relativePath:"04.更多/02.个人记录/01.2024年5月.md",key:"v-6c0afe04",path:"/pages/29fb55/",headers:[{level:4,title:"当前已有的学习经历",slug:"当前已有的学习经历",normalizedTitle:"当前已有的学习经历",charIndex:43}],headersStr:"当前已有的学习经历",content:"提示\n\n这是我第一次记录自己的学习经历，先将之前的记忆放在这里，以防后续忘记。\n\n# 当前已有的学习经历\n\n * 2023.8-2023.10\n   * html css javascript基础，其中js专门阅读了mdn的教程\n * 2023.10-2023.11\n   * 学习了vue2和vue3，对常用的vue指令修饰符与vue的构建逻辑有了比较清晰的了解\n * 2023.11-2023.11\n   * 使用vue2重构了一个有2w左右用户的项目，主要贡献在于组件化与重构UI、跨端适配\n * 2023.12初一星期\n   * 学习了React，并使用react生态搭建了一个简单的前端笔记软件，主要难点在于工程搭建与熟悉react语法与思维习惯\n * 2023.12-2024.1\n   * 复习各种面试题，同时开始面试一些公司，拿到了一家小厂与一家中厂的offer\n   * 在这个过程中积累了面试经验，也对常见的八股有了一定的了解\n * 2024.1-2024.4\n   * 在中厂实习了三个月左右，对React更加熟悉了，各种hooks用的比较熟练了，也能够结合ant design pro搭建内部的页面了，同时能将一些重复会用到的逻辑封装为了自定义hooks\n   * 在实习期间花了大概两个星期刷完了150题左右的算法题，用以应对面试时常见的算法提问\n * 2024.4-2024.5\n   * 在完成现有工作的基础上用了一个星期使用koa2搭建了自己先前静态页面的后端接口，对于跨域、http请求、数据库等有了一些粗浅的了解。\n   * 下半个月在不断地进行面试，拿到了一家初创和两家大厂的日常实习offer，在这个过程中也在不断的打磨自己对于前端各类技术的认知",normalizedContent:"提示\n\n这是我第一次记录自己的学习经历，先将之前的记忆放在这里，以防后续忘记。\n\n# 当前已有的学习经历\n\n * 2023.8-2023.10\n   * html css javascript基础，其中js专门阅读了mdn的教程\n * 2023.10-2023.11\n   * 学习了vue2和vue3，对常用的vue指令修饰符与vue的构建逻辑有了比较清晰的了解\n * 2023.11-2023.11\n   * 使用vue2重构了一个有2w左右用户的项目，主要贡献在于组件化与重构ui、跨端适配\n * 2023.12初一星期\n   * 学习了react，并使用react生态搭建了一个简单的前端笔记软件，主要难点在于工程搭建与熟悉react语法与思维习惯\n * 2023.12-2024.1\n   * 复习各种面试题，同时开始面试一些公司，拿到了一家小厂与一家中厂的offer\n   * 在这个过程中积累了面试经验，也对常见的八股有了一定的了解\n * 2024.1-2024.4\n   * 在中厂实习了三个月左右，对react更加熟悉了，各种hooks用的比较熟练了，也能够结合ant design pro搭建内部的页面了，同时能将一些重复会用到的逻辑封装为了自定义hooks\n   * 在实习期间花了大概两个星期刷完了150题左右的算法题，用以应对面试时常见的算法提问\n * 2024.4-2024.5\n   * 在完成现有工作的基础上用了一个星期使用koa2搭建了自己先前静态页面的后端接口，对于跨域、http请求、数据库等有了一些粗浅的了解。\n   * 下半个月在不断地进行面试，拿到了一家初创和两家大厂的日常实习offer，在这个过程中也在不断的打磨自己对于前端各类技术的认知",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"关于",frontmatter:{title:"关于",date:"2024-05-19T19:12:53.000Z",permalink:"/about/",categories:["关于"],tags:["个人博客介绍"],author:{name:"leon yu",link:"https://github.com/lampeggiante"},sticky:5},regularPath:"/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"05.关于/01.关于.md",key:"v-41d731e4",path:"/about/",headers:[{level:4,title:"写在前面",slug:"写在前面",normalizedTitle:"写在前面",charIndex:56},{level:4,title:"对于当前互联网形式的思考",slug:"对于当前互联网形式的思考",normalizedTitle:"对于当前互联网形式的思考",charIndex:290}],headersStr:"写在前面 对于当前互联网形式的思考",content:"提示\n\n这里是 leon 的个人博客，从2024年5月19日起，本人打算在这里记录自己学习前端时的思考～\n\n# 写在前面\n\n首先还是要非常感谢Evan Xu提供的主题，帮我省去了非常多配置vuepress的麻烦。\n\n本人从2023年8月开始接触前端。先前所学专业为经济学，在高考填报志愿时是列表中唯一的文科。囿于视野的局限，当时选了自己并不擅长也提不起兴趣的经济学，在大学觉得屡屡受挫，没有享受到学科的乐趣。一直以来，学习的知识都脱离了我高中时学习物化生的逻辑，让我觉得学习的知识虚无缥缈。直到经高中的挚友介绍，我才一步一个脚印迈入了互联网，逐步成长为一位前端开发爱好者。\n\n# 对于当前互联网形式的思考\n\n2024年的互联网就业形式十分严峻，企业的人才池子里装满了各路英雄，想要在这样的红海中分一杯羹非常困难。我深刻地知道这一点，也被许多互联网从业者劝退过，”狠赚笔“的圣经每天都在我的耳边盘旋，直至今日，由于非科班的身份，我仍然无法保证自己能够在毕业时获得一份满意的offer。但是对我来说这是一次救赎，我重新踏回了自己所擅长的领域，也重新地做起了自己喜欢的事情，为了自己的爱好，也为了更好的生活，我没理由后悔。\n\n希望自己能够通过前端开发的工作得以在当前纷繁复杂的社会立足，也希望26届时毕业的我能够有满意的去处～\n\n如果有幸有人路过的话，也祝福你在今天，明天，未来每一天都有值得期待的事～",normalizedContent:"提示\n\n这里是 leon 的个人博客，从2024年5月19日起，本人打算在这里记录自己学习前端时的思考～\n\n# 写在前面\n\n首先还是要非常感谢evan xu提供的主题，帮我省去了非常多配置vuepress的麻烦。\n\n本人从2023年8月开始接触前端。先前所学专业为经济学，在高考填报志愿时是列表中唯一的文科。囿于视野的局限，当时选了自己并不擅长也提不起兴趣的经济学，在大学觉得屡屡受挫，没有享受到学科的乐趣。一直以来，学习的知识都脱离了我高中时学习物化生的逻辑，让我觉得学习的知识虚无缥缈。直到经高中的挚友介绍，我才一步一个脚印迈入了互联网，逐步成长为一位前端开发爱好者。\n\n# 对于当前互联网形式的思考\n\n2024年的互联网就业形式十分严峻，企业的人才池子里装满了各路英雄，想要在这样的红海中分一杯羹非常困难。我深刻地知道这一点，也被许多互联网从业者劝退过，”狠赚笔“的圣经每天都在我的耳边盘旋，直至今日，由于非科班的身份，我仍然无法保证自己能够在毕业时获得一份满意的offer。但是对我来说这是一次救赎，我重新踏回了自己所擅长的领域，也重新地做起了自己喜欢的事情，为了自己的爱好，也为了更好的生活，我没理由后悔。\n\n希望自己能够通过前端开发的工作得以在当前纷繁复杂的社会立足，也希望26届时毕业的我能够有满意的去处～\n\n如果有幸有人路过的话，也祝福你在今天，明天，未来每一天都有值得期待的事～",charsets:{cjk:!0},lastUpdated:"2024/08/19, 01:05:55",lastUpdatedTimestamp:1724000755e3},{title:"备战腾讯20240902",frontmatter:{title:"备战腾讯20240902",date:"2024-09-02T12:55:32.000Z",permalink:"/pages/2d88c4/",categories:["更多","面试"],tags:["查漏补缺"],author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/05.%E9%9D%A2%E8%AF%95/01.%E5%A4%87%E6%88%98%E8%85%BE%E8%AE%AF20240902.html",relativePath:"04.更多/05.面试/01.备战腾讯20240902.md",key:"v-7feb8d24",path:"/pages/2d88c4/",headers:[{level:2,title:"为什么会接触前端",slug:"为什么会接触前端",normalizedTitle:"为什么会接触前端",charIndex:2},{level:2,title:"HTML标签可以分为几类",slug:"html标签可以分为几类",normalizedTitle:"html标签可以分为几类",charIndex:126},{level:2,title:"HTML中的 <head> 标签中一般会写什么",slug:"html中的-head-标签中一般会写什么",normalizedTitle:"html中的 <head> 标签中一般会写什么",charIndex:735},{level:2,title:"引入 CSS 的标签叫什么",slug:"引入-css-的标签叫什么",normalizedTitle:"引入 css 的标签叫什么",charIndex:1598},{level:2,title:"JS的引入过程发生了什么",slug:"js的引入过程发生了什么",normalizedTitle:"js的引入过程发生了什么",charIndex:1686},{level:2,title:"判断元素 50% 在可视区域内",slug:"判断元素-50-在可视区域内",normalizedTitle:"判断元素 50% 在可视区域内",charIndex:1794},{level:2,title:"最长连续字符",slug:"最长连续字符",normalizedTitle:"最长连续字符",charIndex:3041},{level:2,title:"从浏览器地址栏输入 url 到显示页面的步骤",slug:"从浏览器地址栏输入-url-到显示页面的步骤",normalizedTitle:"从浏览器地址栏输入 url 到显示页面的步骤",charIndex:3769},{level:2,title:"宏任务有哪些",slug:"宏任务有哪些",normalizedTitle:"宏任务有哪些",charIndex:4082},{level:2,title:"js字符串length的物理意义是什么",slug:"js字符串length的物理意义是什么",normalizedTitle:"js字符串length的物理意义是什么",charIndex:4138}],headersStr:"为什么会接触前端 HTML标签可以分为几类 HTML中的 <head> 标签中一般会写什么 引入 CSS 的标签叫什么 JS的引入过程发生了什么 判断元素 50% 在可视区域内 最长连续字符 从浏览器地址栏输入 url 到显示页面的步骤 宏任务有哪些 js字符串length的物理意义是什么",content:'# 为什么会接触前端\n\n本人虽然本科与研究生为经济学专业，接触了大量的经济学模型和数理推导，也有一定的编程实践，但是市面上没有足够的就业面。这个时候我特别希望能找到一份自己喜欢的编码工作，希望能在这个过程中能学到很多东西，也能与大家一起交流。\n\n\n# HTML标签可以分为几类\n\n提示\n\n找一个记忆顺序，快速记忆\n\n文档和元数据：元\n\n文本和语义元素：语元\n\n链接：链\n\n图像和媒体：媒\n\n列表：列\n\n表格：表格\n\n表单：表单\n\n样式和布局：式\n\n语义标签：语标\n\n元链媒列式 表格和表单 语元与语签\n\n文档和元数据：用于定义文档的结构和元数据，如<html>, <head>, <title>, 和 <meta>。\n\n文本和语义元素：用于显示文本内容和提供文档结构，如<p>, <h1>-<h6>, <em>, <strong>, <blockquote>, <span>, 等。\n\n链接：用于创建超链接，如<a>。\n\n图像和媒体：用于插入图像、音频、视频等多媒体内容，如<img>, <audio>, <video>等。\n\n列表：用于创建列表，如<ul>, <ol>, <li>等。\n\n表格：用于创建表格，如<table>, <tr>, <td>等。\n\n表单：用于创建表单元素，如<form>, <input>, <textarea>, <select>, <button>等。\n\n样式和布局：用于控制文档的样式和布局，如<style>, <div>, <span>等，它们通常结合CSS使用。\n\n语义标签：用于提供更多关于文档内容的语义信息，如<header>, <nav>, <main>, <aside>, <article>, <footer>等。\n\n\n# HTML中的 <head> 标签中一般会写什么\n\n在HTML的 <head>标签中，通常会包含以下内容：\n\n<title> 标签：定义文档的标题，这通常会显示在浏览器的标题栏上。\n\n<meta> 标签：提供有关文档的各种元数据，例如字符编码、作者、描述、关键词等。\n\n<link> 标签：用于链接到外部样式表，以便为文档应用CSS样式。\n\n<script> 标签：可以包含脚本，无论是内联脚本还是链接到外部脚本文件。\n\n<style> 标签：如果有内联样式（虽然不推荐），可以放在这里。\n\n<base> 标签：指定文档中所有相对链接的默认URL。\n\n其他元数据：可能包括搜索引擎优化（SEO）相关的标签，如<meta name="description"> 和<meta name="keywords">，以及社交媒体集成相关的标签。\n\n以下是一个简单的<head>标签示例，其中包含了上述部分元素：\n\n<head>\n  <title>我的网页标题</title>\n  <meta charset="UTF-8">\n  <meta name="description" content="这是我的网页描述">\n  <meta name="keywords" content="关键字1, 关键字2, 关键字3">\n  <link rel="stylesheet" type="text/css" href="styles.css">\n  <script src="script.js"><\/script>\n  <style>\n    /* 任何内联样式可以放在这里 */\n  </style>\n  <base href="https://www.example.com/">\n</head>\n<head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n标签中的内容对于文档的正确渲染和SEO很重要，因为搜索引擎会索引<title>和<meta>标签中的信息，而样式和脚本会影响页面的外观和行为。\n\n\n# 引入 CSS 的标签叫什么\n\n<link> 标签用于引入外部样式表，它的作用是将外部的 CSS 文件链接到当前的 HTML 文件中，从而使页面的样式更加灵活和可定制。\n\n\n# JS的引入过程发生了什么\n\n与外界交互：遇到跨域的资源，会使用ajax进行资源下载\n\n与HTML交互：插入CSS，为HTML元素绑定事件，按照需求进行html元素增删改\n\n内部：执行脚本，生成应用程序上下文\n\n\n# 判断元素 50% 在可视区域内\n\n使用getBoundingClientRect方法\n\nfunction isElementPartiallyInView(element) {\n  const rect = element.getBoundingClientRect();\n  const viewportWidth = document.documentElement.clientWidth;\n  const viewportHeight = document.documentElement.clientHeight;\n\n  const isTopInView = rect.top >= 0 && rect.top < viewportHeight / 2;\n  const isBottomInView = rect.bottom > viewportHeight / 2 && rect.bottom <= viewportHeight;\n\n  return isTopInView || isBottomInView;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用IntersectionObserver方法\n\nfunction isElementPartiallyInView(element, percentage = 50) {\n  let observer = null;\n\n  function handleIntersection(entries, observer) {\n    entries.forEach(entry => {\n      if (entry.intersectionRatio >= percentage / 100) {\n        console.log(`${element.id} 的 ${percentage}% 在可视区域内`);\n        observer.unobserve(element);\n      } else {\n        console.log(`${element.id} 的 ${percentage}% 不在可视区域内`);\n      }\n    });\n  }\n\n  observer = new IntersectionObserver(handleIntersection, { threshold: percentage / 100 });\n  observer.observe(element);\n\n  return observer;\n}\n\nlet myElement = document.getElementById(\'myElement\');\nisElementPartiallyInView(myElement, 50); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 最长连续字符\n\n笔记\n\n字母序连续字符串 是由字母表中连续字母组成的字符串。换句话说，字符串 "abcdefghijklmnopqrstuvwxyz" 的任意子字符串都是 字母序连续字符串 。\n\n例如，"abc" 是一个字母序连续字符串，而 "acb" 和 "za" 不是。 给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。\n\n示例 1：\n\n输入：s = "abacaba" 输出：2 解释：共有 4 个不同的字母序连续子字符串 "a"、"b"、"c" 和 "ab" 。 "ab" 是最长的字母序连续子字符串。\n\n示例 2：\n\n输入：s = "abcde" 输出：5 解释："abcde" 是最长的字母序连续子字符串。\n\n提示：\n\n1 <= s.length <= 105\n\ns 由小写英文字母组成\n\nvar longestContinuousSubstring = function(s) {\n  let cur = 1, max = 1\n  const len = s.length\n  for (let i = 1; i < len; ++i) {\n    const pre = s.charCodeAt(i - 1)\n    const c = s.charCodeAt(i)\n    if (c - pre === 1) {\n      cur++\n      max = Math.max(cur, max)\n    } else {\n      cur = 1\n    }\n  }\n  return max\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 从浏览器地址栏输入 url 到显示页面的步骤\n\n 1. 判断是否为合法 url，如果不是，则使用默认搜索引擎搜索\n 2. 为合法 url，则根据对应的协议建立与服务器之间的联系，通过DNS解析domain为ip地址，并建立TCP连接\n 3. 简历TCP连接之后，向特定服务器发送HTTP请求，获取对应的资源\n 4. 服务器接收到请求后，根据请求的资源类型，返回对应的资源给浏览器\n 5. 浏览器接收到资源后，解析HTML，生成DOM树和CSSOM树\n 6. 浏览器根据DOM树和CSSOM树，生成渲染树\n 7. 浏览器根据渲染树，将渲染树绘制到屏幕上\n 8. 资源加载完毕后，会进行TCP四次挥手过程，关闭TCP连接\n\n\n# 宏任务有哪些\n\n宏任务：setTimeout、setInterval、I/O、UI rendering\n\n\n# js字符串length的物理意义是什么\n\n字符串的length属性表示字符串的长度，它是一个只读属性，用于获取字符串的长度。\n\n在JavaScript中，字符串的长度是指字符串中字符的个数，而不是字节数。例如，字符串"Hello"的length属性值为5，因为它包含5个字符。',normalizedContent:'# 为什么会接触前端\n\n本人虽然本科与研究生为经济学专业，接触了大量的经济学模型和数理推导，也有一定的编程实践，但是市面上没有足够的就业面。这个时候我特别希望能找到一份自己喜欢的编码工作，希望能在这个过程中能学到很多东西，也能与大家一起交流。\n\n\n# html标签可以分为几类\n\n提示\n\n找一个记忆顺序，快速记忆\n\n文档和元数据：元\n\n文本和语义元素：语元\n\n链接：链\n\n图像和媒体：媒\n\n列表：列\n\n表格：表格\n\n表单：表单\n\n样式和布局：式\n\n语义标签：语标\n\n元链媒列式 表格和表单 语元与语签\n\n文档和元数据：用于定义文档的结构和元数据，如<html>, <head>, <title>, 和 <meta>。\n\n文本和语义元素：用于显示文本内容和提供文档结构，如<p>, <h1>-<h6>, <em>, <strong>, <blockquote>, <span>, 等。\n\n链接：用于创建超链接，如<a>。\n\n图像和媒体：用于插入图像、音频、视频等多媒体内容，如<img>, <audio>, <video>等。\n\n列表：用于创建列表，如<ul>, <ol>, <li>等。\n\n表格：用于创建表格，如<table>, <tr>, <td>等。\n\n表单：用于创建表单元素，如<form>, <input>, <textarea>, <select>, <button>等。\n\n样式和布局：用于控制文档的样式和布局，如<style>, <div>, <span>等，它们通常结合css使用。\n\n语义标签：用于提供更多关于文档内容的语义信息，如<header>, <nav>, <main>, <aside>, <article>, <footer>等。\n\n\n# html中的 <head> 标签中一般会写什么\n\n在html的 <head>标签中，通常会包含以下内容：\n\n<title> 标签：定义文档的标题，这通常会显示在浏览器的标题栏上。\n\n<meta> 标签：提供有关文档的各种元数据，例如字符编码、作者、描述、关键词等。\n\n<link> 标签：用于链接到外部样式表，以便为文档应用css样式。\n\n<script> 标签：可以包含脚本，无论是内联脚本还是链接到外部脚本文件。\n\n<style> 标签：如果有内联样式（虽然不推荐），可以放在这里。\n\n<base> 标签：指定文档中所有相对链接的默认url。\n\n其他元数据：可能包括搜索引擎优化（seo）相关的标签，如<meta name="description"> 和<meta name="keywords">，以及社交媒体集成相关的标签。\n\n以下是一个简单的<head>标签示例，其中包含了上述部分元素：\n\n<head>\n  <title>我的网页标题</title>\n  <meta charset="utf-8">\n  <meta name="description" content="这是我的网页描述">\n  <meta name="keywords" content="关键字1, 关键字2, 关键字3">\n  <link rel="stylesheet" type="text/css" href="styles.css">\n  <script src="script.js"><\/script>\n  <style>\n    /* 任何内联样式可以放在这里 */\n  </style>\n  <base href="https://www.example.com/">\n</head>\n<head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n标签中的内容对于文档的正确渲染和seo很重要，因为搜索引擎会索引<title>和<meta>标签中的信息，而样式和脚本会影响页面的外观和行为。\n\n\n# 引入 css 的标签叫什么\n\n<link> 标签用于引入外部样式表，它的作用是将外部的 css 文件链接到当前的 html 文件中，从而使页面的样式更加灵活和可定制。\n\n\n# js的引入过程发生了什么\n\n与外界交互：遇到跨域的资源，会使用ajax进行资源下载\n\n与html交互：插入css，为html元素绑定事件，按照需求进行html元素增删改\n\n内部：执行脚本，生成应用程序上下文\n\n\n# 判断元素 50% 在可视区域内\n\n使用getboundingclientrect方法\n\nfunction iselementpartiallyinview(element) {\n  const rect = element.getboundingclientrect();\n  const viewportwidth = document.documentelement.clientwidth;\n  const viewportheight = document.documentelement.clientheight;\n\n  const istopinview = rect.top >= 0 && rect.top < viewportheight / 2;\n  const isbottominview = rect.bottom > viewportheight / 2 && rect.bottom <= viewportheight;\n\n  return istopinview || isbottominview;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用intersectionobserver方法\n\nfunction iselementpartiallyinview(element, percentage = 50) {\n  let observer = null;\n\n  function handleintersection(entries, observer) {\n    entries.foreach(entry => {\n      if (entry.intersectionratio >= percentage / 100) {\n        console.log(`${element.id} 的 ${percentage}% 在可视区域内`);\n        observer.unobserve(element);\n      } else {\n        console.log(`${element.id} 的 ${percentage}% 不在可视区域内`);\n      }\n    });\n  }\n\n  observer = new intersectionobserver(handleintersection, { threshold: percentage / 100 });\n  observer.observe(element);\n\n  return observer;\n}\n\nlet myelement = document.getelementbyid(\'myelement\');\niselementpartiallyinview(myelement, 50); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 最长连续字符\n\n笔记\n\n字母序连续字符串 是由字母表中连续字母组成的字符串。换句话说，字符串 "abcdefghijklmnopqrstuvwxyz" 的任意子字符串都是 字母序连续字符串 。\n\n例如，"abc" 是一个字母序连续字符串，而 "acb" 和 "za" 不是。 给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。\n\n示例 1：\n\n输入：s = "abacaba" 输出：2 解释：共有 4 个不同的字母序连续子字符串 "a"、"b"、"c" 和 "ab" 。 "ab" 是最长的字母序连续子字符串。\n\n示例 2：\n\n输入：s = "abcde" 输出：5 解释："abcde" 是最长的字母序连续子字符串。\n\n提示：\n\n1 <= s.length <= 105\n\ns 由小写英文字母组成\n\nvar longestcontinuoussubstring = function(s) {\n  let cur = 1, max = 1\n  const len = s.length\n  for (let i = 1; i < len; ++i) {\n    const pre = s.charcodeat(i - 1)\n    const c = s.charcodeat(i)\n    if (c - pre === 1) {\n      cur++\n      max = math.max(cur, max)\n    } else {\n      cur = 1\n    }\n  }\n  return max\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 从浏览器地址栏输入 url 到显示页面的步骤\n\n 1. 判断是否为合法 url，如果不是，则使用默认搜索引擎搜索\n 2. 为合法 url，则根据对应的协议建立与服务器之间的联系，通过dns解析domain为ip地址，并建立tcp连接\n 3. 简历tcp连接之后，向特定服务器发送http请求，获取对应的资源\n 4. 服务器接收到请求后，根据请求的资源类型，返回对应的资源给浏览器\n 5. 浏览器接收到资源后，解析html，生成dom树和cssom树\n 6. 浏览器根据dom树和cssom树，生成渲染树\n 7. 浏览器根据渲染树，将渲染树绘制到屏幕上\n 8. 资源加载完毕后，会进行tcp四次挥手过程，关闭tcp连接\n\n\n# 宏任务有哪些\n\n宏任务：settimeout、setinterval、i/o、ui rendering\n\n\n# js字符串length的物理意义是什么\n\n字符串的length属性表示字符串的长度，它是一个只读属性，用于获取字符串的长度。\n\n在javascript中，字符串的长度是指字符串中字符的个数，而不是字节数。例如，字符串"hello"的length属性值为5，因为它包含5个字符。',charsets:{cjk:!0},lastUpdated:"2024/09/02, 15:15:58",lastUpdatedTimestamp:1725261358e3},{title:"收藏",frontmatter:{title:"收藏",date:"2024-05-19T19:32:31.000Z",permalink:"/favorite/",categories:["收藏"],tags:[null],article:!1,author:{name:"leon yu",link:"https://github.com/lampeggiante"}},regularPath:"/06.%E6%94%B6%E8%97%8F/01.%E6%94%B6%E8%97%8F.html",relativePath:"06.收藏/01.收藏.md",key:"v-5dd236c0",path:"/favorite/",headers:[{level:2,title:"前端合集",slug:"前端合集",normalizedTitle:"前端合集",charIndex:48},{level:2,title:"浏览器",slug:"浏览器",normalizedTitle:"浏览器",charIndex:94},{level:2,title:"linux入门之WSL",slug:"linux入门之wsl",normalizedTitle:"linux入门之wsl",charIndex:238},{level:2,title:"关注博主",slug:"关注博主",normalizedTitle:"关注博主",charIndex:267},{level:2,title:"技术新闻学习",slug:"技术新闻学习",normalizedTitle:"技术新闻学习",charIndex:288},{level:2,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:334}],headersStr:"前端合集 浏览器 linux入门之WSL 关注博主 技术新闻学习 正则",content:"> 在这里，我将会记录一些并非自己写的内容，只是因为内容比较好，所以将一些链接放在这里\n\n\n# 前端合集\n\n依赖注入与控制反转\n\n100+掘金高质量前端文章合集\n\n微前端架构设计\n\n\n# 浏览器\n\n浏览器底层原理（面试重点！）\n\n详解 Chrome 「V8 」引擎，让你更懂 JavaScript\n\n前端万字精华「浏览器简史及其核心原理详解」\n\nrust 学习\n\n前端加载超大图片\n\nIndexedDB 使用\n\nIndexedDB 教程\n\ntsconfig.json\n\n\n# linux入门之WSL\n\n搭建WSL前端开发环境\n\n\n# 关注博主\n\n匠心博客\n\n黯羽轻扬\n\n\n# 技术新闻学习\n\nFRE123 技术周刊\n\nJ 实验室\n\n前端技术周刊\n\nCNode\n\n\n# 正则\n\n深入了解JavaScript的正则表达式",normalizedContent:"> 在这里，我将会记录一些并非自己写的内容，只是因为内容比较好，所以将一些链接放在这里\n\n\n# 前端合集\n\n依赖注入与控制反转\n\n100+掘金高质量前端文章合集\n\n微前端架构设计\n\n\n# 浏览器\n\n浏览器底层原理（面试重点！）\n\n详解 chrome 「v8 」引擎，让你更懂 javascript\n\n前端万字精华「浏览器简史及其核心原理详解」\n\nrust 学习\n\n前端加载超大图片\n\nindexeddb 使用\n\nindexeddb 教程\n\ntsconfig.json\n\n\n# linux入门之wsl\n\n搭建wsl前端开发环境\n\n\n# 关注博主\n\n匠心博客\n\n黯羽轻扬\n\n\n# 技术新闻学习\n\nfre123 技术周刊\n\nj 实验室\n\n前端技术周刊\n\ncnode\n\n\n# 正则\n\n深入了解javascript的正则表达式",charsets:{cjk:!0},lastUpdated:"2024/08/26, 16:01:36",lastUpdatedTimestamp:1724659296e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-4978dfba",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/05/19, 02:10:36",lastUpdatedTimestamp:1716055836e3},{title:"Home",frontmatter:{home:!0,heroText:"Leon's blog",tagline:"做一个有个性的开发者～",features:[{title:"前端",details:"JavaScript、ES6、Vue框架等前端技术",link:"/web/",imgUrl:"/img/web.png"},{title:"场景",details:"html(5)/css(3)，前端页面相关技术",link:"/ui/",imgUrl:"/img/ui.png"},{title:"技术",details:"技术文档、教程、技巧、总结等文章",link:"/technology/",imgUrl:"/img/other.png"}]},regularPath:"/",relativePath:"index.md",key:"v-43865bc6",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/05/20, 11:22:32",lastUpdatedTimestamp:1716175352e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-7511215a",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/05/19, 02:10:36",lastUpdatedTimestamp:1716055836e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-493496da",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/05/19, 02:10:36",lastUpdatedTimestamp:1716055836e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"前端",link:"/web/"},{text:"场景",link:"/ui/"},{text:"技术",link:"/technology/"},{text:"更多",link:"/more/"},{text:"关于",link:"/about/"},{text:"收藏",link:"/favorite/"},{text:"索引",link:"/archives/"}],sidebarDepth:2,logo:"/img/avatar.jpg",repo:"lampeggiante/leonBlog",searchMaxSuggestions:4,searchPlaceholder:"搜点什么吧～",lastUpdated:"最近更新～",docsDir:"docs",sidebar:{"/01.前端/":[["01.前端.md","前端","/web/"],{title:"前端工程化",collapsable:!0,children:[["02.前端工程化/01.常见包管理工具.md","常见包管理工具","/pages/5e2247/"],["02.前端工程化/02.前端工程化理解.md","前端工程化理解","/pages/d9cf63/"]]},{title:"JavaScript高级程序设计",collapsable:!0,children:[["03.JavaScript高级程序设计/01.JavaScript高级程序设计笔记.md","JavaScript高级程序设计笔记","/pages/2da590/"],["03.JavaScript高级程序设计/02.什么是JavaScript.md","什么是JavaScript","/pages/3946c7/"],["03.JavaScript高级程序设计/03.html中的js.md","html中的js","/pages/ac246c/"],["03.JavaScript高级程序设计/04.语法基础（一）.md","语法基础（一）","/pages/de0153/"],["03.JavaScript高级程序设计/05.语法基础（二）.md","语法基础（二）","/pages/546def/"],["03.JavaScript高级程序设计/06.变量、作用域与内存.md","变量、作用域与内存","/pages/d218d6/"],["03.JavaScript高级程序设计/07.基本引用类型.md","基本引用类型","/pages/58a981/"],["03.JavaScript高级程序设计/08.集合引用类型.md","集合引用类型","/pages/f63386/"],["03.JavaScript高级程序设计/09.迭代器与生成器.md","迭代器与生成器","/pages/e9a165/"],["03.JavaScript高级程序设计/10.对象、类与面向对象编程.md","对象、类与面向对象编程","/pages/ab17e4/"],["03.JavaScript高级程序设计/11.代理与反射.md","代理与反射","/pages/911d11/"],["03.JavaScript高级程序设计/12.函数.md","函数","/pages/2aaf04/"],["03.JavaScript高级程序设计/13.期约与异步函数.md","期约与异步函数","/pages/789703/"]]},{title:"sass",collapsable:!0,children:[["04.sass/01.写在前面.md","写在前面","/pages/d0e9c2/"],["04.sass/02.sass基础.md","sass基础","/pages/29c00e/"]]},{title:"vue熟悉",collapsable:!0,children:[["05.vue熟悉/01.深度指南摘录.md","深度指南摘录","/pages/ce368e/"]]},{title:"前端存储",collapsable:!0,children:[["06.前端存储/01.indexedDB的应用.md","indexedDB的应用","/pages/78c7e2/"]]},{title:"opensumi",collapsable:!0,children:[["07.opensumi/01.opensumi介绍与使用.md","opensumi介绍与使用","/pages/8232ec/"]]},{title:"WebContainer",collapsable:!0,children:[["08.WebContainer/01.介绍与使用.md","介绍与使用","/pages/5f1228/"]]},{title:"storybook",collapsable:!0,children:[["09.storybook/01.介绍与使用.md","介绍与使用","/pages/8c2210/"]]},{title:"性能优化",collapsable:!0,children:[["10.性能优化/01.前端性能优化.md","前端性能优化","/pages/f51e80/"]]},{title:"卡颂React",collapsable:!0,children:[["11.卡颂React/01.前言.md","前言","/pages/ce5e4c/"],["11.卡颂React/02.环境搭建.md","环境搭建","/pages/d36b61/"],["11.卡颂React/03.小试牛刀.md","小试牛刀","/pages/98715f/"]]},{title:"JS基础",collapsable:!0,children:[["12.JS基础/01.面向对象.md","面向对象","/pages/59645f/"]]}],catalogue:{},"/02.场景/":[["01.场景.md","场景","/ui/"],["02.ResizeObserver防抖优化性能.md","ResizeObserver防抖优化性能","/pages/7deb64/"],["03.useAbortableRequest.md","useAbortableRequest","/pages/72b6d7/"],["04.RequestAnimationFrame与滚动.md","requestAnimation与滚动","/pages/8bee02/"],["05.支持promise的并发.md","支持promise的并发","/pages/d969d2/"],["06.单点登录场景与理解.md","单点登录场景与理解","/pages/016f34/"],["07.前端路由.md","前端路由","/pages/b1d0fe/"]],"/03.技术/":[["01.技术.md","技术","/technology/"],{title:"TypeScript",collapsable:!0,children:[["02.TypeScript/01.前言.md","前言","/pages/064912/"],["02.TypeScript/02.教程中的难点.md","教程中的难点","/pages/0a5e76/"],["02.TypeScript/03.教程中的难点2.md","教程中的难点2","/pages/e7bde6/"],["02.TypeScript/04.教程中的难点3.md","教程中的难点3","/pages/d8612d/"]]},{title:"NodeJS",collapsable:!0,children:[["03.NodeJS/01.sequelize学习.md","sequelize学习","/pages/0a08d6/"],["03.NodeJS/02.使用postman进行服务端开发.md","使用postman进行服务端开发","/pages/1d60cd/"]]},{title:"shell",collapsable:!0,children:[["04.shell/01.写在前面.md","写在前面","/pages/fbac8b/"],["04.shell/02.基础了解.md","基础了解","/pages/453cda/"],["04.shell/03.学习阮一峰bash教程.md","学习阮一峰bash教程","/pages/d72ce4/"]]},{title:"vscode开发",collapsable:!0,children:[["05.vscode开发/01.前言.md","前言","/pages/9a9b72/"],["05.vscode开发/02.vscode的command.md","vscode的command","/pages/16af6e/"],["05.vscode开发/03.树视图.md","树视图","/pages/8c3c18/"],["05.vscode开发/04.webview.md","webview","/pages/e6e3c2/"]]},{title:"图解HTTP阅读",collapsable:!0,children:[["06.图解HTTP阅读/01.了解Web及网络基础.md","了解Web及网络基础","/pages/3ebda0/"],["06.图解HTTP阅读/02.简单的HTTP协议.md","简单的HTTP协议","/pages/f3d2f4/"]]}],"/04.更多/":[["01.更多.md","更多","/more/"],{title:"个人记录",collapsable:!0,children:[["02.个人记录/01.2024年5月.md","2024年5月","/pages/29fb55/"]]},["03.专有名词学习.md","专有名词学习","/pages/815283/"],["04.好用工具.md","好用工具","/pages/8d7ea0/"],{title:"面试",collapsable:!0,children:[["05.面试/01.备战腾讯20240902.md","备战腾讯20240902","/pages/2d88c4/"]]}],"/05.关于/":[["01.关于.md","关于","/about/"]],"/06.收藏/":[["01.收藏.md","收藏","/favorite/"]]},author:{name:"leon yu",link:"https://github.com/lampeggiante"},blogger:{avatar:"/leonBlog/img/avatar.jpg",name:"Leon Yu",slogan:"做一个有个性的开发者～"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto: 1099052496@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/lampeggiante"}]},footer:{createYear:2024,copyrightInfo:'主题来自 Evan Xu | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a>'},extendFrontmatter:{author:{name:"leon yu",link:"https://github.com/lampeggiante"}}},locales:{"/":{lang:"zh-CN",title:"Leon's blog",description:"web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。",path:"/"}}};var Hs=t(93),Ws=t(94),Gs=t(11);var Ks={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(Gs.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(Gs.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Gs.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,o=n.length;r<o;r++){const{frontmatter:{categories:o,tags:a}}=n[r];"array"===Object(Gs.n)(o)&&o.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(Gs.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Wt.component(Hs.default),Wt.component(Ws.default);function Zs(n){return n.toString().padStart(2,"0")}t(243);Wt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,93))),Wt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,381))),Wt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,94)));t(244);var Xs=[({Vue:n,options:e,router:t,siteData:r})=>{},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Zs(n.getUTCMonth()+1)}-${Zs(n.getUTCDate())} ${Zs(n.getUTCHours())}:${Zs(n.getUTCMinutes())}:${Zs(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(Ks)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{}],Ys=[];class Qs extends class{constructor(){this.store=new Wt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Wt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Qs.prototype,{getPageAsyncComponent:ss,getLayoutAsyncComponent:ls,getAsyncComponent:cs,getVueComponent:us});var nl={install(n){const e=new Qs;n.$vuepress=e,n.prototype.$vuepress=e}};function el(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var tl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ds("pageKey",e),Wt.component(e)||Wt.component(e,ss(e)),Wt.component(e)?n(e):n("")}},rl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},ol={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},al=(t(245),t(246),Object(qs.a)(ol,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),il={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Wt.config.productionTip=!1,Wt.use(Vi),Wt.use(nl),Wt.mixin(function(n,e,t=Wt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(o).reduce((n,e)=>(e.startsWith("$")&&(n[e]=o[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Vs)),Wt.component("Content",tl),Wt.component("ContentSlotsDistributor",rl),Wt.component("OutboundLink",al),Wt.component("ClientOnly",il),Wt.component("Layout",ls("Layout")),Wt.component("NotFound",ls("NotFound")),Wt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.9",hash:"8261af0"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Vs.routerBase||Vs.base,t=new Vi({base:e,mode:"history",fallback:!1,routes:Js,scrollBehavior:(n,e,t)=>t||(n.hash?!Wt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(el(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";el(n,t)?r(t):r()}else r();else{const t=e.path+"/",o=e.path+".html";el(n,o)?r(o):el(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Xs.filter(n=>"function"==typeof n).map(e=>e({Vue:Wt,options:r,router:t,siteData:Vs,isServer:n})))}catch(n){console.error(n)}return{app:new Wt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ys.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);