---
title: 教程中的难点2
date: 2024-05-20 11:15:47
permalink: /pages/e7bde6/
categories:
  - 技术
  - TypeScript
tags:
  - 
author: 
  name: leon yu
  link: https://github.com/YuXingLiang214
---

:::tip
本文整理自 `TypeScript` 官方文档中的 handlebook，版本为 `V5.4`
:::

#### 对象的类型

- 对象的类型可以为匿名、类型别名、接口定义的

```ts
function fn(options: {
  childEle: HTMLElement
  parentEle: Element
  easing: (t: number) => number
  duration: number | "auto"
  callback?: () => void
}): void {} // options 的类型是直接定义的，即匿名的

type FnOptions = { // 使用类型别名定义
  childEle: HTMLElement
  parentEle: Element
  easing: (t: number) => number
  duration: number | "auto"
  callback?: () => void
}

interface FnOptionApi { // 使用接口定义
  childEle: HTMLElement
  parentEle: Element
  easing: (t: number) => number
  duration: number | "auto"
  callback?: () => void
}
```

- 类型中可以加入可选、只读、索引签名
  - 可选
```ts
type Person = {
  name: string
  age?: boolean // 实际上相当于设置 age 的属性为 boolean | undefined
}
```
- 只读
```ts
type Person = {
  name: string
  readonly age: boolean // 在属性名前面加上 readonly 标志符将会使属性变为只读的
}
const person: Person = {
  name: 'joker',
  age: 20 // age 属性不可更改，只允许读取
}
console.log(person.age) // 20
person.age = 21 // setter 被禁用了，此时将会报错

/**
 * @description ts 判断类型是否兼容时不会观察 readonly，可以通过这个特性将 readonly 变为可以修改的
 */
interface Person {
  name: string;
  age: number;
}
 
interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}
 
let writablePerson: Person = {
  name: "Person McPersonface",
  age: 42,
};
 
// works
let readonlyPerson: ReadonlyPerson = writablePerson;
 
console.log(readonlyPerson.age); // prints '42'
writablePerson.age++;
console.log(readonlyPerson.age); // prints '43'
```
- 类型修饰
```ts
/**
 * @description 类型索引可以帮助我们在不知道确切属性名的情况下对类型作出一定限制
 */
// 例如当前并不知道数组哪些位置上有值，但是知道时数组，并且对应的值都为
interface StringArray {
  [index: number]: string
}

const arr: StringArray = ['1', '2', '3']
// 索引签名属性允许 string number symbol 模版字符串 或者以上四种的组合
interface Person {
  name: string
  age: number
  [action: number | symbol]: () => void
}

const xiaoming: Person = { name: 'xiaoming', age: 20 }
const fnSymbol = Symbol('小明会跑')
xiaoming[fnSymbol] = () => { console.log('小明开始跑了') }
xiaoming[fnSymbol]()

// 索引签名可以设置 string | number | symbol 但是如果之前已经声明了相关类型，需要与之兼容

interface Dog {
  name: string
  age: number
  [action: string]: string | number // 只有这样才是与上面两种兼容的，或者将属性名的类型换成 number | symbol，这样才可以赋其他值
}

// 在索引签名中，也可以加入 readonly，只允许初始化时赋值，之后不可修改
```

- 使用 mapping 操作符可以去除可选和只读修饰符

```ts
/**
 * @description 使用 mapping 可以去除可选与只读的命令
 */
interface initialType {
  name?: string
  readonly age: number
  readonly [index: number]: string
  [action: symbol]: () => void
}

// 使用类型别名复制原来的类型
type copiedType = {
  [T in keyof initialType]: initialType[T]
}

// 使用类型别名去除可选属性的可选修饰符 name
type requiredType = {
  [T in keyof initialType]-?: initialType[T]
}

// 使用类型别名去除只读修饰符
type modifiableType = {
  -readonly [T in keyof initialType]: initialType[T]
}
```

- 在 `TypeScript` 4.1 以上，可以使用 as 操作符处理映射类型

```ts
/**
 * @description 使用 as 操作符来操作映射
 */
type Getters<T> = {
  [Property in keyof T as `get${Capitalize<string & Property>}`]: () => T[Property]
}
interface Person {
  name: string
  age: number
  location: string
}

type LazyPerson = Getters<Person>

// 可以通过将属性名的类型设置为 never 来过滤一些属性
type RemoveKindField<T> = {
  [Property in keyof T as Exclude<Property, "kind">]: T[Property]
}
interface Circle {
  kind: "circle";
  radius: number;
}

type KindlessCircle = RemoveKindField<Circle>;

// 可以联合的类型不只是 string | numebr | symbol
type EventConfig<Events extends { kind: string }> = {
  [E in Events as E["kind"]]: (event: E) => void;
}

type SquareEvent = { kind: "square", x: number, y: number };
type CircleEvent = { kind: "circle", radius: number };

type Config = EventConfig<SquareEvent | CircleEvent>

// 进阶类型操作
type ExtractPII<Type> = {
  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;
};
 
type DBFields = {
  id: { format: "incrementing" };
  name: { type: string; pii: true };
};
 
type ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;
```

- interface 与 type alias 都可以扩展类型，但是处理冲突的方式不一样

```ts
interface BasicAddress {
  name?: string;
  street: string;
  city: string;
  country: string;
  postalCode: string;
}
 
interface AddressWithUnit extends BasicAddress {
  unit: string;
}

interface Colorful1 {
  color: string;
}
 
interface Circle1 {
  radius: number;
}
 
interface ColorfulCircle extends Colorful1, Circle1 {}

type ColorfulCircle2 = Colorful1 & Circle1
 
const cc: ColorfulCircle = {
  color: "red",
  radius: 42,
};

const cc2: ColorfulCircle = {
  color: "red",
  radius: 42,
};

// 同一属性类型冲突
interface CircleArea {
  kind: 'circle'
  radius: number
  getArea: (radius: number) => number
}

interface rectArea {
  kind: 'rect'
  width: number
  getArea: (width: number) => number
}

interface newArea extends CircleArea, rectArea {} // 冲突后提示不能
type newArea2  = CircleArea & rectArea // 变为 never，但是不会报错
```

- 当能使用泛型时，优先使用泛型，而不是函数重载
- 数组和只读数组的定义就使用了泛型 `Array` 和 `ReadonlyArray`
  - `Array` 类型的值可以赋值给 `ReadonlyArray` 类型，反之则无法进行
- 元组类型定义了每个位置上的值的类型
  - 元组的可选操作符只能放在最后一位
  - 元组可以使用展开运算符，将对应的数组和元组类型加入到里面，例如 `type StringNumberBooleans = [string, number, ...boolean[]]`
  - 假设定义了某个元组并设置为 as const 将其类型设置为只读的元组是类似的
