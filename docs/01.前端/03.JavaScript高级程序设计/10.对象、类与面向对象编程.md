---
title: 对象、类与面向对象编程
date: 2024-08-28 12:02:36
permalink: /pages/ab17e4/
categories:
  - 前端
  - JavaScript高级程序设计
tags:
  - 
author: 
  name: leon yu
  link: https://github.com/lampeggiante
---

## 理解对象

### 属性类型

#### 数据类型

数据有四种类型，Configurable、Enumerable、Writable、Value

使用 `Object.defineProperty` 可以修改默认属性类型

访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4 个特性描述它们的行为。

Configurable表示是否可以通过 delete 删除并重新定义，默认为true

Enumerable表示是否可以通过 for-in 循环返回属性，默认为true

Writable表示是否可以修改属性的值，默认为true

Value表示属性的值，默认为undefined

访问器属性是不能直接定义的，必须使用Object.defineProperty()。下面是一个例子：

```javascript
let book = {
    _year: 2004,
    edition: 1
};

Object.defineProperty(book, "year", {
    get: function() {
        return this._year;
    },
    set: function(newValue) {
        if (newValue > 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});

book.year = 2005;
alert(book.edition); // 2
```

:::note
在ECMAScript 5 以前，开发者会使用两个非标准的访问创建访问器属性：`__define-Getter__()`和`__defineSetter__()`。这两个方法最早是Firefox 引入的，后来Safari、Chrome 和Opera 也实现了。
:::

### 定义多个属性

`Object.defineProperties()`方法可以定义多个属性

```javascript
let book = {};

Object.defineProperties(book, {
    _year: {
        value: 2004
    },
    edition: {
        value: 1
    },
    year: {
        get: function() {
            return this._year;
        },
        set: function(newValue) {
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});
```

### 读取属性的特性

使用 `Object.getOwnPropertyDescriptor()` 方法可以读取属性的属性描述符

ECMAScript 2017 新增了`Object.getOwnPropertyDescriptors()`静态方法。这个方法实际上会在每个自有属性上调用`Object.getOwnPropertyDescriptor()`并在一个新对象中返回它们。

### 合并对象

`Object.assign()`方法用于将所有可枚举的自有属性从一个或多个源对象复制到目标对象。它将返回目标对象。

Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。

### 对象标识及相等判定

在ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：

```js
// 这些是===符合预期的情况
console.log(true === 1); // false
console.log({} === {}); // false
console.log("2" === 2); // false
// 这些情况在不同JavaScript 引擎中表现不同，但仍被认为相等
console.log(+0 === -0); // true
console.log(+0 === 0); // true
console.log(-0 === 0); // true
// 要确定NaN 的相等性，必须使用极为讨厌的isNaN()
console.log(NaN === NaN); // false
console.log(isNaN(NaN)); // true
```

为改善这类情况，ECMAScript 6 规范新增了`Object.is()`，这个方法与===很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：

```js
console.log(Object.is(true, 1)); // false
console.log(Object.is({}, {})); // false
console.log(Object.is("2", 2)); // false
// 正确的0、-0、+0 相等/不等判定
console.log(Object.is(+0, -0)); // false
console.log(Object.is(+0, 0)); // true
console.log(Object.is(-0, 0)); // false
// 正确的NaN 相等判定
console.log(Object.is(NaN, NaN)); // true
// 要检查超过两个值，递归地利用相等性传递即可：
function recursivelyCheckEqual(x, ...rest) {
  return Object.is(x, rest[0]) &&
    (rest.length < 2 || recursivelyCheckEqual(...rest));
}
```

### 增强的属性语法

#### 属性简写

在属性名和变量名一致的时候，可以不用写两次

#### 可计算属性

用`[]`包裹属性名，可以动态计算属性名

:::warning
可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。
:::

#### 简写方法名

不需要使用 `object = { key: [Function] }` 这种形式，可以直接使用 `object = { key() { } }` 这种形式

### 对象解构

可以使用对象解构语法从对象中进行嵌套解构、部分解构、对函数参数进行解构

## 创建对象

### 工厂模式创建

使用函数方式，通过new一个Object并声明属性来批量创建对象。

缺点：没有解决对象标识类型

```js
function createPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        console.log(this.name);
    };
    return o;
}
```

### 构造函数模式

自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
  };
}
```

:::note
按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在ECMAScript 中区分构造函数和普通函数。毕竟ECMAScript 的构造函数就是能创建对象的函数。
:::

通过构造函数创建实例会执行如下操作：

- 在内存中创建一个新对象
- 这个新对象内部的 `[[Prototype]]` 特性被赋值为构造函数的 prototype 属性
- 构造函数内部的 `this` 被赋值为这个新对象（即 this 指向新对象）
- 执行构造函数内部的代码（给新对象添加属性）
- 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象

:::note
在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加
:::

#### 构造函数也是函数

:::note
构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用new 操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数。
:::

#### 构造函数的问题

:::note
构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。
:::

### 原型模式

:::note
使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型
:::

#### 理解原型

```js
/**
 * 构造函数可以是函数表达式
 * 也可以是函数声明，因此以下两种形式都可以：
 * function Person() {}
 * let Person = function() {}
 */
function Person() {}
/**
 * 声明之后，构造函数就有了一个
 * 与之关联的原型对象：
 */
console.log(typeof Person.prototype);
console.log(Person.prototype);
// {
// constructor: f Person(),
// __proto__: Object
// }
/**
 * 如前所述，构造函数有一个prototype 属性
 * 引用其原型对象，而这个原型对象也有一个
 * constructor 属性，引用这个构造函数
 * 换句话说，两者循环引用：
 */
console.log(Person.prototype.constructor === Person); // true
/**
 * 正常的原型链都会终止于Object 的原型对象
 * Object 原型的原型是null
 */
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Person.prototype.__proto__.constructor === Object); // true
console.log(Person.prototype.__proto__.__proto__ === null); // true
console.log(Person.prototype.__proto__);
// {
// constructor: f Object(),
// toString: ...
// hasOwnProperty: ...
// isPrototypeOf: ...
// ...
// }
let person1 = new Person(),
person2 = new Person();
/**
 * 构造函数、原型对象和实例
 * 是3 个完全不同的对象：
 */
console.log(person1 !== Person); // true
console.log(person1 !== Person.prototype); // true
console.log(Person.prototype !== Person); // true
/**
 * 实例通过__proto__链接到原型对象，
 * 它实际上指向隐藏特性[[Prototype]]
 *
 * 构造函数通过prototype 属性链接到原型对象
 *
 * 实例与构造函数没有直接联系，与原型对象有直接联系
 */
console.log(person1.__proto__ === Person.prototype); // true
conosle.log(person1.__proto__.constructor === Person); // true
/**
 * 同一个构造函数创建的两个实例
 * 共享同一个原型对象：
 */
console.log(person1.__proto__ === person2.__proto__); // true
/**
 * instanceof 检查实例的原型链中
 * 是否包含指定构造函数的原型：
 */
console.log(person1 instanceof Person); // true
console.log(person1 instanceof Object); // true
console.log(Person.prototype instanceof Object); // true
```

![理解原型](/leonBlog/img/prototype.png)

Object 类型还有一个setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系：

```js
let biped = {
  numLegs: 2
};
let person = {
  name: 'Matt'
};
Object.setPrototypeOf(person, biped);
console.log(person.name); // Matt
console.log(person.numLegs); // 2
console.log(Object.getPrototypeOf(person) === biped); // true
```

:::warning
`Object.setPrototypeOf()` 可能会严重影响代码性能。Mozilla 文档说得很清楚：“在所有浏览器和JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行`Object.setPrototypeOf()`语句那么简单，而是会涉及所有访问了那些修改过`[[Prototype]]`的对象的代码。”
:::

为避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型：

```js
let biped = {
  numLegs: 2
};
let person = Object.create(biped);
person.name = 'Matt';
console.log(person.name); // Matt
console.log(person.numLegs); // 2
console.log(Object.getPrototypeOf(person) === biped); // true
```

:::note
如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyNames()

Object.keys()和Object.getOwnPropertyNames()在适当的时候都可用来代替for-in 循环。

在ECMAScript 6 新增符号类型之后，相应地出现了增加一个Object.getOwnPropertyNames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，Object.getOwnProperty-Symbols()方法就出现了，这个方法与Object.getOwnPropertyNames()类似，只是针对符号而已。

for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnProperty-Symbols()以及Object.assign()在属性枚举顺序方面有很大区别。for-in 循环和Object.keys()的枚举顺序是不确定的，取决于JavaScript 引擎，可能因浏览器而异。
:::

:::note
因为从原型上搜索值的过程是**动态**的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。

重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。
:::

```js
function Person() {}
let friend = new Person();
Person.prototype = {
  constructor: Person,
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name);
  }
};
friend.sayName(); // 错误
```

#### 原型的问题

1. 它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值
2. 最主要问题源自它的共享特性。

:::tip
一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。
:::

## 继承
