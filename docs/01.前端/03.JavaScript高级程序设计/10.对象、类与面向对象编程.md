---
title: 对象、类与面向对象编程
date: 2024-08-28 12:02:36
permalink: /pages/ab17e4/
categories:
  - 前端
  - JavaScript高级程序设计
tags:
  - 
author: 
  name: leon yu
  link: https://github.com/lampeggiante
---

## 理解对象

### 属性类型

#### 数据类型

数据有四种类型，Configurable、Enumerable、Writable、Value

使用 `Object.defineProperty` 可以修改默认属性类型

访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4 个特性描述它们的行为。

Configurable表示是否可以通过 delete 删除并重新定义，默认为true

Enumerable表示是否可以通过 for-in 循环返回属性，默认为true

Writable表示是否可以修改属性的值，默认为true

Value表示属性的值，默认为undefined

访问器属性是不能直接定义的，必须使用Object.defineProperty()。下面是一个例子：

```javascript
let book = {
    _year: 2004,
    edition: 1
};

Object.defineProperty(book, "year", {
    get: function() {
        return this._year;
    },
    set: function(newValue) {
        if (newValue > 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});

book.year = 2005;
alert(book.edition); // 2
```

:::note
在ECMAScript 5 以前，开发者会使用两个非标准的访问创建访问器属性：`__define-Getter__()`和`__defineSetter__()`。这两个方法最早是Firefox 引入的，后来Safari、Chrome 和Opera 也实现了。
:::

### 定义多个属性

`Object.defineProperties()`方法可以定义多个属性

```javascript
let book = {};

Object.defineProperties(book, {
    _year: {
        value: 2004
    },
    edition: {
        value: 1
    },
    year: {
        get: function() {
            return this._year;
        },
        set: function(newValue) {
            if (newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    }
});
```

### 读取属性的特性

使用 `Object.getOwnPropertyDescriptor()` 方法可以读取属性的属性描述符

ECMAScript 2017 新增了`Object.getOwnPropertyDescriptors()`静态方法。这个方法实际上会在每个自有属性上调用`Object.getOwnPropertyDescriptor()`并在一个新对象中返回它们。

### 合并对象

`Object.assign()`方法用于将所有可枚举的自有属性从一个或多个源对象复制到目标对象。它将返回目标对象。

Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。

### 对象标识及相等判定

在ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：

```js
// 这些是===符合预期的情况
console.log(true === 1); // false
console.log({} === {}); // false
console.log("2" === 2); // false
// 这些情况在不同JavaScript 引擎中表现不同，但仍被认为相等
console.log(+0 === -0); // true
console.log(+0 === 0); // true
console.log(-0 === 0); // true
// 要确定NaN 的相等性，必须使用极为讨厌的isNaN()
console.log(NaN === NaN); // false
console.log(isNaN(NaN)); // true
```

为改善这类情况，ECMAScript 6 规范新增了`Object.is()`，这个方法与===很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：

```js
console.log(Object.is(true, 1)); // false
console.log(Object.is({}, {})); // false
console.log(Object.is("2", 2)); // false
// 正确的0、-0、+0 相等/不等判定
console.log(Object.is(+0, -0)); // false
console.log(Object.is(+0, 0)); // true
console.log(Object.is(-0, 0)); // false
// 正确的NaN 相等判定
console.log(Object.is(NaN, NaN)); // true
// 要检查超过两个值，递归地利用相等性传递即可：
function recursivelyCheckEqual(x, ...rest) {
  return Object.is(x, rest[0]) &&
    (rest.length < 2 || recursivelyCheckEqual(...rest));
}
```

### 增强的属性语法

#### 属性简写

在属性名和变量名一致的时候，可以不用写两次

#### 可计算属性

用`[]`包裹属性名，可以动态计算属性名

:::warning
可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。
:::

#### 简写方法名

不需要使用 `object = { key: [Function] }` 这种形式，可以直接使用 `object = { key() { } }` 这种形式

### 对象解构

可以使用对象解构语法从对象中进行嵌套解构、部分解构、对函数参数进行解构

