---
title: 基本引用类型
date: 2024-08-25 00:07:06
permalink: /pages/58a981/
categories:
  - 前端
  - JavaScript高级程序设计
tags:
  - 核心技术
author: 
  name: leon yu
  link: https://github.com/lampeggiante
---

:::note
引用类型与类是不等同的概念。

引用值（或者对象）是某个特定引用类型的实例。在ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。

引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆，本章后面不会使用术语“类”。

函数也是一种引用类型。
:::

## Date

### Date.UTC() 和 Date.parse()

Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。

Date.UTC 方法返回自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。这个方法接受年、月、日、小时、分钟、秒和毫秒作为参数，并返回一个表示该日期和时间的毫秒数。

ECMAScript 还提供了Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中。

:::tip
Date 引用类型的 toLocaleString() toString() ValueOf()在不同的浏览器表现不同，需要注意。
:::

## RegExp

正则表达式使用类似 Perl 的简洁语法进行创建

let expression = /pattern/flags

这个正则表达式的pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带**零个或多个flags（标记）**，用于控制正则表达式的行为。

### 表示匹配模式的标记

- g：全局模式，表示查找字符串的全部内容，而不是在找到第一个匹配项时停止。
- i：不区分大小写，表示在查找匹配项时忽略pattern和字符串的大小写。
- m：多行模式，表示查找到一行文本末尾时会继续查找下一行。
- y: 粘附模式，表示只查找从 lastIndex 开始及之后的字符串
- u: Unicode 模式，表示使用 Unicode 来匹配字符
- s: dotAll 模式，表示元字符.匹配任何字符，包括\n和\r

### RegExp 实例属性

每个RegExp 实例都有下列属性，提供有关模式的各方面信息。
- global：布尔值，表示是否设置了g 标记。
- ignoreCase：布尔值，表示是否设置了i 标记。
- unicode：布尔值，表示是否设置了u 标记。
- sticky：布尔值，表示是否设置了y 标记。
- lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从0 开始。
- multiline：布尔值，表示是否设置了m 标记。
- dotAll：布尔值，表示是否设置了s 标记。
- source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
- flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。

```js
let pattern1 = /\[bc\]at/i;
console.log(pattern1.global); // false
console.log(pattern1.ignoreCase); // true
console.log(pattern1.multiline); // false
console.log(pattern1.lastIndex); // 0
console.log(pattern1.source); // "\[bc\]at"
console.log(pattern1.flags); // "i"
let pattern2 = new RegExp("\\[bc\\]at", "i");
console.log(pattern2.global); // false
console.log(pattern2.ignoreCase); // true
console.log(pattern2.multiline); // false
console.log(pattern2.lastIndex); // 0
console.log(pattern2.source); // "\[bc\]at"
console.log(pattern2.flags); // "i"
```

### RegExp 实例方法

RegExp 实例的主要方法是exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。

如果模式中没有捕获组，则数组只包含一个元素

```js
let text = "mom and dad and baby";
let pattern = /mom( and dad( and baby)?)?/gi;
let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches.input); // "mom and dad and baby"
console.log(matches[0]); // "mom and dad and baby"
console.log(matches[1]); // " and dad and baby"
console.log(matches[2]); // " and baby"
```

在这个例子中，模式包含两个捕获组：最内部的匹配项" and baby"，以及外部的匹配项" and dad"或" and dad and baby"。调用exec()后找到了一个匹配项。因为整个字符串匹配模式，所以matchs数组的index 属性就是0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。

如果模式设置了全局标记，则每次调用exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次exec()，也只会返回第一个匹配的信息。

```js
let text = "cat, bat, sat, fat";
let pattern = /.at/;
let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches[0]); // cat
console.log(pattern.lastIndex); // 0
matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches[0]); // cat
console.log(pattern.lastIndex); // 0
```

这次模式设置了全局标记，因此每次调用exec()都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的lastIndex 属性每次都会变化。在全局匹配模式下，每次调用exec()都会更新lastIndex 值，以反映上次匹配的最后一个字符的索引。

如果模式设置了粘附标记y，则每次调用exec()就只会在lastIndex 的位置上寻找匹配项。粘附标记覆盖全局标记。

```js
let text = "cat, bat, sat, fat";
let pattern = /.at/y;
let matches = pattern.exec(text);
console.log(matches.index); // 0
console.log(matches[0]); // cat
console.log(pattern.lastIndex); // 3
// 以索引3 对应的字符开头找不到匹配项，因此exec()返回null
// exec()没找到匹配项，于是将lastIndex 设置为0
matches = pattern.exec(text);
console.log(matches); // null
console.log(pattern.lastIndex); // 0
// 向前设置lastIndex 可以让粘附的模式通过exec()找到下一个匹配项：
pattern.lastIndex = 5;
matches = pattern.exec(text);
console.log(matches.index); // 5
console.log(matches[0]); // bat
console.log(pattern.lastIndex); // 8
```

正则表达式的另一个方法是test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数
返回true，否则返回false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。
test()经常用在if 语句中。

### RegExp 构造函数属性

RegExp 构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了 RegExp 构造函数的属性。

- input $_ 最后搜索的字符串
- lastMatch $& 最后匹配的文本
- lastParen $+ 最后匹配的捕获组
- leftContext $` input 字符串中 lastMatch 之前的文本
- rightContext $' input 字符串中 lastMatch 之后的文本

```js
let text = "this has been a short summer";
let pattern = /(.)hort/g;
if (pattern.test(text)) {
  console.log(RegExp.input); // this has been a short summer
  console.log(RegExp.leftContext); // this has been a
  console.log(RegExp.rightContext); // summer
  console.log(RegExp.lastMatch); // short
  console.log(RegExp.lastParen); // s
  console.log(RegExp.$_); // this has been a short summer
  console.log(RegExp["$`"]); // this has been a
  console.log(RegExp["$'"]); // summer
  console.log(RegExp["$&"]); // short
  console.log(RegExp["$+"]); // s
}
```

RegExp 还有其他几个构造函数属性，可以存储最多9 个捕获组的匹配项。这些属性通过RegExp.$1~RegExp.$9 来访问，分别包含第1~9 个捕获组的匹配项。在调用exec()或test()时，这些属性就会被填充，然后就可以像下面这样使用它们：

```js
let text = "this has been a short summer";
let pattern = /(..)or(.)/g;
if (pattern.test(text)) {
  console.log(RegExp.$1); // sh
  console.log(RegExp.$2); // t
}
```


### 模式局限

:::note
虽然ECMAScript 对正则表达式的支持有了长足的进步，但仍然缺少Perl 语言中的一些高级特性。下列特性目前还没有得到ECMAScript 的支持（想要了解更多信息，可以参考Regular-Expressions.info网站）
- \A 和\Z 锚（分别匹配字符串的开始和末尾）
- 联合及交叉类
- 原子组
- x（忽略空格）匹配模式
- 条件式匹配
- 正则表达式注释
虽然还有这些局限，但ECMAScript 的正则表达式已经非常强大，可以用于大多数模式匹配任务。
:::

