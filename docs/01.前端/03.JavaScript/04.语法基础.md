---
title: 语法基础
date: 2024-08-02 10:40:56
permalink: /pages/de0153/
categories:
  - 前端
  - JavaScript
tags:
  - 核心技术
author: 
  name: leon yu
  link: https://github.com/YuXingLiang214
---

# JavaScript 语法基础

## 严格模式

ECMAScript  5 增加了严格模式（strict  mode）的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。

## let 与条件声明

使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。

当使用 `if` 或者 `try catch` 语法进行条件声明时，使用 let 声明的变量将会被局限在块内。

为此，对于let 这个新的ES6 声明关键字，不能依赖条件声明模式。

## typeof 中的注意事项

1. `typeof null` 结果将会是 'object'
2. 严格来说，`function` 不是对象，但是可以使用 `typeof` 操作符区分 `function` 与 其他对象

## 控制流最佳实践

控制流数据中条件判断建议使用 `if (标志符)`

## NaN 的含义

一个特殊的数值叫NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript 中，0、+0 或0 相除会返回NaN：

## 使用标签函数改变模版字符串的默认行文

模板字面量也支持定义标签函数（tag  function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。 标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。

```js
let a = 6; 
let b = 9;  
 
function simpleTag(strings, aValExpression, bValExpression, sumExpression) { 
  console.log(strings); 
  console.log(aValExpression); 
  console.log(bValExpression); 
  console.log(sumExpression); 
 
  return 'foobar'; 
} 
 
let untaggedResult = `${ a } + ${ b } = ${ a + b }`; 
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`; 
// ["", " + ", " = ", ""] 
// 6 
// 9 
// 15 
 
console.log(untaggedResult);   // "6 + 9 = 15" 
console.log(taggedResult);     // "foobar"
```

使用 `String.raw` 方法可以避免模版字符串的转义

## Symbol 类型

**用法**

- 作为唯一标志符
- 使用 `Symbol()` 生成唯一符号
- 不能使用 new 关键字（为了避免创建包装对象）
- 创建 Symbol 的包装对象可以通过 Object 函数，`Object(Symbol())`

### 使用全局符号注册表

使用 `Symbol.for()` 共享和重用同一个符号

```js
let fooGlobalSymbol = Symbol.for('foo')
console.log(typeof fooGlobalSymbol) // symbol
let otherGlobalSymbol = Symbol.for('foo')
console.log(fooGlobalSymbol === otherGlobalSymbol) // true
```

即使采用相同的符号描述，在全局注册表中定义的符号跟使用Symbol()定义的符号也并不等同： 
```js
let localSymbol = Symbol('foo'); 
let globalSymbol = Symbol.for('foo'); 
 
console.log(localSymbol === globalSymbol); // false
```

注册表中使用的键同时也会被用作符号描述。
```js
let emptyGlobalSymbol = Symbol.for(); 
console.log(emptyGlobalSymbol);    // Symbol(undefined)  
```

传给 Symbol.keyFor() 的值不是 Symbol 时，将会抛出 TypeError

### 使用 Symbol 作为属性

- 可以使用显示赋值，也可以使用 Object.defineProperty / Object.defineProperties 来使用Symbol作为属性

```js
let s1 = Symbol('foo'), 
    s2 = Symbol('bar'), 
    s3 = Symbol('baz'), 
    s4 = Symbol('qux'); 
 
let o = { 
  [s1]: 'foo val' 
}; 
// 这样也可以：o[s1] = 'foo val'; 
 
console.log(o); 
// {Symbol(foo): foo val} 
 
Object.defineProperty(o, s2, {value: 'bar val'}); 
 
console.log(o); 
// {Symbol(foo): foo val, Symbol(bar): bar val} 
 
Object.defineProperties(o, { 
  [s3]: {value: 'baz val'}, 
  [s4]: {value: 'qux val'} 
}); 
 
console.log(o); 
// {Symbol(foo): foo val, Symbol(bar): bar val, 
//  Symbol(baz): baz val, Symbol(qux): qux val}
```

- 将会返回常规属性，类似于`Object.getOwnPropertyNames()`返回对象实例的常规属性数组，`Object.getOwnPropertySymbols()`返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。`Object.getOwnPropertyDescriptors()`会返回同时包含常规和符号属性描述符的对象。`Reflect.ownKeys()`会返回两种类型的键。

```js
let s1 = Symbol('foo'), 
    s2 = Symbol('bar');  
 
let o = { 
  [s1]: 'foo val', 
  [s2]: 'bar val', 
  baz: 'baz val', 
  qux: 'qux val' 
}; 
 
console.log(Object.getOwnPropertySymbols(o)); 
// [Symbol(foo), Symbol(bar)] 
 
console.log(Object.getOwnPropertyNames(o)); 
// ["baz", "qux"] 
 
console.log(Object.getOwnPropertyDescriptors(o)); 
// {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}} 
 
console.log(Reflect.ownKeys(o)); 
// ["baz", "qux", Symbol(foo), Symbol(bar)]
```

- 如何没有显示保存 symbol 的属性名，只能通过过滤对应的属性值来寻找符号属性名了。

```js
let o = {  
  [Symbol('foo')]: 'foo val', 
  [Symbol('bar')]: 'bar val' 
}; 
 
console.log(o); 
// {Symbol(foo): "foo val", Symbol(bar): "bar val"} 
 
let barSymbol = Object.getOwnPropertySymbols(o) 
              .find((symbol) => symbol.toString().match(/bar/)); 
 
console.log(barSymbol); 
// Symbol(bar) 
```

### Symbol 作为内置符号

ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以Symbol 工厂函数字符串属性的形式存在。 这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道for-of 循环会在相关对象上使用 `Symbol.iterator` 属性，那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，来改变for-of 在迭代该对象时的行为。 这些内置符号也没有什么特别之处，它们就是全局函数Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。

:::tip
注意 在提到ECMAScript 规范时，经常会引用符号在规范中的名称，前缀为@@。比如，@@iterator 指的就是Symbol.iterator。
:::

### Symbol.asyncIterator

根据ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的AsyncIterator。由for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器API 的函数。 for-await-of 循环会利用这个函数执行异步迭代操作。循环时，它们会调用以Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器API 的对象。很多时候，返回的对象是实现该API的AsyncGenerator： 

```js
class Foo {  
  async *[Symbol.asyncIterator]() {} 
} 
 
let f = new Foo(); 
 
console.log(f[Symbol.asyncIterator]()); 
// AsyncGenerator {<suspended>}
```

技术上，这个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回Promise 实例。可以通过显式地调用next()方法返回，也可以隐式地通过异步生成器函数返回：
```js
class Emitter {  
  constructor(max) { 
    this.max = max; 
    this.asyncIdx = 0; 
  } 
 
  async *[Symbol.asyncIterator]() { 
    while(this.asyncIdx < this.max) { 
      yield new Promise((resolve) => resolve(this.asyncIdx++)); 
    } 
  } 
} 
 
async function asyncCount() { 
  let emitter = new Emitter(5); 
 
  for await(const x of emitter) { 
    console.log(x); 
  } 
} 
 
asyncCount(); 
// 0 
// 1 
// 2 
// 3 
// 4
```

:::tip
注意 Symbol.asyncIterator 是 ES2018 规范定义的，因此只有版本非常新的浏览器
支持它。
:::

